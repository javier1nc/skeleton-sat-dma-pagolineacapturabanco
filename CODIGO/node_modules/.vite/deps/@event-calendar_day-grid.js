import {
  addDay,
  ancestor,
  assign,
  bgEvent,
  btnTextMonth,
  cloneDate,
  createEventChunk,
  createEventClasses,
  createEventContent,
  datesEqual,
  debounce,
  eventIntersects,
  height,
  helperEvent,
  intl,
  isFunction,
  keyEnter,
  max,
  outsideEvent,
  prepareEventChunks,
  rect,
  repositionEvent,
  resourceBackgroundColor,
  resourceTextColor,
  runReposition,
  setContent,
  setPayload,
  subtractDay,
  task,
  themeView,
  toEventWithLocalDates,
  toISOString,
  toViewWithLocalDates
} from "./chunk-7XG6JH44.js";
import "./chunk-AYNHEKRI.js";
import {
  derived,
  writable
} from "./chunk-B3UEHWPT.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  set_store_value,
  space,
  stop_propagation,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-7XWKRO57.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-2TUXWMP5.js";

// node_modules/@event-calendar/day-grid/src/stores.js
function days(state) {
  return derived([state.date, state.firstDay, state.hiddenDays], ([$date, $firstDay, $hiddenDays]) => {
    let days2 = [];
    let day = cloneDate($date);
    let max2 = 7;
    while (day.getUTCDay() !== $firstDay && max2) {
      subtractDay(day);
      --max2;
    }
    for (let i = 0; i < 7; ++i) {
      if (!$hiddenDays.includes(day.getUTCDay())) {
        days2.push(cloneDate(day));
      }
      addDay(day);
    }
    return days2;
  });
}

// node_modules/@event-calendar/day-grid/src/Header.svelte
var file = "node_modules/@event-calendar/day-grid/src/Header.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let span;
  let span_aria_label_value;
  let setContent_action;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { "aria-label": true });
      children(span).forEach(detach_dev);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(span, "aria-label", span_aria_label_value = /*$_intlDayHeaderAL*/
      ctx[2].format(
        /*day*/
        ctx[8]
      ));
      add_location(span, file, 11, 16, 408);
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[0].day + " " + /*$theme*/
      ((_a = ctx[0].weekdays) == null ? void 0 : _a[
        /*day*/
        ctx[8].getUTCDay()
      ]));
      attr_dev(div, "role", "columnheader");
      add_location(div, file, 10, 12, 308);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(div, t);
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          span,
          /*$_intlDayHeader*/
          ctx[3].format(
            /*day*/
            ctx[8]
          )
        ));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty & /*$_intlDayHeaderAL, $_days*/
      6 && span_aria_label_value !== (span_aria_label_value = /*$_intlDayHeaderAL*/
      ctx[2].format(
        /*day*/
        ctx[8]
      ))) {
        attr_dev(span, "aria-label", span_aria_label_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_days*/
      10) setContent_action.update.call(
        null,
        /*$_intlDayHeader*/
        ctx[3].format(
          /*day*/
          ctx[8]
        )
      );
      if (dirty & /*$theme, $_days*/
      3 && div_class_value !== (div_class_value = /*$theme*/
      ctx[0].day + " " + /*$theme*/
      ((_a = ctx[0].weekdays) == null ? void 0 : _a[
        /*day*/
        ctx[8].getUTCDay()
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(10:8) {#each $_days as day}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div2;
  let div0;
  let div0_class_value;
  let t;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let each_value = ensure_array_like_dev(
    /*$_days*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true, role: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[0].days);
      attr_dev(div0, "role", "row");
      add_location(div0, file, 8, 4, 227);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[0].hiddenScroll);
      add_location(div1, file, 18, 4, 619);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[0].header);
      add_location(div2, file, 7, 0, 193);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader*/
      15) {
        each_value = ensure_array_like_dev(
          /*$_days*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$theme*/
      1 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[0].days)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*$theme*/
      1 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[0].hiddenScroll)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*$theme*/
      1 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx2[0].header)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $theme;
  let $_days;
  let $_intlDayHeaderAL;
  let $_intlDayHeader;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, []);
  let { theme, _intlDayHeader, _intlDayHeaderAL, _days } = getContext("state");
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(0, $theme = value));
  validate_store(_intlDayHeader, "_intlDayHeader");
  component_subscribe($$self, _intlDayHeader, (value) => $$invalidate(3, $_intlDayHeader = value));
  validate_store(_intlDayHeaderAL, "_intlDayHeaderAL");
  component_subscribe($$self, _intlDayHeaderAL, (value) => $$invalidate(2, $_intlDayHeaderAL = value));
  validate_store(_days, "_days");
  component_subscribe($$self, _days, (value) => $$invalidate(1, $_days = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    setContent,
    theme,
    _intlDayHeader,
    _intlDayHeaderAL,
    _days,
    $theme,
    $_days,
    $_intlDayHeaderAL,
    $_intlDayHeader
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2) $$invalidate(4, theme = $$props2.theme);
    if ("_intlDayHeader" in $$props2) $$invalidate(5, _intlDayHeader = $$props2._intlDayHeader);
    if ("_intlDayHeaderAL" in $$props2) $$invalidate(6, _intlDayHeaderAL = $$props2._intlDayHeaderAL);
    if ("_days" in $$props2) $$invalidate(7, _days = $$props2._days);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $theme,
    $_days,
    $_intlDayHeaderAL,
    $_intlDayHeader,
    theme,
    _intlDayHeader,
    _intlDayHeaderAL,
    _days
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment.name
    });
  }
};
var Header_default = Header;

// node_modules/@event-calendar/day-grid/src/Event.svelte
var file2 = "node_modules/@event-calendar/day-grid/src/Event.svelte";
function create_fragment2(ctx) {
  let article;
  let div;
  let div_class_value;
  let setContent_action;
  let t;
  let switch_instance;
  let article_role_value;
  let article_tabindex_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*$_interaction*/
    ctx[8].resizer
  );
  function switch_props(ctx2, dirty) {
    return {
      props: { event: (
        /*event*/
        ctx2[0]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("pointerdown", function() {
      if (is_function(
        /*createDragHandler*/
        ctx[32](
          /*$_interaction*/
          ctx[8],
          "x"
        )
      )) ctx[32](
        /*$_interaction*/
        ctx[8],
        "x"
      ).apply(this, arguments);
    });
  }
  const block = {
    c: function create() {
      article = element("article");
      div = element("div");
      t = space();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", {
        class: true,
        style: true,
        role: true,
        tabindex: true
      });
      var article_nodes = children(article);
      div = claim_element(article_nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      t = claim_space(article_nodes);
      if (switch_instance) claim_component(switch_instance.$$.fragment, article_nodes);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[2].eventBody);
      add_location(div, file2, 188, 4, 5807);
      attr_dev(
        article,
        "class",
        /*classes*/
        ctx[4]
      );
      attr_dev(
        article,
        "style",
        /*style*/
        ctx[5]
      );
      attr_dev(article, "role", article_role_value = /*onclick*/
      ctx[7] ? "button" : void 0);
      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/
      ctx[7] ? 0 : void 0);
      add_location(article, file2, 176, 0, 5371);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      append_hydration_dev(article, div);
      append_hydration_dev(article, t);
      if (switch_instance) mount_component(switch_instance, article, null);
      ctx[51](article);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            div,
            /*content*/
            ctx[6]
          )),
          listen_dev(
            article,
            "click",
            function() {
              if (is_function(
                /*onclick*/
                ctx[7] || void 0
              )) /*onclick*/
              (ctx[7] || void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "keydown",
            function() {
              if (is_function(
                /*onclick*/
                ctx[7] && keyEnter(
                  /*onclick*/
                  ctx[7]
                )
              )) /*onclick*/
              (ctx[7] && keyEnter(
                /*onclick*/
                ctx[7]
              )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "mouseenter",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[31](
                  /*$eventMouseEnter*/
                  ctx[9],
                  /*display*/
                  ctx[1]
                )
              )) ctx[31](
                /*$eventMouseEnter*/
                ctx[9],
                /*display*/
                ctx[1]
              ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "mouseleave",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[31](
                  /*$eventMouseLeave*/
                  ctx[10],
                  /*display*/
                  ctx[1]
                )
              )) ctx[31](
                /*$eventMouseLeave*/
                ctx[10],
                /*display*/
                ctx[1]
              ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "pointerdown",
            function() {
              if (is_function(!helperEvent(
                /*display*/
                ctx[1]
              ) && /*createDragHandler*/
              ctx[32](
                /*$_interaction*/
                ctx[8]
              ))) (!helperEvent(
                /*display*/
                ctx[1]
              ) && /*createDragHandler*/
              ctx[32](
                /*$_interaction*/
                ctx[8]
              )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      4 && div_class_value !== (div_class_value = /*$theme*/
      ctx[2].eventBody)) {
        attr_dev(div, "class", div_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/
      64) setContent_action.update.call(
        null,
        /*content*/
        ctx[6]
      );
      if (dirty[0] & /*$_interaction*/
      256 && switch_value !== (switch_value = /*$_interaction*/
      ctx[8].resizer)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          switch_instance.$on("pointerdown", function() {
            if (is_function(
              /*createDragHandler*/
              ctx[32](
                /*$_interaction*/
                ctx[8],
                "x"
              )
            )) ctx[32](
              /*$_interaction*/
              ctx[8],
              "x"
            ).apply(this, arguments);
          });
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, article, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*event*/
        1) switch_instance_changes.event = /*event*/
        ctx[0];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*classes*/
      16) {
        attr_dev(
          article,
          "class",
          /*classes*/
          ctx[4]
        );
      }
      if (!current || dirty[0] & /*style*/
      32) {
        attr_dev(
          article,
          "style",
          /*style*/
          ctx[5]
        );
      }
      if (!current || dirty[0] & /*onclick*/
      128 && article_role_value !== (article_role_value = /*onclick*/
      ctx[7] ? "button" : void 0)) {
        attr_dev(article, "role", article_role_value);
      }
      if (!current || dirty[0] & /*onclick*/
      128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/
      ctx[7] ? 0 : void 0)) {
        attr_dev(article, "tabindex", article_tabindex_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(article);
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[51](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $eventClick;
  let $_hiddenEvents;
  let $dayMaxEvents;
  let $_popupDate;
  let $_interaction;
  let $_view;
  let $eventAllUpdated;
  let $eventDidMount;
  let $_intlEventTime;
  let $theme;
  let $eventContent;
  let $displayEventEnd;
  let $eventClassNames;
  let $_iClasses;
  let $eventTextColor;
  let $resources;
  let $eventColor;
  let $eventBackgroundColor;
  let $eventMouseEnter;
  let $eventMouseLeave;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Event", slots, []);
  let { chunk } = $$props;
  let { longChunks = {} } = $$props;
  let { inPopup = false } = $$props;
  let { dates = [] } = $$props;
  let { dayMaxEvents, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, resources, theme, _view, _intlEventTime, _interaction, _iClasses, _hiddenEvents, _popupDate, _tasks } = getContext("state");
  validate_store(dayMaxEvents, "dayMaxEvents");
  component_subscribe($$self, dayMaxEvents, (value) => $$invalidate(54, $dayMaxEvents = value));
  validate_store(displayEventEnd, "displayEventEnd");
  component_subscribe($$self, displayEventEnd, (value) => $$invalidate(44, $displayEventEnd = value));
  validate_store(eventAllUpdated, "eventAllUpdated");
  component_subscribe($$self, eventAllUpdated, (value) => $$invalidate(56, $eventAllUpdated = value));
  validate_store(eventBackgroundColor, "eventBackgroundColor");
  component_subscribe($$self, eventBackgroundColor, (value) => $$invalidate(50, $eventBackgroundColor = value));
  validate_store(eventTextColor, "eventTextColor");
  component_subscribe($$self, eventTextColor, (value) => $$invalidate(47, $eventTextColor = value));
  validate_store(eventClick, "eventClick");
  component_subscribe($$self, eventClick, (value) => $$invalidate(40, $eventClick = value));
  validate_store(eventColor, "eventColor");
  component_subscribe($$self, eventColor, (value) => $$invalidate(49, $eventColor = value));
  validate_store(eventContent, "eventContent");
  component_subscribe($$self, eventContent, (value) => $$invalidate(43, $eventContent = value));
  validate_store(eventClassNames, "eventClassNames");
  component_subscribe($$self, eventClassNames, (value) => $$invalidate(45, $eventClassNames = value));
  validate_store(eventDidMount, "eventDidMount");
  component_subscribe($$self, eventDidMount, (value) => $$invalidate(57, $eventDidMount = value));
  validate_store(eventMouseEnter, "eventMouseEnter");
  component_subscribe($$self, eventMouseEnter, (value) => $$invalidate(9, $eventMouseEnter = value));
  validate_store(eventMouseLeave, "eventMouseLeave");
  component_subscribe($$self, eventMouseLeave, (value) => $$invalidate(10, $eventMouseLeave = value));
  validate_store(resources, "resources");
  component_subscribe($$self, resources, (value) => $$invalidate(48, $resources = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(2, $theme = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(41, $_view = value));
  validate_store(_intlEventTime, "_intlEventTime");
  component_subscribe($$self, _intlEventTime, (value) => $$invalidate(42, $_intlEventTime = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(8, $_interaction = value));
  validate_store(_iClasses, "_iClasses");
  component_subscribe($$self, _iClasses, (value) => $$invalidate(46, $_iClasses = value));
  validate_store(_hiddenEvents, "_hiddenEvents");
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(53, $_hiddenEvents = value));
  validate_store(_popupDate, "_popupDate");
  component_subscribe($$self, _popupDate, (value) => $$invalidate(55, $_popupDate = value));
  let el;
  let event;
  let classes;
  let style;
  let content;
  let timeText;
  let margin = 1;
  let hidden = false;
  let display;
  let onclick;
  onMount(() => {
    if (isFunction($eventDidMount)) {
      $eventDidMount({
        event: toEventWithLocalDates(event),
        timeText,
        el,
        view: toViewWithLocalDates($_view)
      });
    }
  });
  afterUpdate(() => {
    if (isFunction($eventAllUpdated) && !helperEvent(display)) {
      task(() => $eventAllUpdated({ view: toViewWithLocalDates($_view) }), "eau", _tasks);
    }
  });
  function createHandler(fn, display2) {
    return !helperEvent(display2) && isFunction(fn) ? (jsEvent) => fn({
      event: toEventWithLocalDates(event),
      el,
      jsEvent,
      view: toViewWithLocalDates($_view)
    }) : void 0;
  }
  function createDragHandler(interaction, resize) {
    return interaction.action ? (jsEvent) => $_interaction.action.drag(event, jsEvent, resize, inPopup ? $_popupDate : null, [rect(el).top - rect(ancestor(el, 1)).top, dates]) : void 0;
  }
  function reposition() {
    if (!el) {
      return;
    }
    $$invalidate(38, margin = repositionEvent(chunk, longChunks, height(el)));
    if ($dayMaxEvents === true) {
      hide();
    } else {
      $$invalidate(39, hidden = false);
    }
  }
  function hide() {
    let dayEl = ancestor(el, 2);
    let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
    $$invalidate(39, hidden = chunk.bottom > h);
    let update = false;
    for (let date of chunk.dates) {
      let hiddenEvents = $_hiddenEvents[date.getTime()];
      if (hiddenEvents) {
        let size = hiddenEvents.size;
        if (hidden) {
          hiddenEvents.add(chunk.event);
        } else {
          hiddenEvents.delete(chunk.event);
        }
        if (size !== hiddenEvents.size) {
          update = true;
        }
      }
    }
    if (update) {
      _hiddenEvents.set($_hiddenEvents);
    }
  }
  function footHeight(dayEl) {
    let h = 0;
    for (let i = 0; i < chunk.days; ++i) {
      h = max(h, height(dayEl.lastElementChild));
      dayEl = dayEl.nextElementSibling;
      if (!dayEl) {
        break;
      }
    }
    return h;
  }
  $$self.$$.on_mount.push(function() {
    if (chunk === void 0 && !("chunk" in $$props || $$self.$$.bound[$$self.$$.props["chunk"]])) {
      console.warn("<Event> was created without expected prop 'chunk'");
    }
  });
  const writable_props = ["chunk", "longChunks", "inPopup", "dates"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Event> was created with unknown prop '${key}'`);
  });
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("chunk" in $$props2) $$invalidate(33, chunk = $$props2.chunk);
    if ("longChunks" in $$props2) $$invalidate(34, longChunks = $$props2.longChunks);
    if ("inPopup" in $$props2) $$invalidate(35, inPopup = $$props2.inPopup);
    if ("dates" in $$props2) $$invalidate(36, dates = $$props2.dates);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    getContext,
    onMount,
    ancestor,
    createEventClasses,
    createEventContent,
    height,
    max,
    toEventWithLocalDates,
    toViewWithLocalDates,
    setContent,
    repositionEvent,
    resourceBackgroundColor,
    resourceTextColor,
    helperEvent,
    keyEnter,
    task,
    rect,
    bgEvent,
    isFunction,
    chunk,
    longChunks,
    inPopup,
    dates,
    dayMaxEvents,
    displayEventEnd,
    eventAllUpdated,
    eventBackgroundColor,
    eventTextColor,
    eventClick,
    eventColor,
    eventContent,
    eventClassNames,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    resources,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _iClasses,
    _hiddenEvents,
    _popupDate,
    _tasks,
    el,
    event,
    classes,
    style,
    content,
    timeText,
    margin,
    hidden,
    display,
    onclick,
    createHandler,
    createDragHandler,
    reposition,
    hide,
    footHeight,
    $eventClick,
    $_hiddenEvents,
    $dayMaxEvents,
    $_popupDate,
    $_interaction,
    $_view,
    $eventAllUpdated,
    $eventDidMount,
    $_intlEventTime,
    $theme,
    $eventContent,
    $displayEventEnd,
    $eventClassNames,
    $_iClasses,
    $eventTextColor,
    $resources,
    $eventColor,
    $eventBackgroundColor,
    $eventMouseEnter,
    $eventMouseLeave
  });
  $$self.$inject_state = ($$props2) => {
    if ("chunk" in $$props2) $$invalidate(33, chunk = $$props2.chunk);
    if ("longChunks" in $$props2) $$invalidate(34, longChunks = $$props2.longChunks);
    if ("inPopup" in $$props2) $$invalidate(35, inPopup = $$props2.inPopup);
    if ("dates" in $$props2) $$invalidate(36, dates = $$props2.dates);
    if ("dayMaxEvents" in $$props2) $$invalidate(11, dayMaxEvents = $$props2.dayMaxEvents);
    if ("displayEventEnd" in $$props2) $$invalidate(12, displayEventEnd = $$props2.displayEventEnd);
    if ("eventAllUpdated" in $$props2) $$invalidate(13, eventAllUpdated = $$props2.eventAllUpdated);
    if ("eventBackgroundColor" in $$props2) $$invalidate(14, eventBackgroundColor = $$props2.eventBackgroundColor);
    if ("eventTextColor" in $$props2) $$invalidate(15, eventTextColor = $$props2.eventTextColor);
    if ("eventClick" in $$props2) $$invalidate(16, eventClick = $$props2.eventClick);
    if ("eventColor" in $$props2) $$invalidate(17, eventColor = $$props2.eventColor);
    if ("eventContent" in $$props2) $$invalidate(18, eventContent = $$props2.eventContent);
    if ("eventClassNames" in $$props2) $$invalidate(19, eventClassNames = $$props2.eventClassNames);
    if ("eventDidMount" in $$props2) $$invalidate(20, eventDidMount = $$props2.eventDidMount);
    if ("eventMouseEnter" in $$props2) $$invalidate(21, eventMouseEnter = $$props2.eventMouseEnter);
    if ("eventMouseLeave" in $$props2) $$invalidate(22, eventMouseLeave = $$props2.eventMouseLeave);
    if ("resources" in $$props2) $$invalidate(23, resources = $$props2.resources);
    if ("theme" in $$props2) $$invalidate(24, theme = $$props2.theme);
    if ("_view" in $$props2) $$invalidate(25, _view = $$props2._view);
    if ("_intlEventTime" in $$props2) $$invalidate(26, _intlEventTime = $$props2._intlEventTime);
    if ("_interaction" in $$props2) $$invalidate(27, _interaction = $$props2._interaction);
    if ("_iClasses" in $$props2) $$invalidate(28, _iClasses = $$props2._iClasses);
    if ("_hiddenEvents" in $$props2) $$invalidate(29, _hiddenEvents = $$props2._hiddenEvents);
    if ("_popupDate" in $$props2) $$invalidate(30, _popupDate = $$props2._popupDate);
    if ("_tasks" in $$props2) _tasks = $$props2._tasks;
    if ("el" in $$props2) $$invalidate(3, el = $$props2.el);
    if ("event" in $$props2) $$invalidate(0, event = $$props2.event);
    if ("classes" in $$props2) $$invalidate(4, classes = $$props2.classes);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("content" in $$props2) $$invalidate(6, content = $$props2.content);
    if ("timeText" in $$props2) timeText = $$props2.timeText;
    if ("margin" in $$props2) $$invalidate(38, margin = $$props2.margin);
    if ("hidden" in $$props2) $$invalidate(39, hidden = $$props2.hidden);
    if ("display" in $$props2) $$invalidate(1, display = $$props2.display);
    if ("onclick" in $$props2) $$invalidate(7, onclick = $$props2.onclick);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*chunk*/
    4) {
      $: $$invalidate(0, event = chunk.event);
    }
    if ($$self.$$.dirty[0] & /*event, display, style, $theme*/
    39 | $$self.$$.dirty[1] & /*$resources, $eventBackgroundColor, $eventColor, $eventTextColor, chunk, margin, hidden, $_iClasses, $eventClassNames, $_view*/
    1033604) {
      $: {
        $$invalidate(1, display = event.display);
        let bgColor = event.backgroundColor || resourceBackgroundColor(event, $resources) || $eventBackgroundColor || $eventColor;
        let txtColor = event.textColor || resourceTextColor(event, $resources) || $eventTextColor;
        if (bgEvent(display)) {
          $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${chunk.days - 1}px);`);
        } else {
          let marginTop = margin;
          if (event._margin) {
            let [_margin, _dates] = event._margin;
            if (chunk.date >= _dates[0] && chunk.date <= _dates.at(-1)) {
              marginTop = _margin;
            }
          }
          $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);margin-top:${marginTop}px;`);
        }
        if (bgColor) {
          $$invalidate(5, style += `background-color:${bgColor};`);
        }
        if (txtColor) {
          $$invalidate(5, style += `color:${txtColor};`);
        }
        if (hidden) {
          $$invalidate(5, style += "visibility:hidden;");
        }
        $$invalidate(5, style += event.styles.join(";"));
        $$invalidate(4, classes = [
          bgEvent(display) ? $theme.bgEvent : $theme.event,
          ...$_iClasses([], event),
          ...createEventClasses($eventClassNames, event, $_view)
        ].join(" "));
      }
    }
    if ($$self.$$.dirty[0] & /*$theme*/
    4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/
    15364) {
      $: $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
    }
    if ($$self.$$.dirty[0] & /*display*/
    2 | $$self.$$.dirty[1] & /*$eventClick*/
    512) {
      $: $$invalidate(7, onclick = createHandler($eventClick, display));
    }
  };
  return [
    event,
    display,
    $theme,
    el,
    classes,
    style,
    content,
    onclick,
    $_interaction,
    $eventMouseEnter,
    $eventMouseLeave,
    dayMaxEvents,
    displayEventEnd,
    eventAllUpdated,
    eventBackgroundColor,
    eventTextColor,
    eventClick,
    eventColor,
    eventContent,
    eventClassNames,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    resources,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _iClasses,
    _hiddenEvents,
    _popupDate,
    createHandler,
    createDragHandler,
    chunk,
    longChunks,
    inPopup,
    dates,
    reposition,
    margin,
    hidden,
    $eventClick,
    $_view,
    $_intlEventTime,
    $eventContent,
    $displayEventEnd,
    $eventClassNames,
    $_iClasses,
    $eventTextColor,
    $resources,
    $eventColor,
    $eventBackgroundColor,
    article_binding
  ];
}
var Event = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        chunk: 33,
        longChunks: 34,
        inPopup: 35,
        dates: 36,
        reposition: 37
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Event",
      options,
      id: create_fragment2.name
    });
  }
  get chunk() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunk(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get longChunks() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set longChunks(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inPopup() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inPopup(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dates() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dates(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reposition() {
    return this.$$.ctx[37];
  }
  set reposition(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Event_default = Event;

// node_modules/@event-calendar/day-grid/src/Popup.svelte
var file3 = "node_modules/@event-calendar/day-grid/src/Popup.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event_default({
    props: { chunk: (
      /*chunk*/
      ctx[20]
    ), inPopup: true },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty & /*$_popupChunks*/
      1) event_changes.chunk = /*chunk*/
      ctx[20];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(100:8) {#each $_popupChunks as chunk (chunk.event)}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div2;
  let div0;
  let time;
  let time_datetime_value;
  let setContent_action;
  let t0;
  let a;
  let t1;
  let a_aria_label_value;
  let div0_class_value;
  let t2;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div1_class_value;
  let div2_class_value;
  let outsideEvent_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*$_popupChunks*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[20].event
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      time = element("time");
      t0 = space();
      a = element("a");
      t1 = text("×");
      t2 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      time = claim_element(div0_nodes, "TIME", { datetime: true });
      children(time).forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      a = claim_element(div0_nodes, "A", {
        role: true,
        tabindex: true,
        "aria-label": true
      });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "×");
      a_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(time, "datetime", time_datetime_value = toISOString(
        /*$_popupDate*/
        ctx[3],
        10
      ));
      add_location(time, file3, 88, 8, 2732);
      attr_dev(a, "role", "button");
      attr_dev(a, "tabindex", "0");
      attr_dev(a, "aria-label", a_aria_label_value = /*$buttonText*/
      ctx[6].close);
      add_location(a, file3, 90, 8, 2904);
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[4].dayHead);
      add_location(div0, file3, 87, 4, 2693);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[4].events);
      add_location(div1, file3, 98, 4, 3123);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[4].popup);
      attr_dev(
        div2,
        "style",
        /*style*/
        ctx[2]
      );
      add_location(div2, file3, 79, 0, 2499);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, time);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, a);
      append_hydration_dev(a, t1);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      ctx[16](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            time,
            /*$_intlDayPopover*/
            ctx[5].format(
              /*$_popupDate*/
              ctx[3]
            )
          )),
          listen_dev(a, "click", stop_propagation(
            /*close*/
            ctx[13]
          ), false, false, true, false),
          listen_dev(a, "keydown", keyEnter(
            /*close*/
            ctx[13]
          ), false, false, false, false),
          action_destroyer(outsideEvent_action = outsideEvent.call(null, div2, "pointerdown")),
          listen_dev(div2, "pointerdown", stop_propagation(
            /*pointerdown_handler*/
            ctx[15]
          ), false, false, true, false),
          listen_dev(
            div2,
            "pointerdownoutside",
            /*handlePointerDownOutside*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*$_popupDate*/
      8 && time_datetime_value !== (time_datetime_value = toISOString(
        /*$_popupDate*/
        ctx2[3],
        10
      ))) {
        attr_dev(time, "datetime", time_datetime_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayPopover, $_popupDate*/
      40) setContent_action.update.call(
        null,
        /*$_intlDayPopover*/
        ctx2[5].format(
          /*$_popupDate*/
          ctx2[3]
        )
      );
      if (!current || dirty & /*$buttonText*/
      64 && a_aria_label_value !== (a_aria_label_value = /*$buttonText*/
      ctx2[6].close)) {
        attr_dev(a, "aria-label", a_aria_label_value);
      }
      if (!current || dirty & /*$theme*/
      16 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[4].dayHead)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*$_popupChunks*/
      1) {
        each_value = ensure_array_like_dev(
          /*$_popupChunks*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      16 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[4].events)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$theme*/
      16 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx2[4].popup)) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*style*/
      4) {
        attr_dev(
          div2,
          "style",
          /*style*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_interaction;
  let $_popupDate;
  let $_popupChunks;
  let $theme;
  let $_intlDayPopover;
  let $buttonText;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popup", slots, []);
  let { buttonText, theme, _interaction, _intlDayPopover, _popupDate, _popupChunks } = getContext("state");
  validate_store(buttonText, "buttonText");
  component_subscribe($$self, buttonText, (value) => $$invalidate(6, $buttonText = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(4, $theme = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(17, $_interaction = value));
  validate_store(_intlDayPopover, "_intlDayPopover");
  component_subscribe($$self, _intlDayPopover, (value) => $$invalidate(5, $_intlDayPopover = value));
  validate_store(_popupDate, "_popupDate");
  component_subscribe($$self, _popupDate, (value) => $$invalidate(3, $_popupDate = value));
  validate_store(_popupChunks, "_popupChunks");
  component_subscribe($$self, _popupChunks, (value) => $$invalidate(0, $_popupChunks = value));
  let el;
  let style = "";
  function position() {
    let dayEl = ancestor(el, 1);
    let bodyEl = ancestor(dayEl, 3);
    let popupRect = rect(el);
    let dayRect = rect(dayEl);
    let bodyRect = rect(bodyEl);
    $$invalidate(2, style = "");
    let left;
    if (popupRect.width >= bodyRect.width) {
      left = bodyRect.left - dayRect.left;
      let right = dayRect.right - bodyRect.right;
      $$invalidate(2, style += `right:${right}px;`);
    } else {
      left = (dayRect.width - popupRect.width) / 2;
      if (dayRect.left + left < bodyRect.left) {
        left = bodyRect.left - dayRect.left;
      } else if (dayRect.left + left + popupRect.width > bodyRect.right) {
        left = bodyRect.right - dayRect.left - popupRect.width;
      }
    }
    $$invalidate(2, style += `left:${left}px;`);
    let top;
    if (popupRect.height >= bodyRect.height) {
      top = bodyRect.top - dayRect.top;
      let bottom = dayRect.bottom - bodyRect.bottom;
      $$invalidate(2, style += `bottom:${bottom}px;`);
    } else {
      top = (dayRect.height - popupRect.height) / 2;
      if (dayRect.top + top < bodyRect.top) {
        top = bodyRect.top - dayRect.top;
      } else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
        top = bodyRect.bottom - dayRect.top - popupRect.height;
      }
    }
    $$invalidate(2, style += `top:${top}px;`);
  }
  function reposition() {
    if (el) {
      $$invalidate(2, style = "");
      tick().then(() => {
        if ($_popupChunks.length) {
          position();
        } else {
          close();
        }
      });
    }
  }
  function close(e) {
    set_store_value(_popupDate, $_popupDate = null, $_popupDate);
  }
  function handlePointerDownOutside(e) {
    var _a;
    close();
    (_a = $_interaction.action) == null ? void 0 : _a.noClick();
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Popup> was created with unknown prop '${key}'`);
  });
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$capture_state = () => ({
    getContext,
    tick,
    ancestor,
    rect,
    setContent,
    outsideEvent,
    keyEnter,
    toISOString,
    Event: Event_default,
    buttonText,
    theme,
    _interaction,
    _intlDayPopover,
    _popupDate,
    _popupChunks,
    el,
    style,
    position,
    reposition,
    close,
    handlePointerDownOutside,
    $_interaction,
    $_popupDate,
    $_popupChunks,
    $theme,
    $_intlDayPopover,
    $buttonText
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttonText" in $$props2) $$invalidate(7, buttonText = $$props2.buttonText);
    if ("theme" in $$props2) $$invalidate(8, theme = $$props2.theme);
    if ("_interaction" in $$props2) $$invalidate(9, _interaction = $$props2._interaction);
    if ("_intlDayPopover" in $$props2) $$invalidate(10, _intlDayPopover = $$props2._intlDayPopover);
    if ("_popupDate" in $$props2) $$invalidate(11, _popupDate = $$props2._popupDate);
    if ("_popupChunks" in $$props2) $$invalidate(12, _popupChunks = $$props2._popupChunks);
    if ("el" in $$props2) $$invalidate(1, el = $$props2.el);
    if ("style" in $$props2) $$invalidate(2, style = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_popupChunks*/
    1) {
      $: if ($_popupChunks) {
        reposition();
      }
    }
  };
  return [
    $_popupChunks,
    el,
    style,
    $_popupDate,
    $theme,
    $_intlDayPopover,
    $buttonText,
    buttonText,
    theme,
    _interaction,
    _intlDayPopover,
    _popupDate,
    _popupChunks,
    close,
    handlePointerDownOutside,
    pointerdown_handler,
    div2_binding
  ];
}
var Popup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popup",
      options,
      id: create_fragment3.name
    });
  }
};
var Popup_default = Popup;

// node_modules/@event-calendar/day-grid/src/Day.svelte
var file4 = "node_modules/@event-calendar/day-grid/src/Day.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  child_ctx[45] = list;
  child_ctx[46] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  return child_ctx;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event_default({
    props: { chunk: (
      /*chunk*/
      ctx[44]
    ) },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty[0] & /*dayBgChunks*/
      256) event_changes.chunk = /*chunk*/
      ctx[44];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(104:8) {#each dayBgChunks as chunk (chunk.event)}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let event;
  let div_class_value;
  let current;
  event = new Event_default({
    props: { chunk: (
      /*iChunks*/
      ctx[2][2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(event.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[14].events);
      add_location(div, file4, 109, 8, 3612);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(event, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*iChunks*/
      4) event_changes.chunk = /*iChunks*/
      ctx2[2][2];
      event.$set(event_changes);
      if (!current || dirty[0] & /*$theme*/
      16384 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[14].events)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(event);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(109:4) {#if iChunks[2] && datesEqual(iChunks[2].date, date)}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let event;
  let div_class_value;
  let current;
  event = new Event_default({
    props: { chunk: (
      /*iChunks*/
      ctx[2][0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(event.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[14].events + " " + /*$theme*/
      ctx[14].preview);
      add_location(div, file4, 115, 8, 3800);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(event, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*iChunks*/
      4) event_changes.chunk = /*iChunks*/
      ctx2[2][0];
      event.$set(event_changes);
      if (!current || dirty[0] & /*$theme*/
      16384 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[14].events + " " + /*$theme*/
      ctx2[14].preview)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(event);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(115:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let first;
  let event;
  let i = (
    /*i*/
    ctx[46]
  );
  let current;
  const assign_event = () => (
    /*event_binding*/
    ctx[38](event, i)
  );
  const unassign_event = () => (
    /*event_binding*/
    ctx[38](null, i)
  );
  let event_props = {
    chunk: (
      /*chunk*/
      ctx[44]
    ),
    longChunks: (
      /*longChunks*/
      ctx[1]
    ),
    dates: (
      /*dates*/
      ctx[3]
    )
  };
  event = new Event_default({ props: event_props, $$inline: true });
  assign_event();
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (i !== /*i*/
      ctx[46]) {
        unassign_event();
        i = /*i*/
        ctx[46];
        assign_event();
      }
      const event_changes = {};
      if (dirty[0] & /*dayChunks*/
      32) event_changes.chunk = /*chunk*/
      ctx[44];
      if (dirty[0] & /*longChunks*/
      2) event_changes.longChunks = /*longChunks*/
      ctx[1];
      if (dirty[0] & /*dates*/
      8) event_changes.dates = /*dates*/
      ctx[3];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      unassign_event();
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(121:8) {#each dayChunks as chunk, i (chunk.event)}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let popup;
  let current;
  popup = new Popup_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(popup.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popup.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popup, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(125:4) {#if showPopup}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let a;
  let setContent_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        role: true,
        tabindex: true,
        "aria-haspopup": true
      });
      children(a).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "role", "button");
      attr_dev(a, "tabindex", "0");
      attr_dev(a, "aria-haspopup", "true");
      add_location(a, file4, 131, 12, 4336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", stop_propagation(
            /*showMore*/
            ctx[27]
          ), false, false, true, false),
          listen_dev(a, "keydown", keyEnter(
            /*showMore*/
            ctx[27]
          ), false, false, false, false),
          listen_dev(a, "pointerdown", stop_propagation(
            /*pointerdown_handler*/
            ctx[37]
          ), false, false, true, false),
          action_destroyer(setContent_action = setContent.call(
            null,
            a,
            /*moreLink*/
            ctx[12]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/
      4096) setContent_action.update.call(
        null,
        /*moreLink*/
        ctx2[12]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(129:8) {#if hiddenEvents.size}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div3;
  let time;
  let time_class_value;
  let time_datetime_value;
  let setContent_action;
  let t0;
  let div0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let t1;
  let show_if_1 = (
    /*iChunks*/
    ctx[2][2] && datesEqual(
      /*iChunks*/
      ctx[2][2].date,
      /*date*/
      ctx[0]
    )
  );
  let t2;
  let show_if = (
    /*iChunks*/
    ctx[2][0] && datesEqual(
      /*iChunks*/
      ctx[2][0].date,
      /*date*/
      ctx[0]
    )
  );
  let t3;
  let div1;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let div1_class_value;
  let t4;
  let t5;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*dayBgChunks*/
    ctx[8]
  );
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[44].event
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
  }
  let if_block0 = show_if_1 && create_if_block_3(ctx);
  let if_block1 = show_if && create_if_block_2(ctx);
  let each_value = ensure_array_like_dev(
    /*dayChunks*/
    ctx[5]
  );
  const get_key_1 = (ctx2) => (
    /*chunk*/
    ctx2[44].event
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  let if_block2 = (
    /*showPopup*/
    ctx[7] && create_if_block_1(ctx)
  );
  let if_block3 = (
    /*hiddenEvents*/
    ctx[6].size && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      time = element("time");
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block2) if_block2.c();
      t5 = space();
      div2 = element("div");
      if (if_block3) if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, role: true });
      var div3_nodes = children(div3);
      time = claim_element(div3_nodes, "TIME", { class: true, datetime: true });
      children(time).forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      if (if_block0) if_block0.l(div3_nodes);
      t2 = claim_space(div3_nodes);
      if (if_block1) if_block1.l(div3_nodes);
      t3 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      if (if_block2) if_block2.l(div3_nodes);
      t5 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block3) if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(time, "class", time_class_value = /*$theme*/
      ctx[14].dayHead);
      attr_dev(time, "datetime", time_datetime_value = toISOString(
        /*date*/
        ctx[0],
        10
      ));
      add_location(time, file4, 97, 4, 3235);
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[14].bgEvents);
      add_location(div0, file4, 102, 4, 3386);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[14].events);
      add_location(div1, file4, 119, 4, 3916);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[14].dayFoot);
      add_location(div2, file4, 127, 4, 4147);
      attr_dev(div3, "class", div3_class_value = /*$theme*/
      ctx[14].day + " " + /*$theme*/
      ((_a = ctx[14].weekdays) == null ? void 0 : _a[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[9] ? " " + /*$theme*/
      ctx[14].today : "") + /*otherMonth*/
      (ctx[10] ? " " + /*$theme*/
      ctx[14].otherMonth : "") + /*highlight*/
      (ctx[11] ? " " + /*$theme*/
      ctx[14].highlight : ""));
      attr_dev(div3, "role", "cell");
      add_location(div3, file4, 90, 0, 2906);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, time);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      append_hydration_dev(div3, t1);
      if (if_block0) if_block0.m(div3, null);
      append_hydration_dev(div3, t2);
      if (if_block1) if_block1.m(div3, null);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append_hydration_dev(div3, t4);
      if (if_block2) if_block2.m(div3, null);
      append_hydration_dev(div3, t5);
      append_hydration_dev(div3, div2);
      if (if_block3) if_block3.m(div2, null);
      ctx[39](div3);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            time,
            /*$_intlDayCell*/
            ctx[16].format(
              /*date*/
              ctx[0]
            )
          )),
          listen_dev(
            div3,
            "pointerleave",
            function() {
              var _a, _b;
              if (is_function(
                /*$_interaction*/
                (_a = ctx[15].pointer) == null ? void 0 : _a.leave
              )) (_b = ctx[15].pointer) == null ? void 0 : _b.leave.apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "pointerdown",
            function() {
              var _a, _b;
              if (is_function(
                /*$_interaction*/
                (_a = ctx[15].action) == null ? void 0 : _a.select
              )) (_b = ctx[15].action) == null ? void 0 : _b.select.apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      16384 && time_class_value !== (time_class_value = /*$theme*/
      ctx[14].dayHead)) {
        attr_dev(time, "class", time_class_value);
      }
      if (!current || dirty[0] & /*date*/
      1 && time_datetime_value !== (time_datetime_value = toISOString(
        /*date*/
        ctx[0],
        10
      ))) {
        attr_dev(time, "datetime", time_datetime_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayCell, date*/
      65537) setContent_action.update.call(
        null,
        /*$_intlDayCell*/
        ctx[16].format(
          /*date*/
          ctx[0]
        )
      );
      if (dirty[0] & /*dayBgChunks*/
      256) {
        each_value_1 = ensure_array_like_dev(
          /*dayBgChunks*/
          ctx[8]
        );
        group_outros();
        validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      16384 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[14].bgEvents)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*iChunks, date*/
      5) show_if_1 = /*iChunks*/
      ctx[2][2] && datesEqual(
        /*iChunks*/
        ctx[2][2].date,
        /*date*/
        ctx[0]
      );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*iChunks, date*/
          5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*iChunks, date*/
      5) show_if = /*iChunks*/
      ctx[2][0] && datesEqual(
        /*iChunks*/
        ctx[2][0].date,
        /*date*/
        ctx[0]
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*iChunks, date*/
          5) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*dayChunks, longChunks, dates, refs*/
      8234) {
        each_value = ensure_array_like_dev(
          /*dayChunks*/
          ctx[5]
        );
        group_outros();
        validate_each_keys(ctx, each_value, get_each_context3, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, outro_and_destroy_block, create_each_block3, null, get_each_context3);
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      16384 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[14].events)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*showPopup*/
        ctx[7]
      ) {
        if (if_block2) {
          if (dirty[0] & /*showPopup*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div3, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hiddenEvents*/
        ctx[6].size
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if_block3 = create_if_block(ctx);
          if_block3.c();
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty[0] & /*$theme*/
      16384 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx[14].dayFoot)) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*$theme, date, isToday, otherMonth, highlight*/
      19969 && div3_class_value !== (div3_class_value = /*$theme*/
      ctx[14].day + " " + /*$theme*/
      ((_a = ctx[14].weekdays) == null ? void 0 : _a[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[9] ? " " + /*$theme*/
      ctx[14].today : "") + /*otherMonth*/
      (ctx[10] ? " " + /*$theme*/
      ctx[14].otherMonth : "") + /*highlight*/
      (ctx[11] ? " " + /*$theme*/
      ctx[14].highlight : ""))) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(if_block0);
      transition_out(if_block1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $_popupChunks;
  let $_popupDate;
  let $moreLinkContent;
  let $_hiddenEvents;
  let $highlightedDates;
  let $currentDate;
  let $_today;
  let $theme;
  let $_interaction;
  let $_intlDayCell;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Day", slots, []);
  let { date } = $$props;
  let { chunks } = $$props;
  let { bgChunks } = $$props;
  let { longChunks } = $$props;
  let { iChunks = [] } = $$props;
  let { dates } = $$props;
  let { date: currentDate, dayMaxEvents, highlightedDates, moreLinkContent, theme, _hiddenEvents, _intlDayCell, _popupDate, _popupChunks, _today, _interaction, _queue } = getContext("state");
  validate_store(currentDate, "currentDate");
  component_subscribe($$self, currentDate, (value) => $$invalidate(35, $currentDate = value));
  validate_store(highlightedDates, "highlightedDates");
  component_subscribe($$self, highlightedDates, (value) => $$invalidate(34, $highlightedDates = value));
  validate_store(moreLinkContent, "moreLinkContent");
  component_subscribe($$self, moreLinkContent, (value) => $$invalidate(32, $moreLinkContent = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(14, $theme = value));
  validate_store(_hiddenEvents, "_hiddenEvents");
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(33, $_hiddenEvents = value));
  validate_store(_intlDayCell, "_intlDayCell");
  component_subscribe($$self, _intlDayCell, (value) => $$invalidate(16, $_intlDayCell = value));
  validate_store(_popupDate, "_popupDate");
  component_subscribe($$self, _popupDate, (value) => $$invalidate(31, $_popupDate = value));
  validate_store(_popupChunks, "_popupChunks");
  component_subscribe($$self, _popupChunks, (value) => $$invalidate(40, $_popupChunks = value));
  validate_store(_today, "_today");
  component_subscribe($$self, _today, (value) => $$invalidate(36, $_today = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(15, $_interaction = value));
  let el;
  let dayChunks, dayBgChunks;
  let isToday;
  let otherMonth;
  let highlight;
  let hiddenEvents = /* @__PURE__ */ new Set();
  let moreLink = "";
  let showPopup;
  let refs = [];
  function showMore() {
    set_store_value(_popupDate, $_popupDate = date, $_popupDate);
  }
  function setPopupChunks() {
    var _a;
    let nextDay = addDay(cloneDate(date));
    let chunks2 = dayChunks.concat(((_a = longChunks[date.getTime()]) == null ? void 0 : _a.chunks) || []);
    set_store_value(_popupChunks, $_popupChunks = chunks2.map((chunk) => assign({}, chunk, createEventChunk(chunk.event, date, nextDay), { days: 1, dates: [date] })).sort((a, b) => a.top - b.top), $_popupChunks);
  }
  function reposition() {
    runReposition(refs, dayChunks);
  }
  $$self.$$.on_mount.push(function() {
    if (date === void 0 && !("date" in $$props || $$self.$$.bound[$$self.$$.props["date"]])) {
      console.warn("<Day> was created without expected prop 'date'");
    }
    if (chunks === void 0 && !("chunks" in $$props || $$self.$$.bound[$$self.$$.props["chunks"]])) {
      console.warn("<Day> was created without expected prop 'chunks'");
    }
    if (bgChunks === void 0 && !("bgChunks" in $$props || $$self.$$.bound[$$self.$$.props["bgChunks"]])) {
      console.warn("<Day> was created without expected prop 'bgChunks'");
    }
    if (longChunks === void 0 && !("longChunks" in $$props || $$self.$$.bound[$$self.$$.props["longChunks"]])) {
      console.warn("<Day> was created without expected prop 'longChunks'");
    }
    if (dates === void 0 && !("dates" in $$props || $$self.$$.bound[$$self.$$.props["dates"]])) {
      console.warn("<Day> was created without expected prop 'dates'");
    }
  });
  const writable_props = ["date", "chunks", "bgChunks", "longChunks", "iChunks", "dates"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Day> was created with unknown prop '${key}'`);
  });
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function event_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refs[i] = $$value;
      $$invalidate(13, refs);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(4, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2) $$invalidate(0, date = $$props2.date);
    if ("chunks" in $$props2) $$invalidate(28, chunks = $$props2.chunks);
    if ("bgChunks" in $$props2) $$invalidate(29, bgChunks = $$props2.bgChunks);
    if ("longChunks" in $$props2) $$invalidate(1, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2) $$invalidate(2, iChunks = $$props2.iChunks);
    if ("dates" in $$props2) $$invalidate(3, dates = $$props2.dates);
  };
  $$self.$capture_state = () => ({
    getContext,
    tick,
    datesEqual,
    setContent,
    createEventChunk,
    addDay,
    cloneDate,
    assign,
    setPayload,
    toISOString,
    keyEnter,
    runReposition,
    isFunction,
    Event: Event_default,
    Popup: Popup_default,
    date,
    chunks,
    bgChunks,
    longChunks,
    iChunks,
    dates,
    currentDate,
    dayMaxEvents,
    highlightedDates,
    moreLinkContent,
    theme,
    _hiddenEvents,
    _intlDayCell,
    _popupDate,
    _popupChunks,
    _today,
    _interaction,
    _queue,
    el,
    dayChunks,
    dayBgChunks,
    isToday,
    otherMonth,
    highlight,
    hiddenEvents,
    moreLink,
    showPopup,
    refs,
    showMore,
    setPopupChunks,
    reposition,
    $_popupChunks,
    $_popupDate,
    $moreLinkContent,
    $_hiddenEvents,
    $highlightedDates,
    $currentDate,
    $_today,
    $theme,
    $_interaction,
    $_intlDayCell
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2) $$invalidate(0, date = $$props2.date);
    if ("chunks" in $$props2) $$invalidate(28, chunks = $$props2.chunks);
    if ("bgChunks" in $$props2) $$invalidate(29, bgChunks = $$props2.bgChunks);
    if ("longChunks" in $$props2) $$invalidate(1, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2) $$invalidate(2, iChunks = $$props2.iChunks);
    if ("dates" in $$props2) $$invalidate(3, dates = $$props2.dates);
    if ("currentDate" in $$props2) $$invalidate(17, currentDate = $$props2.currentDate);
    if ("dayMaxEvents" in $$props2) dayMaxEvents = $$props2.dayMaxEvents;
    if ("highlightedDates" in $$props2) $$invalidate(18, highlightedDates = $$props2.highlightedDates);
    if ("moreLinkContent" in $$props2) $$invalidate(19, moreLinkContent = $$props2.moreLinkContent);
    if ("theme" in $$props2) $$invalidate(20, theme = $$props2.theme);
    if ("_hiddenEvents" in $$props2) $$invalidate(21, _hiddenEvents = $$props2._hiddenEvents);
    if ("_intlDayCell" in $$props2) $$invalidate(22, _intlDayCell = $$props2._intlDayCell);
    if ("_popupDate" in $$props2) $$invalidate(23, _popupDate = $$props2._popupDate);
    if ("_popupChunks" in $$props2) $$invalidate(24, _popupChunks = $$props2._popupChunks);
    if ("_today" in $$props2) $$invalidate(25, _today = $$props2._today);
    if ("_interaction" in $$props2) $$invalidate(26, _interaction = $$props2._interaction);
    if ("_queue" in $$props2) _queue = $$props2._queue;
    if ("el" in $$props2) $$invalidate(4, el = $$props2.el);
    if ("dayChunks" in $$props2) $$invalidate(5, dayChunks = $$props2.dayChunks);
    if ("dayBgChunks" in $$props2) $$invalidate(8, dayBgChunks = $$props2.dayBgChunks);
    if ("isToday" in $$props2) $$invalidate(9, isToday = $$props2.isToday);
    if ("otherMonth" in $$props2) $$invalidate(10, otherMonth = $$props2.otherMonth);
    if ("highlight" in $$props2) $$invalidate(11, highlight = $$props2.highlight);
    if ("hiddenEvents" in $$props2) $$invalidate(6, hiddenEvents = $$props2.hiddenEvents);
    if ("moreLink" in $$props2) $$invalidate(12, moreLink = $$props2.moreLink);
    if ("showPopup" in $$props2) $$invalidate(7, showPopup = $$props2.showPopup);
    if ("refs" in $$props2) $$invalidate(13, refs = $$props2.refs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*bgChunks, date, hiddenEvents, chunks, dayChunks*/
    805306465) {
      $: {
        $$invalidate(5, dayChunks = []);
        $$invalidate(8, dayBgChunks = bgChunks.filter((bgChunk) => datesEqual(bgChunk.date, date)));
        hiddenEvents.clear();
        $$invalidate(6, hiddenEvents), $$invalidate(29, bgChunks), $$invalidate(0, date), $$invalidate(28, chunks), $$invalidate(5, dayChunks);
        for (let chunk of chunks) {
          if (datesEqual(chunk.date, date)) {
            dayChunks.push(chunk);
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*date, hiddenEvents*/
    65) {
      $: set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$_today*/
    32) {
      $: $$invalidate(9, isToday = datesEqual(date, $_today));
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/
    24) {
      $: {
        $$invalidate(10, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
        $$invalidate(11, highlight = $highlightedDates.some((d) => datesEqual(d, date)));
      }
    }
    if ($$self.$$.dirty[0] & /*hiddenEvents*/
    64 | $$self.$$.dirty[1] & /*$_hiddenEvents, $moreLinkContent*/
    6) {
      $: if ($_hiddenEvents && hiddenEvents.size) {
        let text2 = "+" + hiddenEvents.size + " more";
        if ($moreLinkContent) {
          $$invalidate(12, moreLink = isFunction($moreLinkContent) ? $moreLinkContent({ num: hiddenEvents.size, text: text2 }) : $moreLinkContent);
        } else {
          $$invalidate(12, moreLink = text2);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$_popupDate*/
    1) {
      $: $$invalidate(7, showPopup = $_popupDate && datesEqual(date, $_popupDate));
    }
    if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/
    162) {
      $: if (showPopup && longChunks && dayChunks) {
        tick().then(setPopupChunks);
      }
    }
    if ($$self.$$.dirty[0] & /*el, date*/
    17) {
      $: if (el) {
        setPayload(el, () => ({
          allDay: true,
          date,
          resource: void 0,
          dayEl: el
        }));
      }
    }
  };
  return [
    date,
    longChunks,
    iChunks,
    dates,
    el,
    dayChunks,
    hiddenEvents,
    showPopup,
    dayBgChunks,
    isToday,
    otherMonth,
    highlight,
    moreLink,
    refs,
    $theme,
    $_interaction,
    $_intlDayCell,
    currentDate,
    highlightedDates,
    moreLinkContent,
    theme,
    _hiddenEvents,
    _intlDayCell,
    _popupDate,
    _popupChunks,
    _today,
    _interaction,
    showMore,
    chunks,
    bgChunks,
    reposition,
    $_popupDate,
    $moreLinkContent,
    $_hiddenEvents,
    $highlightedDates,
    $currentDate,
    $_today,
    pointerdown_handler,
    event_binding,
    div3_binding
  ];
}
var Day = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        date: 0,
        chunks: 28,
        bgChunks: 29,
        longChunks: 1,
        iChunks: 2,
        dates: 3,
        reposition: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Day",
      options,
      id: create_fragment4.name
    });
  }
  get date() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgChunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgChunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get longChunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set longChunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iChunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iChunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dates() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dates(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reposition() {
    return this.$$.ctx[30];
  }
  set reposition(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Day_default = Day;

// node_modules/@event-calendar/day-grid/src/Week.svelte
var file5 = "node_modules/@event-calendar/day-grid/src/Week.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[27] = list;
  child_ctx[28] = i;
  return child_ctx;
}
function create_each_block4(ctx) {
  let day;
  let i = (
    /*i*/
    ctx[28]
  );
  let current;
  const assign_day = () => (
    /*day_binding*/
    ctx[23](day, i)
  );
  const unassign_day = () => (
    /*day_binding*/
    ctx[23](null, i)
  );
  let day_props = {
    date: (
      /*date*/
      ctx[26]
    ),
    chunks: (
      /*chunks*/
      ctx[1]
    ),
    bgChunks: (
      /*bgChunks*/
      ctx[2]
    ),
    longChunks: (
      /*longChunks*/
      ctx[3]
    ),
    iChunks: (
      /*iChunks*/
      ctx[4]
    ),
    dates: (
      /*dates*/
      ctx[0]
    )
  };
  day = new Day_default({ props: day_props, $$inline: true });
  assign_day();
  const block = {
    c: function create() {
      create_component(day.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(day.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (i !== /*i*/
      ctx2[28]) {
        unassign_day();
        i = /*i*/
        ctx2[28];
        assign_day();
      }
      const day_changes = {};
      if (dirty & /*dates*/
      1) day_changes.date = /*date*/
      ctx2[26];
      if (dirty & /*chunks*/
      2) day_changes.chunks = /*chunks*/
      ctx2[1];
      if (dirty & /*bgChunks*/
      4) day_changes.bgChunks = /*bgChunks*/
      ctx2[2];
      if (dirty & /*longChunks*/
      8) day_changes.longChunks = /*longChunks*/
      ctx2[3];
      if (dirty & /*iChunks*/
      16) day_changes.iChunks = /*iChunks*/
      ctx2[4];
      if (dirty & /*dates*/
      1) day_changes.dates = /*dates*/
      ctx2[0];
      day.$set(day_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      unassign_day();
      destroy_component(day, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(67:4) {#each dates as date, i}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*dates*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[6].days);
      attr_dev(div, "role", "row");
      add_location(div, file5, 65, 0, 1908);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*reposition*/
          ctx[14],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*dates, chunks, bgChunks, longChunks, iChunks, refs*/
      63) {
        each_value = ensure_array_like_dev(
          /*dates*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      64 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[6].days)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $_hiddenEvents;
  let $hiddenDays;
  let $_iEvents;
  let $resources;
  let $filterEventsWithResources;
  let $_events;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Week", slots, []);
  let { dates } = $$props;
  let { _events, _iEvents, _queue2, _hiddenEvents, resources, filterEventsWithResources, hiddenDays, theme } = getContext("state");
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(22, $_events = value));
  validate_store(_iEvents, "_iEvents");
  component_subscribe($$self, _iEvents, (value) => $$invalidate(19, $_iEvents = value));
  validate_store(_hiddenEvents, "_hiddenEvents");
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(17, $_hiddenEvents = value));
  validate_store(resources, "resources");
  component_subscribe($$self, resources, (value) => $$invalidate(20, $resources = value));
  validate_store(filterEventsWithResources, "filterEventsWithResources");
  component_subscribe($$self, filterEventsWithResources, (value) => $$invalidate(21, $filterEventsWithResources = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(18, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(6, $theme = value));
  let chunks, bgChunks, longChunks, iChunks = [];
  let start;
  let end;
  let refs = [];
  let debounceHandle = {};
  function reposition() {
    debounce(() => runReposition(refs, dates), debounceHandle, _queue2);
  }
  $$self.$$.on_mount.push(function() {
    if (dates === void 0 && !("dates" in $$props || $$self.$$.bound[$$self.$$.props["dates"]])) {
      console.warn("<Week> was created without expected prop 'dates'");
    }
  });
  const writable_props = ["dates"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Week> was created with unknown prop '${key}'`);
  });
  function day_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refs[i] = $$value;
      $$invalidate(5, refs);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dates" in $$props2) $$invalidate(0, dates = $$props2.dates);
  };
  $$self.$capture_state = () => ({
    getContext,
    tick,
    cloneDate,
    addDay,
    eventIntersects,
    bgEvent,
    createEventChunk,
    prepareEventChunks,
    runReposition,
    debounce,
    Day: Day_default,
    dates,
    _events,
    _iEvents,
    _queue2,
    _hiddenEvents,
    resources,
    filterEventsWithResources,
    hiddenDays,
    theme,
    chunks,
    bgChunks,
    longChunks,
    iChunks,
    start,
    end,
    refs,
    debounceHandle,
    reposition,
    $_hiddenEvents,
    $hiddenDays,
    $_iEvents,
    $resources,
    $filterEventsWithResources,
    $_events,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("dates" in $$props2) $$invalidate(0, dates = $$props2.dates);
    if ("_events" in $$props2) $$invalidate(7, _events = $$props2._events);
    if ("_iEvents" in $$props2) $$invalidate(8, _iEvents = $$props2._iEvents);
    if ("_queue2" in $$props2) _queue2 = $$props2._queue2;
    if ("_hiddenEvents" in $$props2) $$invalidate(9, _hiddenEvents = $$props2._hiddenEvents);
    if ("resources" in $$props2) $$invalidate(10, resources = $$props2.resources);
    if ("filterEventsWithResources" in $$props2) $$invalidate(11, filterEventsWithResources = $$props2.filterEventsWithResources);
    if ("hiddenDays" in $$props2) $$invalidate(12, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2) $$invalidate(13, theme = $$props2.theme);
    if ("chunks" in $$props2) $$invalidate(1, chunks = $$props2.chunks);
    if ("bgChunks" in $$props2) $$invalidate(2, bgChunks = $$props2.bgChunks);
    if ("longChunks" in $$props2) $$invalidate(3, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2) $$invalidate(4, iChunks = $$props2.iChunks);
    if ("start" in $$props2) $$invalidate(15, start = $$props2.start);
    if ("end" in $$props2) $$invalidate(16, end = $$props2.end);
    if ("refs" in $$props2) $$invalidate(5, refs = $$props2.refs);
    if ("debounceHandle" in $$props2) debounceHandle = $$props2.debounceHandle;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dates*/
    1) {
      $: {
        $$invalidate(15, start = dates[0]);
        $$invalidate(16, end = addDay(cloneDate(dates.at(-1))));
      }
    }
    if ($$self.$$.dirty & /*$_events, start, end, $filterEventsWithResources, $resources, bgChunks, chunks, $hiddenDays*/
    7700486) {
      $: {
        $$invalidate(1, chunks = []);
        $$invalidate(2, bgChunks = []);
        for (let event of $_events) {
          if (eventIntersects(event, start, end, $filterEventsWithResources ? $resources : void 0)) {
            let chunk = createEventChunk(event, start, end);
            if (bgEvent(event.display)) {
              if (event.allDay) {
                bgChunks.push(chunk);
              }
            } else {
              chunks.push(chunk);
            }
          }
        }
        prepareEventChunks(bgChunks, $hiddenDays);
        $$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));
        reposition();
      }
    }
    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/
    884736) {
      $: $$invalidate(4, iChunks = $_iEvents.map((event) => {
        let chunk;
        if (event && eventIntersects(event, start, end)) {
          chunk = createEventChunk(event, start, end);
          prepareEventChunks([chunk], $hiddenDays);
        } else {
          chunk = null;
        }
        return chunk;
      }));
    }
    if ($$self.$$.dirty & /*$_hiddenEvents*/
    131072) {
      $: if ($_hiddenEvents) {
        tick().then(reposition);
      }
    }
  };
  return [
    dates,
    chunks,
    bgChunks,
    longChunks,
    iChunks,
    refs,
    $theme,
    _events,
    _iEvents,
    _hiddenEvents,
    resources,
    filterEventsWithResources,
    hiddenDays,
    theme,
    reposition,
    start,
    end,
    $_hiddenEvents,
    $hiddenDays,
    $_iEvents,
    $resources,
    $filterEventsWithResources,
    $_events,
    day_binding
  ];
}
var Week = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { dates: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Week",
      options,
      id: create_fragment5.name
    });
  }
  get dates() {
    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dates(value) {
    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Week_default = Week;

// node_modules/@event-calendar/day-grid/src/Body.svelte
var file6 = "node_modules/@event-calendar/day-grid/src/Body.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_each_block5(ctx) {
  let week;
  let current;
  week = new Week_default({
    props: { dates: (
      /*dates*/
      ctx[15]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(week.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(week.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(week, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const week_changes = {};
      if (dirty & /*weeks*/
      1) week_changes.dates = /*dates*/
      ctx2[15];
      week.$set(week_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(week.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(week.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(week, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(30:8) {#each weeks as dates}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*weeks*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[2].content);
      add_location(div0, file6, 28, 4, 715);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[2].body + /*$dayMaxEvents*/
      (ctx[1] === true ? " " + /*$theme*/
      ctx[2].uniform : ""));
      add_location(div1, file6, 24, 0, 601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      ctx[13](div1);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*weeks*/
      1) {
        each_value = ensure_array_like_dev(
          /*weeks*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      4 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[2].content)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*$theme, $dayMaxEvents*/
      6 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[2].body + /*$dayMaxEvents*/
      (ctx2[1] === true ? " " + /*$theme*/
      ctx2[2].uniform : ""))) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
      ctx[13](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $_viewDates;
  let $dayMaxEvents;
  let $_hiddenEvents;
  let $hiddenDays;
  let $theme;
  let $_bodyEl;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, []);
  let { _bodyEl, _viewDates, _hiddenEvents, dayMaxEvents, hiddenDays, theme } = getContext("state");
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(3, $_bodyEl = value));
  validate_store(_viewDates, "_viewDates");
  component_subscribe($$self, _viewDates, (value) => $$invalidate(11, $_viewDates = value));
  validate_store(_hiddenEvents, "_hiddenEvents");
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(14, $_hiddenEvents = value));
  validate_store(dayMaxEvents, "dayMaxEvents");
  component_subscribe($$self, dayMaxEvents, (value) => $$invalidate(1, $dayMaxEvents = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(12, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(2, $theme = value));
  let weeks;
  let days2;
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Body> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $_bodyEl = $$value;
      _bodyEl.set($_bodyEl);
    });
  }
  $$self.$capture_state = () => ({
    getContext,
    Week: Week_default,
    _bodyEl,
    _viewDates,
    _hiddenEvents,
    dayMaxEvents,
    hiddenDays,
    theme,
    weeks,
    days: days2,
    $_viewDates,
    $dayMaxEvents,
    $_hiddenEvents,
    $hiddenDays,
    $theme,
    $_bodyEl
  });
  $$self.$inject_state = ($$props2) => {
    if ("_bodyEl" in $$props2) $$invalidate(4, _bodyEl = $$props2._bodyEl);
    if ("_viewDates" in $$props2) $$invalidate(5, _viewDates = $$props2._viewDates);
    if ("_hiddenEvents" in $$props2) $$invalidate(6, _hiddenEvents = $$props2._hiddenEvents);
    if ("dayMaxEvents" in $$props2) $$invalidate(7, dayMaxEvents = $$props2.dayMaxEvents);
    if ("hiddenDays" in $$props2) $$invalidate(8, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2) $$invalidate(9, theme = $$props2.theme);
    if ("weeks" in $$props2) $$invalidate(0, weeks = $$props2.weeks);
    if ("days" in $$props2) $$invalidate(10, days2 = $$props2.days);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hiddenDays, $dayMaxEvents, $_viewDates, days, weeks*/
    7171) {
      $: {
        $$invalidate(0, weeks = []);
        $$invalidate(10, days2 = 7 - $hiddenDays.length);
        set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);
        $dayMaxEvents;
        for (let i = 0; i < $_viewDates.length / days2; ++i) {
          let dates = [];
          for (let j = 0; j < days2; ++j) {
            dates.push($_viewDates[i * days2 + j]);
          }
          weeks.push(dates);
        }
      }
    }
  };
  return [
    weeks,
    $dayMaxEvents,
    $theme,
    $_bodyEl,
    _bodyEl,
    _viewDates,
    _hiddenEvents,
    dayMaxEvents,
    hiddenDays,
    theme,
    days2,
    $_viewDates,
    $hiddenDays,
    div1_binding
  ];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment6.name
    });
  }
};
var Body_default = Body;

// node_modules/@event-calendar/day-grid/src/View.svelte
function create_fragment7(ctx) {
  let header;
  let t;
  let body;
  let current;
  header = new Header_default({ $$inline: true });
  body = new Body_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(header.$$.fragment);
      t = space();
      create_component(body.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(body.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(body, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(header, detaching);
      destroy_component(body, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<View> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ Header: Header_default, Body: Body_default });
  return [];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment7.name
    });
  }
};
var View_default = View;

// node_modules/@event-calendar/day-grid/src/index.js
var src_default = {
  createOptions(options) {
    options.dayMaxEvents = false;
    options.dayCellFormat = { day: "numeric" };
    options.dayPopoverFormat = { month: "long", day: "numeric", year: "numeric" };
    options.moreLinkContent = void 0;
    options.buttonText.dayGridMonth = "month";
    options.buttonText.close = "Close";
    options.theme.uniform = "ec-uniform";
    options.theme.dayFoot = "ec-day-foot";
    options.theme.popup = "ec-popup";
    options.view = "dayGridMonth";
    options.views.dayGridMonth = {
      buttonText: btnTextMonth,
      component: View_default,
      dayHeaderFormat: { weekday: "short" },
      dayHeaderAriaLabelFormat: { weekday: "long" },
      displayEventEnd: false,
      duration: { months: 1 },
      theme: themeView("ec-day-grid ec-month-view"),
      titleFormat: { year: "numeric", month: "long" }
    };
  },
  createStores(state) {
    state._days = days(state);
    state._intlDayCell = intl(state.locale, state.dayCellFormat);
    state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
    state._hiddenEvents = writable({});
    state._popupDate = writable(null);
    state._popupChunks = writable([]);
  }
};
export {
  src_default as default
};
//# sourceMappingURL=@event-calendar_day-grid.js.map
