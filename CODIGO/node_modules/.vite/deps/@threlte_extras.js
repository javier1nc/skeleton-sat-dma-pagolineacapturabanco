import {
  Jt,
  K,
  Xt,
  Yt
} from "./chunk-ZRPOQUD2.js";
import {
  defineWorkerModule,
  terminateWorker
} from "./chunk-JRGLTISH.js";
import {
  MeshBVH,
  MeshBVHUniformStruct,
  SAH,
  shaderIntersectFunction,
  shaderStructs
} from "./chunk-6NF6Z6JJ.js";
import {
  ThreePerf
} from "./chunk-VTITCIBE.js";
import {
  SDFGenerator
} from "./chunk-2JDCZ4CQ.js";
import {
  bidi_default
} from "./chunk-YGXTRQ4L.js";
import {
  HierarchicalObject_default,
  T,
  asyncWritable,
  createRawEventDispatcher,
  currentWritable,
  forwardEventHandlers,
  injectPlugin,
  memoize,
  revision,
  useCache,
  useLoader,
  useParent,
  useStage,
  useTask,
  useThrelte,
  useThrelteUserContext,
  watch
} from "./chunk-35FGOTN7.js";
import "./chunk-SKZTLOIB.js";
import {
  AdditiveBlending,
  AlwaysStencilFunc,
  AnimationClip,
  AnimationMixer,
  Audio,
  AudioListener,
  AudioLoader,
  BackSide,
  Bone,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CanvasTexture,
  CapsuleGeometry,
  ClampToEdgeWrapping,
  Color,
  ColorManagement,
  CompressedArrayTexture,
  CompressedCubeTexture,
  CompressedTexture,
  Controls,
  CubeCamera,
  CubeReflectionMapping,
  CubeTexture,
  CubeTextureLoader,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DefaultLoadingManager,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DynamicDrawUsage,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  Euler,
  ExtrudeGeometry,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  ImageBitmapLoader,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  KeepStencilOp,
  Line,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoColorSpace,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PositionalAudio,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGFormat,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  ReplaceStencilOp,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderMaterial,
  Shape,
  ShapePath,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  SpriteMaterial,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UniformsUtils,
  UnsignedByteType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLCubeRenderTarget,
  WebGLRenderTarget
} from "./chunk-P22M66ZC.js";
import "./chunk-AYNHEKRI.js";
import {
  derived,
  readable,
  writable
} from "./chunk-B3UEHWPT.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  handle_promise,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_dynamic_element_data,
  set_store_value,
  space,
  subscribe,
  tick,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-7XWKRO57.js";
import "./chunk-2GBBIY5G.js";
import {
  __publicField
} from "./chunk-2TUXWMP5.js";

// node_modules/@threlte/extras/dist/hooks/useCursor.js
var useCursor = (onPointerOver = "pointer", onPointerOut = "auto", target = void 0) => {
  let hovering = false;
  const hoveringStore = writable(false);
  const onPointerEnter = () => {
    hoveringStore.set(true);
  };
  const onPointerLeave = () => {
    hoveringStore.set(false);
  };
  if (typeof window === "undefined") {
    return {
      hovering: hoveringStore,
      onPointerEnter,
      onPointerLeave
    };
  }
  const el = target ?? document.body;
  let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get_store_value(onPointerOver);
  if (typeof onPointerOver !== "string") {
    const unsubscribeOnPointerOver = onPointerOver.subscribe((cursorStyle) => {
      onPointerOverValue = cursorStyle;
      if (hovering) {
        el.style.cursor = cursorStyle;
      }
    });
    onDestroy(unsubscribeOnPointerOver);
  }
  let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get_store_value(onPointerOut);
  if (typeof onPointerOut !== "string") {
    const unsubscribeOnPointerOut = onPointerOut.subscribe((cursorStyle) => {
      onPointerOutValue = cursorStyle;
      if (!hovering) {
        el.style.cursor = cursorStyle;
      }
    });
    onDestroy(unsubscribeOnPointerOut);
  }
  const unsubscribeHovering = hoveringStore.subscribe((isHovering) => {
    hovering = isHovering;
    if (isHovering) {
      el.style.cursor = onPointerOverValue;
    } else {
      el.style.cursor = onPointerOutValue;
    }
  });
  onDestroy(unsubscribeHovering);
  onDestroy(() => {
    el.style.cursor = onPointerOutValue;
  });
  return {
    hovering: hoveringStore,
    onPointerEnter,
    onPointerLeave
  };
};

// node_modules/three/examples/jsm/libs/meshopt_decoder.module.js
var MeshoptDecoder = function() {
  "use strict";
  var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
  var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
  var instance44;
  var ready = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
    instance44 = result.instance;
    instance44.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    var result = new Uint8Array(data.length);
    for (var i = 0; i < data.length; ++i) {
      var ch = data.charCodeAt(i);
      result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
    }
    var write = 0;
    for (var i = 0; i < data.length; ++i) {
      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
    }
    return result.buffer.slice(0, write);
  }
  function decode(fun, target, count, size, source, filter) {
    var sbrk = instance44.exports.sbrk;
    var count4 = count + 3 & ~3;
    var tp = sbrk(count4 * size);
    var sp = sbrk(source.length);
    var heap = new Uint8Array(instance44.exports.memory.buffer);
    heap.set(source, sp);
    var res = fun(tp, count, size, sp, source.length);
    if (res == 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res != 0) {
      throw new Error("Malformed buffer data: " + res);
    }
  }
  var filters = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var decoders = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  var workers = [];
  var requestId = 0;
  function createWorker(url) {
    var worker = {
      object: new Worker(url),
      pending: 0,
      requests: {}
    };
    worker.object.onmessage = function(event) {
      var data = event.data;
      worker.pending -= data.count;
      worker.requests[data.id][data.action](data.value);
      delete worker.requests[data.id];
    };
    return worker;
  }
  function initWorkers(count) {
    var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + decode.toString() + workerProcess.toString();
    var blob = new Blob([source], { type: "text/javascript" });
    var url = URL.createObjectURL(blob);
    for (var i = 0; i < count; ++i) {
      workers[i] = createWorker(url);
    }
    URL.revokeObjectURL(url);
  }
  function decodeWorker(count, size, source, mode, filter) {
    var worker = workers[0];
    for (var i = 1; i < workers.length; ++i) {
      if (workers[i].pending < worker.pending) {
        worker = workers[i];
      }
    }
    return new Promise(function(resolve, reject) {
      var data = new Uint8Array(source);
      var id = requestId++;
      worker.pending += count;
      worker.requests[id] = { resolve, reject };
      worker.object.postMessage({ id, count, size, source: data, mode, filter }, [data.buffer]);
    });
  }
  function workerProcess(event) {
    ready.then(function() {
      var data = event.data;
      try {
        var target = new Uint8Array(data.count * data.size);
        decode(instance44.exports[data.mode], target, data.count, data.size, data.source, instance44.exports[data.filter]);
        self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);
      } catch (error) {
        self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
      }
    });
  }
  return {
    ready,
    supported: true,
    useWorkers: function(count) {
      initWorkers(count);
    },
    decodeVertexBuffer: function(target, count, size, source, filter) {
      decode(instance44.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance44.exports[filters[filter]]);
    },
    decodeIndexBuffer: function(target, count, size, source) {
      decode(instance44.exports.meshopt_decodeIndexBuffer, target, count, size, source);
    },
    decodeIndexSequence: function(target, count, size, source) {
      decode(instance44.exports.meshopt_decodeIndexSequence, target, count, size, source);
    },
    decodeGltfBuffer: function(target, count, size, source, mode, filter) {
      decode(instance44.exports[decoders[mode]], target, count, size, source, instance44.exports[filters[filter]]);
    },
    decodeGltfBufferAsync: function(count, size, source, mode, filter) {
      if (workers.length > 0) {
        return decodeWorker(count, size, source, decoders[mode], filters[filter]);
      }
      return ready.then(function() {
        var target = new Uint8Array(count * size);
        decode(instance44.exports[decoders[mode]], target, count, size, source, instance44.exports[filters[filter]]);
        return target;
      });
    }
  };
}();

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError = () => {
  }) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace, onError).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {
  }) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace) return;
    const _color = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color.fromBufferAttribute(attribute, i);
      ColorManagement.toWorkingColorSpace(_color, SRGBColorSpace);
      attribute.setXYZ(i, _color.r, _color.g, _color.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index) buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1) continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
  const creaseDot = Math.cos(creaseAngle);
  const hashMultiplier = (1 + 1e-10) * 100;
  const verts = [new Vector3(), new Vector3(), new Vector3()];
  const tempVec1 = new Vector3();
  const tempVec2 = new Vector3();
  const tempNorm = new Vector3();
  const tempNorm2 = new Vector3();
  function hashVertex(v) {
    const x = ~~(v.x * hashMultiplier);
    const y = ~~(v.y * hashMultiplier);
    const z = ~~(v.z * hashMultiplier);
    return `${x},${y},${z}`;
  }
  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttr = resultGeometry.attributes.position;
  const vertexMap = {};
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();
    for (let n2 = 0; n2 < 3; n2++) {
      const vert = verts[n2];
      const hash = hashVertex(vert);
      if (!(hash in vertexMap)) {
        vertexMap[hash] = [];
      }
      vertexMap[hash].push(normal);
    }
  }
  const normalArray = new Float32Array(posAttr.count * 3);
  const normAttr = new BufferAttribute(normalArray, 3, false);
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c, b);
    tempVec2.subVectors(a, b);
    tempNorm.crossVectors(tempVec1, tempVec2).normalize();
    for (let n2 = 0; n2 < 3; n2++) {
      const vert = verts[n2];
      const hash = hashVertex(vert);
      const otherNormals = vertexMap[hash];
      tempNorm2.set(0, 0, 0);
      for (let k = 0, lk = otherNormals.length; k < lk; k++) {
        const otherNorm = otherNormals[k];
        if (tempNorm.dot(otherNorm) > creaseDot) {
          tempNorm2.add(otherNorm);
        }
      }
      tempNorm2.normalize();
      normAttr.setXYZ(i3 + n2, tempNorm2.x, tempNorm2.y, tempNorm2.z);
    }
  }
  resultGeometry.setAttribute("normal", normAttr);
  return resultGeometry;
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light") return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p = (t2 - t0) / td;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  if (uri.search(/\.ktx2($|\?)/i) > 0 || uri.search(/^data\:image\/ktx2/) === 0) return "image/ktx2";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0) return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func3) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func3(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func3) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func3(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0) continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh) return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children2 = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children2.length; i < il; i++) {
        node.add(children2[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl = targetNames.length; j < jl; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl = outputArray.length; j < jl; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/three/examples/jsm/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i)) return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/three/examples/jsm/libs/ktx-parse.module.js
var t = 0;
var n = 2;
var g = 1;
var u = 2;
var T2 = 0;
var C = 1;
var R = 10;
var it = 0;
var ct = 9;
var yt = 15;
var xt = 16;
var wt = 22;
var Ft = 37;
var Ct = 43;
var te = 76;
var ae = 83;
var ge = 97;
var ue = 100;
var we = 103;
var Ae = 109;
var In = 165;
var Sn = 166;
var pi = 1000066e3;
var Ii = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Si = class {
  constructor(t2, e, n2, i) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint8Array(t2) {
    const e = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, t2);
    return this._offset += t2, e;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e) {
    void 0 === e && (e = 0);
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; ) i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Fi = new Uint8Array([0]);
var Oi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ti(t2) {
  return new TextDecoder().decode(t2);
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Oi.length);
  if (e[0] !== Oi[0] || e[1] !== Oi[1] || e[2] !== Oi[2] || e[3] !== Oi[3] || e[4] !== Oi[4] || e[5] !== Oi[5] || e[6] !== Oi[6] || e[7] !== Oi[7] || e[8] !== Oi[8] || e[9] !== Oi[9] || e[10] !== Oi[10] || e[11] !== Oi[11]) throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Ii(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Si(t2, Oi.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), h = s._nextUint64(), U = s._nextUint64(), c = new Si(t2, Oi.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++) n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + c._nextUint64(), c._nextUint64()), uncompressedByteLength: c._nextUint64() });
  const _ = new Si(t2, r, o, true), p = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g3 = (p.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g3; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p);
  const y = new Si(t2, l, f, true);
  for (; y._offset < f; ) {
    const t3 = y._nextUint32(), e2 = y._scan(t3), i2 = Ti(e2);
    if (n2.keyValue[i2] = y._nextUint8Array(t3 - e2.byteLength - 1), i2.match(/^ktx/i)) {
      const t4 = Ti(n2.keyValue[i2]);
      n2.keyValue[i2] = t4.substring(0, t4.lastIndexOf("\0"));
    }
    y._skip(t3 % 4 ? 4 - t3 % 4 : 0);
  }
  if (U <= 0) return n2;
  const x = new Si(t2, h, U, true), u2 = x._nextUint16(), b = x._nextUint16(), d = x._nextUint32(), w = x._nextUint32(), m = x._nextUint32(), D = x._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a; t3++) B2.push({ imageFlags: x._nextUint32(), rgbSliceByteOffset: x._nextUint32(), rgbSliceByteLength: x._nextUint32(), alphaSliceByteOffset: x._nextUint32(), alphaSliceByteLength: x._nextUint32() });
  const L = h + x._offset, v = L + d, A2 = v + w, k = A2 + m, V = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I2 = new Uint8Array(t2.buffer, t2.byteOffset + v, w), S = new Uint8Array(t2.buffer, t2.byteOffset + A2, m), F = new Uint8Array(t2.buffer, t2.byteOffset + k, D);
  return n2.globalData = { endpointCount: u2, selectorCount: b, imageDescs: B2, endpointsData: V, selectorsData: I2, tablesData: S, extendedData: F }, n2;
}

// node_modules/three/examples/jsm/libs/zstddec.module.js
var A;
var I;
var B;
var g2 = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C2).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g2)).then(this._init) : WebAssembly.instantiate(Buffer.from(C2, "base64"), g2).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g2.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g3 = 0) {
    if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C3 = I.exports.malloc(Q2);
    B.set(A2, C3), g3 = g3 || Number(I.exports.ZSTD_findDecompressedSize(C3, Q2));
    const E = I.exports.malloc(g3), i = I.exports.ZSTD_decompress(E, g3, C3, Q2), D = B.slice(E, E + i);
    return I.exports.free(C3), I.exports.free(E), D;
  }
};
var C2 = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three/examples/jsm/math/ColorSpaces.js
var LINEAR_DISPLAY_P3_TO_XYZ = new Matrix3().set(
  0.4865709,
  0.2656677,
  0.1982173,
  0.2289746,
  0.6917385,
  0.0792869,
  0,
  0.0451134,
  1.0439444
);
var XYZ_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
  2.4934969,
  -0.9313836,
  -0.4027108,
  -0.829489,
  1.7626641,
  0.0236247,
  0.0358458,
  -0.0761724,
  0.9568845
);
var DisplayP3ColorSpace = "display-p3";
var LinearDisplayP3ColorSpace = "display-p3-linear";
var LINEAR_REC2020_TO_XYZ = new Matrix3().set(
  0.636958,
  0.1446169,
  0.168881,
  0.2627002,
  0.6779981,
  0.0593017,
  0,
  0.0280727,
  1.0609851
);
var XYZ_TO_LINEAR_REC2020 = new Matrix3().set(
  1.7166512,
  -0.3556708,
  -0.2533663,
  -0.6666844,
  1.6164812,
  0.0157685,
  0.0176399,
  -0.0427706,
  0.9421031
);

// node_modules/three/examples/jsm/loaders/KTX2Loader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class _KTX2Loader extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  async detectSupportAsync(renderer) {
    this.workerConfig = {
      astcSupported: await renderer.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: false,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: await renderer.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await renderer.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await renderer.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await renderer.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await renderer.hasFeatureAsync("texture-compression-pvrtc")
    };
    return this;
  }
  detectSupport(renderer) {
    if (renderer.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer.hasFeature("texture-compression-astc"),
        astcHDRSupported: false,
        // https://github.com/gpuweb/gpuweb/issues/3856
        etc1Supported: renderer.hasFeature("texture-compression-etc1"),
        etc2Supported: renderer.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer.hasFeature("texture-compression-bc"),
        bptcSupported: renderer.hasFeature("texture-compression-bptc"),
        pvrtcSupported: renderer.hasFeature("texture-compression-pvrtc")
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
        astcHDRSupported: renderer.extensions.has("WEBGL_compressed_texture_astc") && renderer.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
        etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = _KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat),
          "let _EngineType = " + JSON.stringify(_KTX2Loader.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    if (_taskCache2.has(buffer)) {
      const cachedTask = _taskCache2.get(buffer);
      return cachedTask.promise.then(onLoad).catch(onError);
    }
    this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
  }
  _createTextureFrom(transcodeResult, container) {
    const { type: messageType, error, data: { faces, width, height, format, type, dfdFlags } } = transcodeResult;
    if (messageType === "error") return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedCubeTexture(faces, format, type);
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, type) : new CompressedTexture(mipmaps, width, height, format, type);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = parseColorSpace(container);
    texture.premultiplyAlpha = !!(dfdFlags & g);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config = {}) {
    const container = Pi(new Uint8Array(buffer));
    const isBasisHDR = container.vkFormat === pi && container.dataFormatDescriptor[0].colorModel === 167;
    const needsTranscoder = container.vkFormat === it || isBasisHDR && !this.workerConfig.astcHDRSupported;
    if (!needsTranscoder) {
      return createRawTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache2.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format
};
KTX2Loader.EngineType = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const EngineType = _EngineType;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init2(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, type, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, data: { faces, width, height, hasAlpha, format, type, dfdFlags } }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init2(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    let basisFormat;
    if (ktx2File.isUASTC()) {
      basisFormat = BasisFormat.UASTC;
    } else if (ktx2File.isETC1S()) {
      basisFormat = BasisFormat.ETC1S;
    } else if (ktx2File.isHDR()) {
      basisFormat = BasisFormat.UASTC_HDR;
    } else {
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    }
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat, engineType } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          let dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (engineType === EngineType.HalfFloatType) {
            dst = new Uint16Array(dst.buffer, dst.byteOffset, dst.byteLength / Uint16Array.BYTES_PER_ELEMENT);
          }
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat, type: engineType });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, dfdFlags, format: engineFormat, type: engineType };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.BC6H],
      engineFormat: [EngineFormat.RGB_BPTC_UNSIGNED_Format],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: false
    },
    // Uncompressed fallbacks.
    {
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.RGBA32, TranscoderFormat.RGBA32],
      engineFormat: [EngineFormat.RGBAFormat, EngineFormat.RGBAFormat],
      engineType: [EngineType.UnsignedByteType, EngineType.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: false
    },
    {
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.RGBA_HALF],
      engineFormat: [EngineFormat.RGBAFormat],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: false
    }
  ];
  const OPTIONS = {
    // TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
    // a historical accident shown to avoid performance pitfalls for Linux with
    // Firefox & AMD GPU (RadeonSI). Further work needed.
    // See https://github.com/mrdoob/three.js/pull/29730.
    [BasisFormat.ETC1S]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.ETC1S)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC_HDR]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC_HDR)).sort((a, b) => a.priorityHDR - b.priorityHDR)
  };
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    const options = OPTIONS[basisFormat];
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (opt.if && !config[opt.if]) continue;
      if (!opt.basisFormat.includes(basisFormat)) continue;
      if (hasAlpha && opt.transcoderFormat.length < 2) continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
      const transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      const engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      const engineType = opt.engineType[0];
      return { transcoderFormat, engineFormat, engineType };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function isPowerOfTwo(value) {
    if (value <= 2) return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1) return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]);
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [ge]: RGBAFormat,
  [Ft]: RGBAFormat,
  [Ct]: RGBAFormat,
  [we]: RGFormat,
  [ae]: RGFormat,
  [xt]: RGFormat,
  [wt]: RGFormat,
  [ue]: RedFormat,
  [te]: RedFormat,
  [yt]: RedFormat,
  [ct]: RedFormat,
  [pi]: RGBA_ASTC_4x4_Format,
  [Sn]: RGBA_ASTC_6x6_Format,
  [In]: RGBA_ASTC_6x6_Format
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [ge]: HalfFloatType,
  [Ft]: UnsignedByteType,
  [Ct]: UnsignedByteType,
  [we]: FloatType,
  [ae]: HalfFloatType,
  [xt]: UnsignedByteType,
  [wt]: UnsignedByteType,
  [ue]: FloatType,
  [te]: HalfFloatType,
  [yt]: UnsignedByteType,
  [ct]: UnsignedByteType,
  [pi]: HalfFloatType,
  [Sn]: UnsignedByteType,
  [In]: UnsignedByteType
};
async function createRawTexture(container) {
  const { vkFormat } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  let zstd;
  if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd2 = new Q();
        await zstd2.init();
        resolve(zstd2);
      });
    }
    zstd = await _zstd;
  }
  const mipmaps = [];
  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);
    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);
    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;
    const level = container.levels[levelIndex];
    let levelData;
    if (container.supercompressionScheme === t) {
      levelData = level.levelData;
    } else if (container.supercompressionScheme === n) {
      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
    } else {
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    }
    let data;
    if (TYPE_MAP[vkFormat] === FloatType) {
      data = new Float32Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
      );
    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
      data = new Uint16Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
      );
    } else {
      data = levelData;
    }
    mipmaps.push({
      data,
      width: levelWidth,
      height: levelHeight,
      depth: levelDepth
    });
  }
  let texture;
  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {
    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
  } else {
    if (container.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);
    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
  }
  texture.mipmaps = mipmaps;
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = parseColorSpace(container);
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}
function parseColorSpace(container) {
  const dfd = container.dataFormatDescriptor[0];
  if (dfd.colorPrimaries === C) {
    return dfd.transferFunction === u ? SRGBColorSpace : LinearSRGBColorSpace;
  } else if (dfd.colorPrimaries === R) {
    return dfd.transferFunction === u ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;
  } else if (dfd.colorPrimaries === T2) {
    return NoColorSpace;
  } else {
    console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`);
    return NoColorSpace;
  }
}

// node_modules/@threlte/extras/dist/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
var defaultDracoLoaderInstances = {};
function useGltf(urlOrOptions, options) {
  const { renderer } = useThrelte();
  const opts = typeof urlOrOptions === "string" ? options : urlOrOptions;
  const loader = useLoader(GLTFLoader, {
    extend(loader2) {
      if (opts == null ? void 0 : opts.useDraco) {
        if (typeof opts.useDraco === "string" || typeof opts.useDraco === "boolean") {
          const path = typeof opts.useDraco === "string" ? opts.useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
          if (!defaultDracoLoaderInstances[path]) {
            defaultDracoLoaderInstances[path] = new DRACOLoader().setDecoderPath(path);
          }
          loader2.setDRACOLoader(defaultDracoLoaderInstances[path]);
        } else {
          loader2.setDRACOLoader(opts.useDraco);
        }
      }
      if (opts == null ? void 0 : opts.useMeshopt) {
        loader2.setMeshoptDecoder(MeshoptDecoder);
      }
      if (opts == null ? void 0 : opts.ktxTranscoderPath) {
        const ktx2Loader = new KTX2Loader();
        ktx2Loader.setTranscoderPath(opts == null ? void 0 : opts.ktxTranscoderPath);
        ktx2Loader.detectSupport(renderer);
        loader2.setKTX2Loader(ktx2Loader);
      }
    }
  });
  const load = (url2) => {
    return loader.load(url2, {
      transform(result) {
        return {
          ...result,
          ...buildSceneGraph(result.scene)
        };
      }
    });
  };
  const url = typeof urlOrOptions === "string" ? urlOrOptions : void 0;
  if (url) {
    return load(url);
  } else {
    return {
      load
    };
  }
}

// node_modules/@threlte/extras/dist/hooks/useGltfAnimations.js
var isRoot = (value) => !!(value == null ? void 0 : value.isObject3D);
var isGltfStore = (value) => !!(value == null ? void 0 : value.subscribe) && typeof value.subscribe === "function";
function useGltfAnimations(rootOrGltf, maybeRoot) {
  const gltf = isGltfStore(rootOrGltf) ? rootOrGltf : writable(void 0);
  const root = currentWritable(isRoot(rootOrGltf) ? rootOrGltf : isRoot(maybeRoot) ? maybeRoot : void 0);
  const actualRoot = derived([root, gltf], ([root2, gltf2]) => {
    return root2 ?? (gltf2 == null ? void 0 : gltf2.scene);
  });
  const actions = currentWritable({});
  const mixer = new AnimationMixer(void 0);
  watch([gltf, actualRoot], async ([gltf2, actualRoot2]) => {
    if (!gltf2 || !gltf2.animations.length || !actualRoot2)
      return;
    await tick();
    const newActions = gltf2.animations.reduce((acc, clip) => {
      const action = mixer.clipAction(clip, actualRoot2);
      return {
        ...acc,
        [clip.name]: action
      };
    }, {});
    actions.set(newActions);
    return () => {
      Object.values(newActions).forEach((a) => {
        const action = a;
        action.stop();
        mixer.uncacheClip(action.getClip());
      });
    };
  });
  const { start, stop } = useTask((delta) => {
    mixer.update(delta);
  }, { autoStart: false });
  watch(actions, (actions2) => {
    if (Object.keys(actions2).length)
      start();
    else
      stop();
  });
  return {
    gltf,
    root,
    mixer,
    actions
  };
}

// node_modules/@threlte/extras/dist/hooks/useProgress.js
var previousTotalLoaded = 0;
var useProgress = () => {
  const finishedOnce = writable(false);
  const activeStore = writable(false);
  const itemStore = writable(void 0);
  const loadedStore = writable(0);
  const totalStore = writable(0);
  const errorsStore = writable([]);
  const progressStore = writable(0);
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    activeStore.set(true);
    itemStore.set(item);
    loadedStore.set(loaded);
    totalStore.set(total);
    const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);
    progressStore.set(progress);
    if (progress === 1)
      finishedOnce.set(true);
  };
  DefaultLoadingManager.onLoad = () => {
    activeStore.set(false);
  };
  DefaultLoadingManager.onError = (item) => {
    errorsStore.update((errors) => {
      return [...errors, item];
    });
  };
  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      previousTotalLoaded = total;
    }
    activeStore.set(true);
    itemStore.set(item);
    loadedStore.set(loaded);
    totalStore.set(total);
    const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;
    progressStore.set(progress);
    if (progress === 1)
      finishedOnce.set(true);
  };
  return {
    active: { subscribe: activeStore.subscribe },
    item: { subscribe: itemStore.subscribe },
    loaded: { subscribe: loadedStore.subscribe },
    total: { subscribe: totalStore.subscribe },
    errors: { subscribe: errorsStore.subscribe },
    progress: { subscribe: progressStore.subscribe },
    finishedOnce: { subscribe: finishedOnce.subscribe }
  };
};

// node_modules/@threlte/extras/dist/hooks/useTexture.js
var useTexture = (input, options) => {
  const loader = useLoader(TextureLoader, options);
  const { renderer } = useThrelte();
  return loader.load(input, {
    ...options,
    transform: (res) => {
      var _a;
      res.colorSpace = renderer.outputColorSpace;
      res.needsUpdate = true;
      return ((_a = options == null ? void 0 : options.transform) == null ? void 0 : _a.call(options, res)) ?? res;
    }
  });
};

// node_modules/@threlte/extras/dist/hooks/useFBO.js
function useFBO(width, height, options) {
  const { dpr, size } = useThrelte();
  const _width = typeof width === "number" ? width : 1 * (dpr.current ?? 1);
  const _height = typeof height === "number" ? height : 1 * (dpr.current ?? 1);
  const _options = (typeof width === "number" ? options : width) || {};
  const { samples = 0, depth, ...targetOptions } = _options;
  const target = new WebGLRenderTarget(_width, _height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    type: HalfFloatType,
    ...targetOptions
  });
  if (depth) {
    target.depthTexture = new DepthTexture(_width, _height, FloatType);
  }
  target.samples = samples;
  onMount(() => {
    if (samples)
      target.samples = samples;
  });
  onDestroy(() => {
    target.dispose();
  });
  const unsubscribeSize = size.subscribe((val) => {
    const _width2 = typeof width === "number" ? width : val.width * dpr.current;
    const _height2 = typeof height === "number" ? height : val.height * dpr.current;
    if (target.width !== _width2 && target.height !== _height2) {
      target.setSize(_width2, _height2);
    }
  });
  onDestroy(unsubscribeSize);
  return target;
}

// node_modules/@threlte/extras/dist/hooks/useGamepad.js
var standardButtons = [
  "clusterBottom",
  "clusterRight",
  "clusterLeft",
  "clusterTop",
  "leftBumper",
  "rightBumper",
  "leftTrigger",
  "rightTrigger",
  "select",
  "start",
  "leftStickButton",
  "rightStickButton",
  "directionalTop",
  "directionalBottom",
  "directionalLeft",
  "directionalRight",
  "center"
];
var xrButtons = [
  "trigger",
  "squeeze",
  "touchpadButton",
  "thumbstickButton",
  "clusterBottom",
  "clusterTop"
];
var standardAxes = ["leftStick", "rightStick"];
var xrAxes = ["touchpad", "thumbstick"];
var createButton = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a;
    (_a = events[index])[name] ?? (_a[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    pressed: false,
    touched: false,
    value: 0,
    on,
    off
  };
};
var createAxis = (events, index) => {
  const off = (name, fn) => {
    if (!(index in events) || !(name in events[index]))
      return;
    const arrayIndex = events[index][name].indexOf(fn);
    if (arrayIndex > -1)
      events[index][name].splice(arrayIndex, 1);
  };
  const on = (name, fn) => {
    var _a;
    (_a = events[index])[name] ?? (_a[name] = []);
    events[index][name].push(fn);
    return () => off(name, fn);
  };
  return {
    x: 0,
    y: 0,
    on,
    off
  };
};
var createXrStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Primary trigger */
    trigger: createButton(events, 0),
    /** buttons[1] - Primary squeeze button */
    squeeze: createButton(events, 1),
    /** buttons[2] - Primary touchpad */
    touchpadButton: createButton(events, 2),
    /** buttons[3] - Primary thumbstick */
    thumbstickButton: createButton(events, 3),
    /** buttons[4] - Bottom cluster button */
    clusterBottom: createButton(events, 4),
    /** buttons[5] - Top cluster button */
    clusterTop: createButton(events, 5),
    /** axes[0], axes[1] - Horizontal / vertical axis for the primary touchpad */
    touchpad: createAxis(events, 6),
    /** axes[2], axes[3] - Horizontal / vertical axis for the primary thumbstick */
    thumbstick: createAxis(events, 7)
  };
};
var createStandard = (allEvents, events) => {
  const off = (name, fn) => {
    if (!allEvents[name])
      return;
    const index = allEvents[name].indexOf(fn);
    if (index > -1)
      allEvents[name].splice(index, 1);
  };
  const on = (name, fn) => {
    allEvents[name] ?? (allEvents[name] = []);
    allEvents[name].push(fn);
    return () => off(name, fn);
  };
  return {
    on,
    off,
    /** The Gamepad connection status */
    connected: currentWritable(false),
    /** The raw Gamepad object */
    raw: null,
    /** buttons[0] - Botton button in right cluster */
    clusterBottom: createButton(events, 0),
    /** buttons[1] - Right button in right cluster */
    clusterRight: createButton(events, 1),
    /** buttons[2] - Left button in right cluster */
    clusterLeft: createButton(events, 2),
    /** buttons[3] - Top button in right cluster */
    clusterTop: createButton(events, 3),
    /** buttons[4] - Top left front button */
    leftBumper: createButton(events, 4),
    /** buttons[5] - Top right front button */
    rightBumper: createButton(events, 5),
    /** buttons[6] - Bottom left front button */
    leftTrigger: createButton(events, 6),
    /** buttons[7] - Bottom right front button */
    rightTrigger: createButton(events, 7),
    /** buttons[8] - Left button in center cluster */
    select: createButton(events, 8),
    /** buttons[9] - Right button in center cluster */
    start: createButton(events, 9),
    /** buttons[10] - Left stick pressed button */
    leftStickButton: createButton(events, 10),
    /** buttons[11] -	Right stick pressed button */
    rightStickButton: createButton(events, 11),
    /** buttons[12] -	Top button in left cluster */
    directionalTop: createButton(events, 12),
    /** buttons[13] -	Bottom button in left cluster */
    directionalBottom: createButton(events, 13),
    /** buttons[14] -	Left button in left cluster */
    directionalLeft: createButton(events, 14),
    /** buttons[15] -	Right button in left cluster */
    directionalRight: createButton(events, 15),
    /** buttons[16] -	Center button in center cluster */
    center: createButton(events, 16),
    /** axes[0], axes[1] - Horizontal / vertical axis for left stick (negative left/positive right) */
    leftStick: createAxis(events, 17),
    /** axes[2], axes[3] - Horizontal / vertical axis for right stick (negative left/positive right) */
    rightStick: createAxis(events, 18)
  };
};
var processButton = (target, mappedButton, allEvents, buttonEvents, source) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const lastTouched = mappedButton.touched;
  const lastPressed = mappedButton.pressed;
  const lastValue = mappedButton.value;
  mappedButton.touched = (source == null ? void 0 : source.touched) ?? false;
  mappedButton.pressed = (source == null ? void 0 : source.pressed) ?? false;
  const value = mappedButton.value = (source == null ? void 0 : source.value) ?? 0;
  if (!lastTouched && mappedButton.touched) {
    (_a = allEvents.touchstart) == null ? void 0 : _a.forEach((fn) => fn({ type: "touchstart", target, value }));
    (_b = buttonEvents.touchstart) == null ? void 0 : _b.forEach((fn) => fn({ type: "touchstart", target, value }));
  } else if (lastTouched && !mappedButton.touched) {
    (_c = allEvents.touch) == null ? void 0 : _c.forEach((fn) => fn({ type: "touch", target, value }));
    (_d = buttonEvents.touch) == null ? void 0 : _d.forEach((fn) => fn({ type: "touch", target, value }));
    (_e = allEvents.touchend) == null ? void 0 : _e.forEach((fn) => fn({ type: "touchend", target, value }));
    (_f = buttonEvents.touchend) == null ? void 0 : _f.forEach((fn) => fn({ type: "touchend", target, value }));
  }
  if (!lastPressed && mappedButton.pressed) {
    (_g = allEvents.down) == null ? void 0 : _g.forEach((fn) => fn({ type: "down", target, value }));
    (_h = buttonEvents.down) == null ? void 0 : _h.forEach((fn) => fn({ type: "down", target, value }));
  } else if (lastPressed && !mappedButton.pressed) {
    (_i = allEvents.press) == null ? void 0 : _i.forEach((fn) => fn({ type: "press", target, value }));
    (_j = buttonEvents.press) == null ? void 0 : _j.forEach((fn) => fn({ type: "press", target, value }));
    (_k = allEvents.up) == null ? void 0 : _k.forEach((fn) => fn({ type: "up", target, value }));
    (_l = buttonEvents.up) == null ? void 0 : _l.forEach((fn) => fn({ type: "up", target, value }));
  }
  if (lastValue !== mappedButton.value) {
    (_m = allEvents.change) == null ? void 0 : _m.forEach((fn) => fn({ type: "change", target, value }));
    (_n = buttonEvents.change) == null ? void 0 : _n.forEach((fn) => fn({ type: "change", target, value }));
  }
};
var processAxis = (target, mappedStick, allEvents, axisEvents, axisDeadzone, rawX = 0, rawY = 0) => {
  var _a, _b;
  const lastValueX = mappedStick.x;
  const lastValueY = mappedStick.y;
  const x = Math.abs(rawX) < axisDeadzone ? 0 : rawX;
  const y = Math.abs(rawY) < axisDeadzone ? 0 : rawY;
  mappedStick.x = x;
  mappedStick.y = y;
  if (lastValueX !== x || lastValueY !== y) {
    (_a = allEvents.change) == null ? void 0 : _a.forEach((fn) => fn({ type: "change", target, value: { x, y } }));
    (_b = axisEvents.change) == null ? void 0 : _b.forEach((fn) => fn({ type: "change", target, value: { x, y } }));
  }
};
function useGamepad(options = {}) {
  const { axisDeadzone = 0.05 } = options;
  const allEvents = {};
  const events = [];
  if ("xr" in options) {
    for (let i = 0; i < xrButtons.length + xrAxes.length; i += 1) {
      events.push({});
    }
    const gamepad = createXrStandard(allEvents, events);
    const { xr } = useThrelte().renderer;
    const processSnapshot = () => {
      var _a;
      (_a = xr.getSession()) == null ? void 0 : _a.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        gamepad.raw = source.gamepad ?? null;
        const { buttons = [], axes = [] } = gamepad.raw ?? {};
        xrButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
        processAxis("touchpad", gamepad.touchpad, allEvents, events[6], axisDeadzone, axes[0], axes[1]);
        processAxis("thumbstick", gamepad.thumbstick, allEvents, events[7], axisDeadzone, axes[2], axes[3]);
      });
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleConnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      const pad = event.data.gamepad;
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    const handleDisconnected = (event) => {
      if (event.data.handedness !== options.hand)
        return;
      gamepad.raw = null;
      gamepad.connected.set(false);
      stop();
    };
    const session = xr.getSession();
    if (session) {
      session.inputSources.forEach((source) => {
        if (source.handedness !== options.hand) {
          return;
        }
        const pad = source.gamepad;
        if (pad) {
          gamepad.raw = pad;
          gamepad.connected.set(true);
          start();
        }
      });
    }
    for (const index of [0, 1]) {
      const controller = xr.getController(index);
      controller.addEventListener("connected", handleConnected);
      controller.addEventListener("disconnected", handleDisconnected);
    }
    onDestroy(() => {
      for (const index of [0, 1]) {
        const controller = xr.getController(index);
        controller.removeEventListener("connected", handleConnected);
        controller.removeEventListener("disconnected", handleDisconnected);
      }
    });
    return gamepad;
  } else {
    for (let i = 0; i < standardButtons.length + standardAxes.length; i += 1) {
      events.push({});
    }
    const { index: gamepadIndex = 0 } = options;
    const gamepad = createStandard(allEvents, events);
    const processSnapshot = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      gamepad.raw = pad;
      const { buttons = [], axes = [] } = pad ?? {};
      standardButtons.forEach((name, index) => processButton(name, gamepad[name], allEvents, events[index], buttons[index]));
      processAxis("leftStick", gamepad.leftStick, allEvents, events[17], axisDeadzone, axes[0], axes[1]);
      processAxis("rightStick", gamepad.rightStick, allEvents, events[18], axisDeadzone, axes[2], axes[3]);
    };
    const { start, stop } = useTask(processSnapshot, { autoStart: false, autoInvalidate: false });
    const handleGamepadDisconnected = (event) => {
      var _a;
      const { id } = event.gamepad;
      if (id === ((_a = gamepad.raw) == null ? void 0 : _a.id)) {
        gamepad.raw = null;
        gamepad.connected.set(false);
        stop();
      }
    };
    const handleGamepadConnected = () => {
      const pad = navigator.getGamepads()[gamepadIndex];
      if (pad) {
        gamepad.raw = pad;
        gamepad.connected.set(true);
        start();
      }
    };
    handleGamepadConnected();
    window.addEventListener("gamepadconnected", handleGamepadConnected);
    window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);
    onDestroy(() => {
      window.removeEventListener("gamepadconnected", handleGamepadConnected);
      window.removeEventListener("gamepaddisconnected", handleGamepadDisconnected);
    });
    return gamepad;
  }
}

// node_modules/@threlte/extras/dist/hooks/useMask.js
var useMask = (id = 1, inverse = false) => {
  return {
    stencilRef: id,
    stencilWrite: true,
    stencilFunc: inverse ? NotEqualStencilFunc : EqualStencilFunc,
    stencilFail: KeepStencilOp,
    stencilZFail: KeepStencilOp,
    stencilZPass: KeepStencilOp
  };
};

// node_modules/@threlte/extras/dist/suspense/context.js
var suspenseContextIdentifier = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER");
var createSuspenseContext = (options) => {
  const dispatch = createRawEventDispatcher();
  const promises = currentWritable(/* @__PURE__ */ new Set());
  const errors = currentWritable(/* @__PURE__ */ new Map());
  const finalized = writable(false);
  const checkFinalized = () => {
    if (promises.current.size === 0 && errors.current.size === 0)
      finalized.set(true);
  };
  const finalStore = writable((options == null ? void 0 : options.final) ?? false);
  const addPromise = (promise) => {
    promises.update((set) => {
      set.add(promise);
      return set;
    });
  };
  const removePromise = (promise) => {
    promises.update((set) => {
      set.delete(promise);
      return set;
    });
  };
  const addError = (promise, error) => {
    errors.update((map) => {
      map.set(promise, error);
      return map;
    });
  };
  const removeError = (promise) => {
    errors.update((map) => {
      map.delete(promise);
      return map;
    });
  };
  const suspended = derived([promises, errors, finalStore, finalized], ([promises2, errors2, final, finalized2]) => {
    if (final && finalized2) {
      return false;
    } else if (errors2.size > 0) {
      return true;
    } else {
      return promises2.size > 0;
    }
  });
  const context = {
    suspend(promise) {
      addPromise(promise);
      promise.catch((error) => {
        addError(promise, error);
        dispatch("error", error);
      }).finally(() => {
        removePromise(promise);
        checkFinalized();
      });
    },
    onComponentDestroy(promise) {
      removePromise(promise);
      removeError(promise);
      checkFinalized();
    },
    suspended
  };
  const errorsArray = derived(errors, (errors2) => Array.from(errors2.values()));
  setContext(suspenseContextIdentifier, context);
  return {
    promises,
    suspended,
    errors: errorsArray,
    setFinal: (final) => finalStore.set(final ?? false)
  };
};

// node_modules/@threlte/extras/dist/suspense/useSuspense.js
var useSuspense = () => {
  const ctx = getContext(suspenseContextIdentifier);
  const promises = /* @__PURE__ */ new Set();
  const suspend = (promise) => {
    if (ctx) {
      ctx.suspend(promise);
      promises.add(promise);
    }
    return promise;
  };
  const state = {
    suspended: derived((ctx == null ? void 0 : ctx.suspended) ?? readable(false), (suspended) => suspended)
  };
  onDestroy(() => {
    if (!ctx)
      return;
    for (const promise of promises) {
      ctx.onComponentDestroy(promise);
    }
    promises.clear();
  });
  return Object.assign(suspend, state);
};

// node_modules/@threlte/extras/dist/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte
var { console: console_1 } = globals;
function create_if_block_1(ctx) {
  let t2;
  let updating_ref;
  let current;
  const t_spread_levels = [
    { is: (
      /*is*/
      ctx[3]
    ) },
    { map: (
      /*texture*/
      ctx[4]
    ) },
    { toneMapped: false },
    { transparent: (
      /*transparent*/
      ctx[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  function t_ref_binding(value) {
    ctx[26](value);
  }
  let t_props = {};
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    t_props.ref = /*ref*/
    ctx[0];
  }
  t2 = new T({ props: t_props, $$inline: true });
  binding_callbacks.push(() => bind(t2, "ref", t_ref_binding));
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty[0] & /*is, texture, transparent, alphaTest, $$restProps*/
      158 ? get_spread_update(t_spread_levels, [
        dirty[0] & /*is*/
        8 && { is: (
          /*is*/
          ctx2[3]
        ) },
        dirty[0] & /*texture*/
        16 && { map: (
          /*texture*/
          ctx2[4]
        ) },
        t_spread_levels[2],
        dirty[0] & /*transparent*/
        4 && { transparent: (
          /*transparent*/
          ctx2[2]
        ) },
        dirty[0] & /*alphaTest*/
        2 && { alphaTest: (
          /*alphaTest*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        )
      ]) : {};
      if (!updating_ref && dirty[0] & /*ref*/
      1) {
        updating_ref = true;
        t_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(241:18) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let t0;
  let updating_ref;
  let t1;
  let t_meshdepthmaterial;
  let current;
  const t0_spread_levels = [
    { is: (
      /*is*/
      ctx[3]
    ) },
    { map: (
      /*texture*/
      ctx[4]
    ) },
    { toneMapped: false },
    { side: DoubleSide },
    { shadowSide: DoubleSide },
    { transparent: (
      /*transparent*/
      ctx[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  function t0_ref_binding(value) {
    ctx[25](value);
  }
  let t0_props = {};
  for (let i = 0; i < t0_spread_levels.length; i += 1) {
    t0_props = assign(t0_props, t0_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    t0_props.ref = /*ref*/
    ctx[0];
  }
  t0 = new T({ props: t0_props, $$inline: true });
  binding_callbacks.push(() => bind(t0, "ref", t0_ref_binding));
  t_meshdepthmaterial = new T.MeshDepthMaterial({
    props: {
      attach: "customDepthMaterial",
      depthPacking: RGBADepthPacking,
      map: (
        /*texture*/
        ctx[4]
      ),
      alphaTest: (
        /*alphaTest*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      create_component(t_meshdepthmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_meshdepthmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_meshdepthmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t0_changes = dirty[0] & /*is, texture, transparent, alphaTest, $$restProps*/
      158 ? get_spread_update(t0_spread_levels, [
        dirty[0] & /*is*/
        8 && { is: (
          /*is*/
          ctx2[3]
        ) },
        dirty[0] & /*texture*/
        16 && { map: (
          /*texture*/
          ctx2[4]
        ) },
        t0_spread_levels[2],
        t0_spread_levels[3],
        t0_spread_levels[4],
        dirty[0] & /*transparent*/
        4 && { transparent: (
          /*transparent*/
          ctx2[2]
        ) },
        dirty[0] & /*alphaTest*/
        2 && { alphaTest: (
          /*alphaTest*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        )
      ]) : {};
      if (!updating_ref && dirty[0] & /*ref*/
      1) {
        updating_ref = true;
        t0_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t0.$set(t0_changes);
      const t_meshdepthmaterial_changes = {};
      if (dirty[0] & /*texture*/
      16) t_meshdepthmaterial_changes.map = /*texture*/
      ctx2[4];
      if (dirty[0] & /*alphaTest*/
      2) t_meshdepthmaterial_changes.alphaTest = /*alphaTest*/
      ctx2[1];
      t_meshdepthmaterial.$set(t_meshdepthmaterial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(t_meshdepthmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(t_meshdepthmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
      }
      destroy_component(t0, detaching);
      destroy_component(t_meshdepthmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(223:0) {#if texture && isMesh}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*texture*/
      ctx2[4] && /*isMesh*/
      ctx2[5]
    ) return 0;
    if (
      /*texture*/
      ctx2[4]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let fpsInterval;
  const omit_props_names = [
    "textureUrl",
    "dataUrl",
    "animation",
    "loop",
    "autoplay",
    "fps",
    "filter",
    "alphaTest",
    "delay",
    "transparent",
    "flipX",
    "startFrame",
    "endFrame",
    "rows",
    "columns",
    "totalFrames",
    "is",
    "ref",
    "play",
    "pause"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimatedSpriteMaterial", slots, []);
  let { textureUrl } = $$props;
  let { dataUrl = "" } = $$props;
  let { animation = "" } = $$props;
  let { loop = true } = $$props;
  let { autoplay = true } = $$props;
  let { fps = 10 } = $$props;
  let { filter = "nearest" } = $$props;
  let { alphaTest = 0.1 } = $$props;
  let { delay = 0 } = $$props;
  let { transparent = true } = $$props;
  let { flipX = false } = $$props;
  let { startFrame = 0 } = $$props;
  let { endFrame = void 0 } = $$props;
  let { rows = 1 } = $$props;
  let { columns = void 0 } = $$props;
  let { totalFrames = 0 } = $$props;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(24, $parent = value));
  const dispatch = createRawEventDispatcher();
  const supportedDirections = ["forward", "reverse"];
  const isSupportedDirection = (value) => {
    const isSupported = supportedDirections.includes(value);
    if (!isSupported) {
      console.warn(`Unsupported sprite animation direction "${value}"`);
    }
    return isSupported;
  };
  let timerOffset = 0;
  let currentFrame = startFrame;
  let numFrames = 0;
  let flipOffset = flipX ? -1 : 1;
  let frameWidth = 0;
  let frameHeight = 0;
  let texture;
  let json;
  let frameNames = [];
  let direction = "forward";
  let frameTag;
  let spritesheetSize = { w: 0, h: 0 };
  let isMesh = "isMesh" in $parent;
  let { is = isMesh ? new MeshBasicMaterial() : new SpriteMaterial() } = $$props;
  let { ref } = $$props;
  const suspend = useSuspense();
  const textureStore = suspend(useTexture(textureUrl, {
    transform: (value) => {
      value.matrixAutoUpdate = false;
      value.generateMipmaps = false;
      value.premultiplyAlpha = false;
      value.wrapS = value.wrapT = RepeatWrapping;
      value.magFilter = value.minFilter = filter === "nearest" ? NearestFilter : LinearFilter;
      return value;
    }
  }));
  const jsonStore = suspend(dataUrl ? useLoader(FileLoader).load(dataUrl, {
    transform: (file2) => {
      if (typeof file2 !== "string") return;
      try {
        return JSON.parse(file2);
      } catch {
        return;
      }
    }
  }) : asyncWritable(new Promise((resolve) => {
    const unsub = textureStore.subscribe((value) => {
      if (!value) return;
      unsub();
      resolve(createData(value));
    });
  })));
  const createData = (texture2) => {
    const { width, height } = texture2.image;
    const cols = columns ?? totalFrames;
    numFrames = totalFrames;
    const frameWidth2 = width / cols;
    const frameHeight2 = height / rows;
    const data = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: width, h: height },
        scale: 1
      }
    };
    for (let i = 0; i < numFrames; i += 1) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const x = col * frameWidth2;
      const y = row * frameHeight2;
      data.frames[`${i}`] = {
        frame: { x, y, w: frameWidth2, h: frameHeight2 },
        spriteSourceSize: {
          x: 0,
          y: 0,
          w: frameWidth2,
          h: frameHeight2
        },
        sourceSize: { w: frameWidth2, h: frameHeight2 }
      };
    }
    return data;
  };
  const setFrame = (frame) => {
    const horizontalFrames = spritesheetSize.w / frameWidth;
    const verticalFrames = spritesheetSize.h / frameHeight;
    const frameOffsetX = 1 / horizontalFrames;
    const frameOffsetY = 1 / verticalFrames;
    const x = flipOffset > 0 ? frameOffsetX * (frame.x / frameWidth) : frameOffsetX * (frame.x / frameHeight) - texture.repeat.x;
    const y = Math.abs(1 - frameOffsetY) - frameOffsetY * (frame.y / frameHeight);
    texture == null ? void 0 : texture.offset.set(x, y);
    texture == null ? void 0 : texture.updateMatrix();
  };
  const setAnimation = (name) => {
    if (!json) return;
    frameTag = json == null ? void 0 : json.meta.frameTags.find((tag) => tag.name === name);
    direction = isSupportedDirection(frameTag == null ? void 0 : frameTag.direction) ? frameTag.direction : "forward";
    currentFrame = direction === "forward" ? (frameTag == null ? void 0 : frameTag.from) ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? numFrames - 1;
    setFrame(json.frames[frameNames[currentFrame]].frame);
    if (dispatch.hasEventListener("start")) {
      dispatch("start");
    }
  };
  let playQueued = false;
  const play = async () => {
    playQueued = true;
    await Promise.all([textureStore, jsonStore]);
    if (!playQueued) return;
    timerOffset = performance.now() - delay;
    start();
  };
  const pause = () => {
    playQueued = false;
    stop();
  };
  const { start, stop } = useTask(
    () => {
      if (!json) return;
      const now2 = performance.now();
      const diff = now2 - timerOffset;
      const name = frameNames[currentFrame];
      const { frame, duration } = json.frames[name];
      const interval = duration ?? fpsInterval;
      if (diff <= interval) return;
      timerOffset = now2 - diff % interval;
      const start2 = direction === "forward" ? (frameTag == null ? void 0 : frameTag.from) ?? startFrame ?? 0 : (frameTag == null ? void 0 : frameTag.to) ?? endFrame ?? numFrames - 1;
      const end = direction === "forward" ? (frameTag == null ? void 0 : frameTag.to) ?? endFrame ?? numFrames - 1 : (frameTag == null ? void 0 : frameTag.from) ?? startFrame ?? 0;
      setFrame(frame);
      switch (direction) {
        case "forward":
          currentFrame += 1;
          break;
        case "reverse":
          currentFrame -= 1;
          break;
        default:
          break;
      }
      if (direction === "forward" && currentFrame > end || direction === "reverse" && currentFrame < end) {
        currentFrame = start2;
        if (loop) {
          if (dispatch.hasEventListener("loop")) {
            dispatch("loop");
          }
        } else {
          pause();
          if (dispatch.hasEventListener("end")) {
            dispatch("end");
          }
        }
      }
    },
    { autoStart: false }
  );
  watch([textureStore, jsonStore], ([nextTexture, nextJson]) => {
    if (nextTexture === void 0 || nextJson === void 0) return;
    $$invalidate(4, texture = nextTexture.clone());
    json = nextJson;
    frameNames = Object.keys(json.frames);
    numFrames = frameNames.length;
    spritesheetSize = json.meta.size;
    const { sourceSize } = Object.values(json.frames)[0];
    frameWidth = sourceSize.w;
    frameHeight = sourceSize.h;
    texture.repeat.set(1 * flipOffset / (spritesheetSize.w / frameWidth), 1 / (spritesheetSize.h / frameHeight));
    setAnimation(animation);
    dispatch("load");
    if (autoplay) {
      play();
    }
  });
  $$self.$$.on_mount.push(function() {
    if (textureUrl === void 0 && !("textureUrl" in $$props || $$self.$$.bound[$$self.$$.props["textureUrl"]])) {
      console_1.warn("<AnimatedSpriteMaterial> was created without expected prop 'textureUrl'");
    }
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console_1.warn("<AnimatedSpriteMaterial> was created without expected prop 'ref'");
    }
  });
  function t0_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  function t_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("textureUrl" in $$new_props) $$invalidate(8, textureUrl = $$new_props.textureUrl);
    if ("dataUrl" in $$new_props) $$invalidate(9, dataUrl = $$new_props.dataUrl);
    if ("animation" in $$new_props) $$invalidate(10, animation = $$new_props.animation);
    if ("loop" in $$new_props) $$invalidate(11, loop = $$new_props.loop);
    if ("autoplay" in $$new_props) $$invalidate(12, autoplay = $$new_props.autoplay);
    if ("fps" in $$new_props) $$invalidate(13, fps = $$new_props.fps);
    if ("filter" in $$new_props) $$invalidate(14, filter = $$new_props.filter);
    if ("alphaTest" in $$new_props) $$invalidate(1, alphaTest = $$new_props.alphaTest);
    if ("delay" in $$new_props) $$invalidate(15, delay = $$new_props.delay);
    if ("transparent" in $$new_props) $$invalidate(2, transparent = $$new_props.transparent);
    if ("flipX" in $$new_props) $$invalidate(16, flipX = $$new_props.flipX);
    if ("startFrame" in $$new_props) $$invalidate(17, startFrame = $$new_props.startFrame);
    if ("endFrame" in $$new_props) $$invalidate(18, endFrame = $$new_props.endFrame);
    if ("rows" in $$new_props) $$invalidate(19, rows = $$new_props.rows);
    if ("columns" in $$new_props) $$invalidate(20, columns = $$new_props.columns);
    if ("totalFrames" in $$new_props) $$invalidate(21, totalFrames = $$new_props.totalFrames);
    if ("is" in $$new_props) $$invalidate(3, is = $$new_props.is);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    DoubleSide,
    FileLoader,
    LinearFilter,
    MeshBasicMaterial,
    NearestFilter,
    RepeatWrapping,
    RGBADepthPacking,
    SpriteMaterial,
    T,
    asyncWritable,
    createRawEventDispatcher,
    useTask,
    watch,
    useLoader,
    useParent,
    useSuspense,
    useTexture,
    textureUrl,
    dataUrl,
    animation,
    loop,
    autoplay,
    fps,
    filter,
    alphaTest,
    delay,
    transparent,
    flipX,
    startFrame,
    endFrame,
    rows,
    columns,
    totalFrames,
    parent,
    dispatch,
    supportedDirections,
    isSupportedDirection,
    timerOffset,
    currentFrame,
    numFrames,
    flipOffset,
    frameWidth,
    frameHeight,
    texture,
    json,
    frameNames,
    direction,
    frameTag,
    spritesheetSize,
    isMesh,
    is,
    ref,
    suspend,
    textureStore,
    jsonStore,
    createData,
    setFrame,
    setAnimation,
    playQueued,
    play,
    pause,
    start,
    stop,
    fpsInterval,
    $parent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("textureUrl" in $$props) $$invalidate(8, textureUrl = $$new_props.textureUrl);
    if ("dataUrl" in $$props) $$invalidate(9, dataUrl = $$new_props.dataUrl);
    if ("animation" in $$props) $$invalidate(10, animation = $$new_props.animation);
    if ("loop" in $$props) $$invalidate(11, loop = $$new_props.loop);
    if ("autoplay" in $$props) $$invalidate(12, autoplay = $$new_props.autoplay);
    if ("fps" in $$props) $$invalidate(13, fps = $$new_props.fps);
    if ("filter" in $$props) $$invalidate(14, filter = $$new_props.filter);
    if ("alphaTest" in $$props) $$invalidate(1, alphaTest = $$new_props.alphaTest);
    if ("delay" in $$props) $$invalidate(15, delay = $$new_props.delay);
    if ("transparent" in $$props) $$invalidate(2, transparent = $$new_props.transparent);
    if ("flipX" in $$props) $$invalidate(16, flipX = $$new_props.flipX);
    if ("startFrame" in $$props) $$invalidate(17, startFrame = $$new_props.startFrame);
    if ("endFrame" in $$props) $$invalidate(18, endFrame = $$new_props.endFrame);
    if ("rows" in $$props) $$invalidate(19, rows = $$new_props.rows);
    if ("columns" in $$props) $$invalidate(20, columns = $$new_props.columns);
    if ("totalFrames" in $$props) $$invalidate(21, totalFrames = $$new_props.totalFrames);
    if ("timerOffset" in $$props) timerOffset = $$new_props.timerOffset;
    if ("currentFrame" in $$props) currentFrame = $$new_props.currentFrame;
    if ("numFrames" in $$props) numFrames = $$new_props.numFrames;
    if ("flipOffset" in $$props) flipOffset = $$new_props.flipOffset;
    if ("frameWidth" in $$props) frameWidth = $$new_props.frameWidth;
    if ("frameHeight" in $$props) frameHeight = $$new_props.frameHeight;
    if ("texture" in $$props) $$invalidate(4, texture = $$new_props.texture);
    if ("json" in $$props) json = $$new_props.json;
    if ("frameNames" in $$props) frameNames = $$new_props.frameNames;
    if ("direction" in $$props) direction = $$new_props.direction;
    if ("frameTag" in $$props) frameTag = $$new_props.frameTag;
    if ("spritesheetSize" in $$props) spritesheetSize = $$new_props.spritesheetSize;
    if ("isMesh" in $$props) $$invalidate(5, isMesh = $$new_props.isMesh);
    if ("is" in $$props) $$invalidate(3, is = $$new_props.is);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("playQueued" in $$props) playQueued = $$new_props.playQueued;
    if ("fpsInterval" in $$props) fpsInterval = $$new_props.fpsInterval;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$parent*/
    16777216) {
      $: $$invalidate(5, isMesh = "isMesh" in $parent);
    }
    if ($$self.$$.dirty[0] & /*fps*/
    8192) {
      $: fpsInterval = 1e3 / fps;
    }
    if ($$self.$$.dirty[0] & /*animation, autoplay*/
    5120) {
      $: {
        setAnimation(animation);
        if (autoplay) {
          play();
        }
      }
    }
  };
  return [
    ref,
    alphaTest,
    transparent,
    is,
    texture,
    isMesh,
    parent,
    $$restProps,
    textureUrl,
    dataUrl,
    animation,
    loop,
    autoplay,
    fps,
    filter,
    delay,
    flipX,
    startFrame,
    endFrame,
    rows,
    columns,
    totalFrames,
    play,
    pause,
    $parent,
    t0_ref_binding,
    t_ref_binding
  ];
}
var AnimatedSpriteMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        textureUrl: 8,
        dataUrl: 9,
        animation: 10,
        loop: 11,
        autoplay: 12,
        fps: 13,
        filter: 14,
        alphaTest: 1,
        delay: 15,
        transparent: 2,
        flipX: 16,
        startFrame: 17,
        endFrame: 18,
        rows: 19,
        columns: 20,
        totalFrames: 21,
        is: 3,
        ref: 0,
        play: 22,
        pause: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimatedSpriteMaterial",
      options,
      id: create_fragment.name
    });
  }
  get textureUrl() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textureUrl(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dataUrl() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dataUrl(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fps() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fps(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alphaTest() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alphaTest(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipX() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipX(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startFrame() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startFrame(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endFrame() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endFrame(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get totalFrames() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set totalFrames(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get is() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set is(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[22];
  }
  set play(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[23];
  }
  set pause(value) {
    throw new Error("<AnimatedSpriteMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimatedSpriteMaterial_default = AnimatedSpriteMaterial;

// node_modules/@threlte/extras/dist/components/Edges/Edges.svelte
var { Error: Error_1 } = globals;
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*ref*/
4096 });
var get_default_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[12]
) });
function create_default_slot(ctx) {
  let t_edgesgeometry;
  let t0;
  let t_linebasicmaterial;
  let t1;
  let current;
  t_edgesgeometry = new T.EdgesGeometry({
    props: {
      args: [
        /*geometry*/
        ctx[2],
        /*thresholdAngle*/
        ctx[0]
      ]
    },
    $$inline: true
  });
  t_linebasicmaterial = new T.LineBasicMaterial({
    props: { color: (
      /*color*/
      ctx[1]
    ) },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      create_component(t_edgesgeometry.$$.fragment);
      t0 = space();
      create_component(t_linebasicmaterial.$$.fragment);
      t1 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_edgesgeometry.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_linebasicmaterial.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_edgesgeometry, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_linebasicmaterial, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_edgesgeometry_changes = {};
      if (dirty & /*geometry, thresholdAngle*/
      5) t_edgesgeometry_changes.args = [
        /*geometry*/
        ctx2[2],
        /*thresholdAngle*/
        ctx2[0]
      ];
      t_edgesgeometry.$set(t_edgesgeometry_changes);
      const t_linebasicmaterial_changes = {};
      if (dirty & /*color*/
      2) t_linebasicmaterial_changes.color = /*color*/
      ctx2[1];
      t_linebasicmaterial.$set(t_linebasicmaterial_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        6144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_edgesgeometry.$$.fragment, local);
      transition_in(t_linebasicmaterial.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_edgesgeometry.$$.fragment, local);
      transition_out(t_linebasicmaterial.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(t_edgesgeometry, detaching);
      destroy_component(t_linebasicmaterial, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(12:0) <T.LineSegments   let:ref   {...$$restProps}   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let t_linesegments;
  let current;
  const t_linesegments_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  let t_linesegments_props = {
    $$slots: {
      default: [
        create_default_slot,
        ({ ref }) => ({ 12: ref }),
        ({ ref }) => ref ? 4096 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_linesegments_spread_levels.length; i += 1) {
    t_linesegments_props = assign(t_linesegments_props, t_linesegments_spread_levels[i]);
  }
  t_linesegments = new T.LineSegments({
    props: t_linesegments_props,
    $$inline: true
  });
  ctx[10](t_linesegments);
  const block = {
    c: function create() {
      create_component(t_linesegments.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_linesegments.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_linesegments, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_linesegments_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(t_linesegments_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty & /*$$scope, ref, color, geometry, thresholdAngle*/
      6151) {
        t_linesegments_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_linesegments.$set(t_linesegments_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_linesegments.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_linesegments.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[10](null);
      destroy_component(t_linesegments, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let parentMesh;
  let geometry;
  const omit_props_names = ["thresholdAngle", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Edges", slots, ["default"]);
  let { thresholdAngle = void 0 } = $$props;
  let { color = void 0 } = $$props;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(8, $parent = value));
  if (!$parent || $parent.type !== "Mesh") throw new Error("Edges: component must be a child of a Mesh");
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(3, $component = value));
  function t_linesegments_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("thresholdAngle" in $$new_props) $$invalidate(0, thresholdAngle = $$new_props.thresholdAngle);
    if ("color" in $$new_props) $$invalidate(1, color = $$new_props.color);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useParent,
    forwardEventHandlers,
    thresholdAngle,
    color,
    parent,
    component,
    parentMesh,
    geometry,
    $parent,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("thresholdAngle" in $$props) $$invalidate(0, thresholdAngle = $$new_props.thresholdAngle);
    if ("color" in $$props) $$invalidate(1, color = $$new_props.color);
    if ("parentMesh" in $$props) $$invalidate(7, parentMesh = $$new_props.parentMesh);
    if ("geometry" in $$props) $$invalidate(2, geometry = $$new_props.geometry);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$parent*/
    256) {
      $: $$invalidate(7, parentMesh = $parent);
    }
    if ($$self.$$.dirty & /*parentMesh*/
    128) {
      $: $$invalidate(2, geometry = "clone" in parentMesh.geometry ? parentMesh.geometry.clone() : parentMesh.geometry);
    }
  };
  return [
    thresholdAngle,
    color,
    geometry,
    $component,
    parent,
    component,
    $$restProps,
    parentMesh,
    $parent,
    slots,
    t_linesegments_binding,
    $$scope
  ];
}
var Edges = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { thresholdAngle: 0, color: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edges",
      options,
      id: create_fragment2.name
    });
  }
  get thresholdAngle() {
    throw new Error_1("<Edges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thresholdAngle(value) {
    throw new Error_1("<Edges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_1("<Edges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_1("<Edges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Edges_default = Edges;

// node_modules/@threlte/extras/dist/hooks/useHasEventListeners.js
var useHasEventListeners = () => {
  const component = get_current_component();
  const hasEventListeners = (type) => {
    const callbacks = component.$$.callbacks;
    return type in callbacks && callbacks[type].length > 0;
  };
  return {
    hasEventListeners
  };
};

// node_modules/@threlte/extras/dist/components/HTML/utils.js
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
var isOrthographicCamera = (o) => {
  return o.isOrthographicCamera;
};
var isPerspectiveCamera = (o) => {
  return o.isPerspectiveCamera;
};
var isOrthographicCameraOrPerspectiveCamera = (o) => {
  return isOrthographicCamera(o) || isPerspectiveCamera(o);
};
var defaultCalculatePosition = (obj, camera, size) => {
  const objectPos = v1.setFromMatrixPosition(obj.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
};
var isObjectBehindCamera = (el, camera) => {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el, camera, raycaster, occlude) => {
  const elPos = v1.setFromMatrixPosition(el.matrixWorld);
  const screenPos = elPos.clone();
  screenPos.project(camera);
  raycaster.setFromCamera(screenPos, camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectScale = (el, camera) => {
  if (isOrthographicCamera(camera)) {
    return camera.zoom;
  } else if (isPerspectiveCamera(camera)) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var objectZIndex = (el, camera, zIndexRange) => {
  if (isOrthographicCameraOrPerspectiveCamera(camera)) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A2 = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B2 = zIndexRange[1] - A2 * camera.far;
    return Math.round(A2 * dist + B2);
  }
  return void 0;
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (matrix, multipliers, prepend = "") => {
  let matrix3d = "matrix3d(";
  for (let i = 0; i !== 16; i++) {
    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? "," : ")");
  }
  return prepend + matrix3d;
};
var getCameraCSSMatrix = /* @__PURE__ */ ((multipliers) => {
  return (matrix) => getCSSMatrix(matrix, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = /* @__PURE__ */ ((scaleMultipliers) => {
  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);
var styleDeclarationKeyToCssString = (s) => {
  return s.split(/(?=[A-Z])/).join("-").toLowerCase();
};
var compileStyles = (styles) => {
  return Object.entries(styles).filter(([_, value]) => !!value).map(([key, value]) => `${styleDeclarationKeyToCssString(key)}: ${value}`).join("; ");
};
var updateStyles = (store, styles) => {
  store.update((values) => {
    return {
      ...values,
      ...styles
    };
  });
};

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
var { Error: Error_12 } = globals;
var file = "node_modules/@threlte/extras/dist/components/HTML/HTML.svelte";
var get_threlte_slot_changes = (dirty) => ({ ref: dirty[0] & /*ref*/
4 });
var get_threlte_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[2]
) });
function create_default_slot2(ctx) {
  let current;
  const threlte_slot_template = (
    /*#slots*/
    ctx[40].threlte
  );
  const threlte_slot = create_slot(
    threlte_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    get_threlte_slot_context
  );
  const block = {
    c: function create() {
      if (threlte_slot) threlte_slot.c();
    },
    l: function claim(nodes) {
      if (threlte_slot) threlte_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (threlte_slot) {
        threlte_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (threlte_slot) {
        if (threlte_slot.p && (!current || dirty[0] & /*ref*/
        4 | dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            threlte_slot,
            threlte_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              threlte_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              get_threlte_slot_changes
            ),
            get_threlte_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(threlte_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(threlte_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (threlte_slot) threlte_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(244:0) <T   is={ref}   {...$$restProps}   let:ref   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element_1(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(277:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(256:0) {#if transform}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(286:6) {#if showEl}",
    ctx
  });
  return block;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let div;
  let div_style_value;
  let svelte_element_style_value;
  let portalAction_action;
  let buildDefaultNonTransformStyles_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*showEl*/
    ctx[6] && create_if_block_2(ctx)
  );
  let svelte_element_levels = [
    {
      style: svelte_element_style_value = compileStyles(
        /*$noTransformElStyles*/
        ctx[11]
      )
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      div = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        { style: true }
      );
      var svelte_element_nodes = children(svelte_element);
      div = claim_element(svelte_element_nodes, "DIV", { style: true });
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "style", div_style_value = compileStyles(
        /*$noTransformDivStyles*/
        ctx[12]
      ));
      add_location(div, file, 284, 4, 9459);
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 277, 2, 9294);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div);
      if (if_block) if_block.m(div, null);
      ctx[45](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(portalAction_action = /*portalAction*/
          ctx[23].call(null, svelte_element)),
          action_destroyer(buildDefaultNonTransformStyles_action = /*buildDefaultNonTransformStyles*/
          ctx[22].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showEl*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*showEl*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$noTransformDivStyles*/
      4096 && div_style_value !== (div_style_value = compileStyles(
        /*$noTransformDivStyles*/
        ctx2[12]
      ))) {
        attr_dev(div, "style", div_style_value);
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*$noTransformElStyles*/
        2048 && svelte_element_style_value !== (svelte_element_style_value = compileStyles(
          /*$noTransformElStyles*/
          ctx2[11]
        ))) && { style: svelte_element_style_value }
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (if_block) if_block.d();
      ctx[45](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(278:2) <svelte:element     this={as}     bind:this={el}     use:portalAction     use:buildDefaultNonTransformStyles     style={compileStyles($noTransformElStyles)}   >",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(271:8) {#if showEl}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let div1;
  let div0;
  let div0_style_value;
  let div1_style_value;
  let svelte_element_style_value;
  let portalAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*showEl*/
    ctx[6] && create_if_block_12(ctx)
  );
  let svelte_element_levels = [
    {
      style: svelte_element_style_value = compileStyles(
        /*$transformElStyles*/
        ctx[8]
      )
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      div1 = element("div");
      div0 = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        { style: true }
      );
      var svelte_element_nodes = children(svelte_element);
      div1 = claim_element(svelte_element_nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      if (if_block) if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "style", div0_style_value = compileStyles(
        /*$transformInnerRefStyles*/
        ctx[10]
      ));
      add_location(div0, file, 266, 6, 9079);
      attr_dev(div1, "style", div1_style_value = compileStyles(
        /*$transformOuterRefStyles*/
        ctx[9]
      ));
      add_location(div1, file, 262, 4, 8972);
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 256, 2, 8848);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div1);
      append_hydration_dev(div1, div0);
      if (if_block) if_block.m(div0, null);
      ctx[42](div0);
      ctx[43](div1);
      ctx[44](svelte_element);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portalAction_action = /*portalAction*/
        ctx[23].call(null, svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showEl*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*showEl*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$transformInnerRefStyles*/
      1024 && div0_style_value !== (div0_style_value = compileStyles(
        /*$transformInnerRefStyles*/
        ctx2[10]
      ))) {
        attr_dev(div0, "style", div0_style_value);
      }
      if (!current || dirty[0] & /*$transformOuterRefStyles*/
      512 && div1_style_value !== (div1_style_value = compileStyles(
        /*$transformOuterRefStyles*/
        ctx2[9]
      ))) {
        attr_dev(div1, "style", div1_style_value);
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*$transformElStyles*/
        256 && svelte_element_style_value !== (svelte_element_style_value = compileStyles(
          /*$transformElStyles*/
          ctx2[8]
        ))) && { style: svelte_element_style_value }
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (if_block) if_block.d();
      ctx[42](null);
      ctx[43](null);
      ctx[44](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(257:2) <svelte:element     this={as}     use:portalAction     bind:this={el}     style={compileStyles($transformElStyles)}   >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t0;
  let t1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const t0_spread_levels = [
    { is: (
      /*ref*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[25]
  ];
  let t0_props = {
    $$slots: {
      default: [create_default_slot2, ({ ref }) => ({ 2: ref }), ({ ref }) => [ref ? 4 : 0]]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t0_spread_levels.length; i += 1) {
    t0_props = assign(t0_props, t0_spread_levels[i]);
  }
  t0 = new T({ props: t0_props, $$inline: true });
  ctx[41](t0);
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*transform*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t0_changes = dirty[0] & /*ref, $$restProps*/
      33554436 ? get_spread_update(t0_spread_levels, [
        dirty[0] & /*ref*/
        4 && { is: (
          /*ref*/
          ctx2[2]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(
          /*$$restProps*/
          ctx2[25]
        )
      ]) : {};
      if (dirty[0] & /*ref*/
      4 | dirty[1] & /*$$scope*/
      32768) {
        t0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t0.$set(t0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
        detach_dev(if_block_anchor);
      }
      ctx[41](null);
      destroy_component(t0, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "transform",
    "calculatePosition",
    "eps",
    "occlude",
    "zIndexRange",
    "sprite",
    "pointerEvents",
    "center",
    "fullscreen",
    "distanceFactor",
    "as",
    "portal",
    "ref",
    "visible"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $size;
  let $camera;
  let $heightHalf;
  let $widthHalf;
  let $component;
  let $transformElStyles;
  let $transformOuterRefStyles;
  let $transformInnerRefStyles;
  let $noTransformElStyles;
  let $noTransformDivStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HTML", slots, ["threlte", "default"]);
  let { transform = false } = $$props;
  let { calculatePosition = defaultCalculatePosition } = $$props;
  let { eps: eps2 = 1e-3 } = $$props;
  let { occlude = false } = $$props;
  let { zIndexRange = [16777271, 0] } = $$props;
  let { sprite = false } = $$props;
  let { pointerEvents = "auto" } = $$props;
  let { center = false } = $$props;
  let { fullscreen = false } = $$props;
  let { distanceFactor = void 0 } = $$props;
  let { as = "div" } = $$props;
  let { portal = void 0 } = $$props;
  const dispatch = createRawEventDispatcher();
  let { ref = new Group() } = $$props;
  const { renderer, camera, scene, size } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(50, $camera = value));
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(37, $size = value));
  const isViableCamera = (c) => {
    return c.isPerspectiveCamera || c.isOrthographicCamera;
  };
  const getCamera = () => {
    if (!isViableCamera($camera)) {
      throw new Error("Only PerspectiveCamera or OrthographicCamera supported for component <HTML>");
    }
    return $camera;
  };
  const raycaster = new Raycaster();
  let oldPosition = [0, 0];
  let oldZoom = 0;
  let { visible = true } = $$props;
  let el = document.createElement(as);
  let transformOuterRef;
  let transformInnerRef;
  const { hasEventListeners } = useHasEventListeners();
  let raytraceTarget = typeof occlude === "boolean" && occlude === true ? [scene] : Array.isArray(occlude) ? occlude : void 0;
  const widthHalf = derived(size, (size2) => size2.width / 2);
  validate_store(widthHalf, "widthHalf");
  component_subscribe($$self, widthHalf, (value) => $$invalidate(39, $widthHalf = value));
  const heightHalf = derived(size, (size2) => size2.height / 2);
  validate_store(heightHalf, "heightHalf");
  component_subscribe($$self, heightHalf, (value) => $$invalidate(38, $heightHalf = value));
  let styles = {
    common: { el: writable({}) },
    transform: {
      el: writable({
        position: "absolute",
        top: "0",
        left: "0",
        pointerEvents: "none",
        overflow: "hidden",
        display: "block",
        width: `${$size.width}px`,
        height: `${$size.height}px`
      }),
      outerRef: writable({
        position: "absolute",
        top: "0",
        left: "0",
        width: `${$size.width}px`,
        height: `${$size.height}px`,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      }),
      innerRef: writable({ position: "absolute", pointerEvents })
    },
    noTransform: {
      el: writable({}),
      div: writable({
        position: "absolute",
        transform: center ? "translate3d(-50%,-50%,0)" : "none",
        top: fullscreen ? `${-$heightHalf}px` : void 0,
        left: fullscreen ? `${-$widthHalf}px` : void 0,
        width: fullscreen ? `${$size.width}px` : void 0,
        height: fullscreen ? `${$size.height}px` : void 0
      })
    }
  };
  const transformElStyles = derived([styles.transform.el, styles.common.el], ([vA, vB]) => {
    return { ...vA, ...vB };
  });
  validate_store(transformElStyles, "transformElStyles");
  component_subscribe($$self, transformElStyles, (value) => $$invalidate(8, $transformElStyles = value));
  const transformOuterRefStyles = derived(styles.transform.outerRef, (v) => v);
  validate_store(transformOuterRefStyles, "transformOuterRefStyles");
  component_subscribe($$self, transformOuterRefStyles, (value) => $$invalidate(9, $transformOuterRefStyles = value));
  const transformInnerRefStyles = derived(styles.transform.innerRef, (v) => v);
  validate_store(transformInnerRefStyles, "transformInnerRefStyles");
  component_subscribe($$self, transformInnerRefStyles, (value) => $$invalidate(10, $transformInnerRefStyles = value));
  const noTransformElStyles = derived(styles.noTransform.el, (v) => v);
  validate_store(noTransformElStyles, "noTransformElStyles");
  component_subscribe($$self, noTransformElStyles, (value) => $$invalidate(11, $noTransformElStyles = value));
  const noTransformDivStyles = derived(styles.noTransform.div, (v) => v);
  validate_store(noTransformDivStyles, "noTransformDivStyles");
  component_subscribe($$self, noTransformDivStyles, (value) => $$invalidate(12, $noTransformDivStyles = value));
  const getAncestorVisibility = () => {
    let ancestorsAreVisible = true;
    let parent = ref.parent;
    traverse: while (parent) {
      if ("visible" in parent && !parent.visible) {
        ancestorsAreVisible = false;
        break traverse;
      }
      parent = parent.parent;
    }
    return ancestorsAreVisible;
  };
  let showEl = getAncestorVisibility();
  useTask(async () => {
    $$invalidate(6, showEl = getAncestorVisibility());
    const camera2 = getCamera();
    camera2.updateMatrixWorld();
    ref.updateWorldMatrix(true, false);
    const vec = transform ? oldPosition : calculatePosition(ref, camera2, $size);
    if (transform || Math.abs(oldZoom - camera2.zoom) > eps2 || Math.abs(oldPosition[0] - vec[0]) > eps2 || Math.abs(oldPosition[1] - vec[1]) > eps2) {
      const isBehindCamera = isObjectBehindCamera(ref, camera2);
      const previouslyVisible = visible;
      if (raytraceTarget) {
        const isvisible = isObjectVisible(ref, camera2, raycaster, raytraceTarget);
        $$invalidate(26, visible = isvisible && !isBehindCamera);
      } else {
        $$invalidate(26, visible = !isBehindCamera);
      }
      if (previouslyVisible !== visible) {
        if (hasEventListeners("visibilitychange")) dispatch("visibilitychange", visible);
        else {
          updateStyles(styles.common.el, { display: visible ? "block" : "none" });
        }
      }
      updateStyles(styles.common.el, {
        zIndex: `${objectZIndex(ref, camera2, zIndexRange)}`
      });
      if (transform) {
        const fov = camera2.projectionMatrix.elements[5] * $heightHalf;
        const { isOrthographicCamera: isOrthographicCamera2, top, left, bottom, right } = camera2;
        let matrix = ref.matrixWorld;
        if (sprite) {
          matrix = camera2.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(ref.scale);
          matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;
          matrix.elements[15] = 1;
        }
        updateStyles(styles.transform.el, {
          perspective: isOrthographicCamera2 ? "" : `${fov}px`
        });
        if (transformOuterRef && transformInnerRef) {
          const cameraTransform = isOrthographicCamera2 ? `scale(${fov}) translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;
          const cameraMatrix = getCameraCSSMatrix(camera2.matrixWorldInverse);
          updateStyles(styles.transform.outerRef, {
            transform: `${cameraTransform}${cameraMatrix}translate(${$widthHalf}px, ${$heightHalf}px)`
          });
          updateStyles(styles.transform.innerRef, {
            transform: getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400))
          });
        }
      } else {
        const scale = distanceFactor === void 0 ? 1 : objectScale(ref, camera2) * distanceFactor;
        updateStyles(styles.noTransform.el, {
          transform: `translate3d(${vec[0]}px, ${vec[1]}px, 0) scale(${scale})`
        });
      }
      oldPosition = vec;
      oldZoom = camera2.zoom;
    }
  });
  const buildDefaultNonTransformStyles = (_) => {
    if (!ref || transform) return;
    scene.updateMatrixWorld();
    const vec = calculatePosition(ref, $camera, $size);
    updateStyles(styles.noTransform.el, {
      position: "absolute",
      top: "0",
      left: "0",
      transform: `translate3d(${vec[0]}px, ${vec[1]}px, 0)`,
      transformOrigin: "0 0"
    });
  };
  const portalAction = (el2) => {
    const target = portal ?? renderer.domElement.parentElement;
    if (!target) {
      console.warn("HTML: target is undefined.");
      return;
    }
    target.appendChild(el2);
    return {
      destroy: () => {
        if (!el2.parentNode) return;
        el2.parentNode.removeChild(el2);
      }
    };
  };
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(7, $component = value));
  function t0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      transformInnerRef = $$value;
      $$invalidate(5, transformInnerRef);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      transformOuterRef = $$value;
      $$invalidate(4, transformOuterRef);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function svelte_element_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transform" in $$new_props) $$invalidate(0, transform = $$new_props.transform);
    if ("calculatePosition" in $$new_props) $$invalidate(27, calculatePosition = $$new_props.calculatePosition);
    if ("eps" in $$new_props) $$invalidate(28, eps2 = $$new_props.eps);
    if ("occlude" in $$new_props) $$invalidate(29, occlude = $$new_props.occlude);
    if ("zIndexRange" in $$new_props) $$invalidate(30, zIndexRange = $$new_props.zIndexRange);
    if ("sprite" in $$new_props) $$invalidate(31, sprite = $$new_props.sprite);
    if ("pointerEvents" in $$new_props) $$invalidate(32, pointerEvents = $$new_props.pointerEvents);
    if ("center" in $$new_props) $$invalidate(33, center = $$new_props.center);
    if ("fullscreen" in $$new_props) $$invalidate(34, fullscreen = $$new_props.fullscreen);
    if ("distanceFactor" in $$new_props) $$invalidate(35, distanceFactor = $$new_props.distanceFactor);
    if ("as" in $$new_props) $$invalidate(1, as = $$new_props.as);
    if ("portal" in $$new_props) $$invalidate(36, portal = $$new_props.portal);
    if ("ref" in $$new_props) $$invalidate(2, ref = $$new_props.ref);
    if ("visible" in $$new_props) $$invalidate(26, visible = $$new_props.visible);
    if ("$$scope" in $$new_props) $$invalidate(46, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    forwardEventHandlers,
    T,
    useTask,
    useThrelte,
    derived,
    writable,
    Group,
    ThreeeObject3D: Object3D,
    OrthographicCamera,
    PerspectiveCamera,
    Raycaster,
    useHasEventListeners,
    compileStyles,
    defaultCalculatePosition,
    epsilon,
    getCameraCSSMatrix,
    getObjectCSSMatrix,
    isObjectBehindCamera,
    isObjectVisible,
    objectScale,
    objectZIndex,
    updateStyles,
    transform,
    calculatePosition,
    eps: eps2,
    occlude,
    zIndexRange,
    sprite,
    pointerEvents,
    center,
    fullscreen,
    distanceFactor,
    as,
    portal,
    dispatch,
    ref,
    renderer,
    camera,
    scene,
    size,
    isViableCamera,
    getCamera,
    raycaster,
    oldPosition,
    oldZoom,
    visible,
    el,
    transformOuterRef,
    transformInnerRef,
    hasEventListeners,
    raytraceTarget,
    widthHalf,
    heightHalf,
    styles,
    transformElStyles,
    transformOuterRefStyles,
    transformInnerRefStyles,
    noTransformElStyles,
    noTransformDivStyles,
    getAncestorVisibility,
    showEl,
    buildDefaultNonTransformStyles,
    portalAction,
    component,
    $size,
    $camera,
    $heightHalf,
    $widthHalf,
    $component,
    $transformElStyles,
    $transformOuterRefStyles,
    $transformInnerRefStyles,
    $noTransformElStyles,
    $noTransformDivStyles
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transform" in $$props) $$invalidate(0, transform = $$new_props.transform);
    if ("calculatePosition" in $$props) $$invalidate(27, calculatePosition = $$new_props.calculatePosition);
    if ("eps" in $$props) $$invalidate(28, eps2 = $$new_props.eps);
    if ("occlude" in $$props) $$invalidate(29, occlude = $$new_props.occlude);
    if ("zIndexRange" in $$props) $$invalidate(30, zIndexRange = $$new_props.zIndexRange);
    if ("sprite" in $$props) $$invalidate(31, sprite = $$new_props.sprite);
    if ("pointerEvents" in $$props) $$invalidate(32, pointerEvents = $$new_props.pointerEvents);
    if ("center" in $$props) $$invalidate(33, center = $$new_props.center);
    if ("fullscreen" in $$props) $$invalidate(34, fullscreen = $$new_props.fullscreen);
    if ("distanceFactor" in $$props) $$invalidate(35, distanceFactor = $$new_props.distanceFactor);
    if ("as" in $$props) $$invalidate(1, as = $$new_props.as);
    if ("portal" in $$props) $$invalidate(36, portal = $$new_props.portal);
    if ("ref" in $$props) $$invalidate(2, ref = $$new_props.ref);
    if ("oldPosition" in $$props) oldPosition = $$new_props.oldPosition;
    if ("oldZoom" in $$props) oldZoom = $$new_props.oldZoom;
    if ("visible" in $$props) $$invalidate(26, visible = $$new_props.visible);
    if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
    if ("transformOuterRef" in $$props) $$invalidate(4, transformOuterRef = $$new_props.transformOuterRef);
    if ("transformInnerRef" in $$props) $$invalidate(5, transformInnerRef = $$new_props.transformInnerRef);
    if ("raytraceTarget" in $$props) raytraceTarget = $$new_props.raytraceTarget;
    if ("styles" in $$props) $$invalidate(58, styles = $$new_props.styles);
    if ("showEl" in $$props) $$invalidate(6, showEl = $$new_props.showEl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*occlude*/
    536870912) {
      $: raytraceTarget = typeof occlude === "boolean" && occlude === true ? [scene] : Array.isArray(occlude) ? occlude : void 0;
    }
    if ($$self.$$.dirty[1] & /*$size*/
    64) {
      $: updateStyles(styles.transform.el, {
        width: `${$size.width}px`,
        height: `${$size.height}px`
      });
    }
    if ($$self.$$.dirty[1] & /*$size*/
    64) {
      $: updateStyles(styles.transform.outerRef, {
        width: `${$size.width}px`,
        height: `${$size.height}px`
      });
    }
    if ($$self.$$.dirty[1] & /*pointerEvents*/
    2) {
      $: updateStyles(styles.transform.innerRef, { pointerEvents });
    }
    if ($$self.$$.dirty[1] & /*pointerEvents*/
    2) {
      $: updateStyles(styles.noTransform.div, { pointerEvents });
    }
    if ($$self.$$.dirty[1] & /*center*/
    4) {
      $: updateStyles(styles.noTransform.div, {
        transform: center ? "translate3d(-50%, -50%, 0)" : "none"
      });
    }
    if ($$self.$$.dirty[1] & /*fullscreen, $heightHalf, $widthHalf, $size*/
    456) {
      $: updateStyles(styles.noTransform.div, {
        top: fullscreen ? `${-$heightHalf}px` : void 0,
        left: fullscreen ? `${-$widthHalf}px` : void 0,
        width: fullscreen ? `${$size.width}px` : void 0,
        height: fullscreen ? `${$size.height}px` : void 0
      });
    }
  };
  return [
    transform,
    as,
    ref,
    el,
    transformOuterRef,
    transformInnerRef,
    showEl,
    $component,
    $transformElStyles,
    $transformOuterRefStyles,
    $transformInnerRefStyles,
    $noTransformElStyles,
    $noTransformDivStyles,
    camera,
    size,
    widthHalf,
    heightHalf,
    transformElStyles,
    transformOuterRefStyles,
    transformInnerRefStyles,
    noTransformElStyles,
    noTransformDivStyles,
    buildDefaultNonTransformStyles,
    portalAction,
    component,
    $$restProps,
    visible,
    calculatePosition,
    eps2,
    occlude,
    zIndexRange,
    sprite,
    pointerEvents,
    center,
    fullscreen,
    distanceFactor,
    portal,
    $size,
    $heightHalf,
    $widthHalf,
    slots,
    t0_binding,
    div0_binding,
    div1_binding,
    svelte_element_binding,
    svelte_element_binding_1,
    $$scope
  ];
}
var HTML = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        transform: 0,
        calculatePosition: 27,
        eps: 28,
        occlude: 29,
        zIndexRange: 30,
        sprite: 31,
        pointerEvents: 32,
        center: 33,
        fullscreen: 34,
        distanceFactor: 35,
        as: 1,
        portal: 36,
        ref: 2,
        visible: 26
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HTML",
      options,
      id: create_fragment3.name
    });
  }
  get transform() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calculatePosition() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set calculatePosition(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eps() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eps(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get occlude() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set occlude(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndexRange() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndexRange(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sprite() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sprite(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceFactor() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceFactor(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HTML_default = HTML;

// node_modules/@threlte/extras/dist/components/Float/Float.svelte
var get_default_slot_changes2 = (dirty) => ({ ref: dirty & /*ref*/
32768 });
var get_default_slot_context2 = (ctx) => ({ ref: (
  /*ref*/
  ctx[15]
) });
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        36864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(54:0) <T.Group   position={floatPosition}   rotation={floatRotation}   let:ref   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let t_group;
  let current;
  const t_group_spread_levels = [
    { position: (
      /*floatPosition*/
      ctx[0]
    ) },
    { rotation: (
      /*floatRotation*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let t_group_props = {
    $$slots: {
      default: [
        create_default_slot3,
        ({ ref }) => ({ 15: ref }),
        ({ ref }) => ref ? 32768 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_group_spread_levels.length; i += 1) {
    t_group_props = assign(t_group_props, t_group_spread_levels[i]);
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_group_changes = dirty & /*floatPosition, floatRotation, $$restProps*/
      7 ? get_spread_update(t_group_spread_levels, [
        dirty & /*floatPosition*/
        1 && { position: (
          /*floatPosition*/
          ctx2[0]
        ) },
        dirty & /*floatRotation*/
        2 && { rotation: (
          /*floatRotation*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      36864) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "position",
    "rotation",
    "speed",
    "floatIntensity",
    "floatingRange",
    "rotationSpeed",
    "rotationIntensity",
    "seed"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Float", slots, ["default"]);
  let { position = 0 } = $$props;
  let { rotation = 0 } = $$props;
  let { speed = 1 } = $$props;
  let { floatIntensity = 1 } = $$props;
  let { floatingRange = [-0.1, 0.1] } = $$props;
  let { rotationSpeed = 0 } = $$props;
  let { rotationIntensity = 0 } = $$props;
  let { seed = Math.random() * 1e4 } = $$props;
  let t2 = seed;
  let floatPosition = Array.isArray(position) ? position : [position, position, position];
  const map = MathUtils.mapLinear;
  let floatRotation = Array.isArray(rotation) ? rotation : [rotation, rotation, rotation];
  useTask((delta) => {
    t2 += delta;
    const fSpeed = Array.isArray(speed) ? speed : [speed, speed, speed];
    const fIntensity = Array.isArray(floatIntensity) ? floatIntensity : [floatIntensity, floatIntensity, floatIntensity];
    const fRange = floatingRange.length == 3 ? floatingRange : [[0, 0], floatingRange, [0, 0]];
    $$invalidate(0, floatPosition = Array.isArray(position) ? position : [position, position, position]);
    $$invalidate(0, floatPosition[0] = floatPosition[0] + map(Math.sin(t2 / 4 * fSpeed[0]) / 10, -0.1, 0.1, ...fRange[0]) * fIntensity[0], floatPosition);
    $$invalidate(0, floatPosition[1] = floatPosition[1] + map(Math.sin(t2 / 4 * fSpeed[1]) / 10, -0.1, 0.1, ...fRange[1]) * fIntensity[1], floatPosition);
    $$invalidate(0, floatPosition[2] = floatPosition[2] + map(Math.sin(t2 / 4 * fSpeed[2]) / 10, -0.1, 0.1, ...fRange[2]) * fIntensity[2], floatPosition);
    $$invalidate(0, floatPosition);
    const rSpeed = Array.isArray(rotationSpeed) ? rotationSpeed : [rotationSpeed, rotationSpeed, rotationSpeed];
    const rIntensity = Array.isArray(rotationIntensity) ? rotationIntensity : [rotationIntensity, rotationIntensity, rotationIntensity];
    $$invalidate(1, floatRotation = Array.isArray(rotation) ? rotation : [rotation, rotation, rotation]);
    $$invalidate(1, floatRotation[0] += Math.cos(t2 / 4 * rSpeed[0]) / 8 * rIntensity[0], floatRotation);
    $$invalidate(1, floatRotation[1] += Math.cos(t2 / 4 * rSpeed[1]) / 8 * rIntensity[1], floatRotation);
    $$invalidate(1, floatRotation[2] += Math.cos(t2 / 4 * rSpeed[2]) / 8 * rIntensity[2], floatRotation);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props) $$invalidate(3, position = $$new_props.position);
    if ("rotation" in $$new_props) $$invalidate(4, rotation = $$new_props.rotation);
    if ("speed" in $$new_props) $$invalidate(5, speed = $$new_props.speed);
    if ("floatIntensity" in $$new_props) $$invalidate(6, floatIntensity = $$new_props.floatIntensity);
    if ("floatingRange" in $$new_props) $$invalidate(7, floatingRange = $$new_props.floatingRange);
    if ("rotationSpeed" in $$new_props) $$invalidate(8, rotationSpeed = $$new_props.rotationSpeed);
    if ("rotationIntensity" in $$new_props) $$invalidate(9, rotationIntensity = $$new_props.rotationIntensity);
    if ("seed" in $$new_props) $$invalidate(10, seed = $$new_props.seed);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MathUtils,
    useTask,
    T,
    position,
    rotation,
    speed,
    floatIntensity,
    floatingRange,
    rotationSpeed,
    rotationIntensity,
    seed,
    t: t2,
    floatPosition,
    map,
    floatRotation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props) $$invalidate(3, position = $$new_props.position);
    if ("rotation" in $$props) $$invalidate(4, rotation = $$new_props.rotation);
    if ("speed" in $$props) $$invalidate(5, speed = $$new_props.speed);
    if ("floatIntensity" in $$props) $$invalidate(6, floatIntensity = $$new_props.floatIntensity);
    if ("floatingRange" in $$props) $$invalidate(7, floatingRange = $$new_props.floatingRange);
    if ("rotationSpeed" in $$props) $$invalidate(8, rotationSpeed = $$new_props.rotationSpeed);
    if ("rotationIntensity" in $$props) $$invalidate(9, rotationIntensity = $$new_props.rotationIntensity);
    if ("seed" in $$props) $$invalidate(10, seed = $$new_props.seed);
    if ("t" in $$props) t2 = $$new_props.t;
    if ("floatPosition" in $$props) $$invalidate(0, floatPosition = $$new_props.floatPosition);
    if ("floatRotation" in $$props) $$invalidate(1, floatRotation = $$new_props.floatRotation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    floatPosition,
    floatRotation,
    $$restProps,
    position,
    rotation,
    speed,
    floatIntensity,
    floatingRange,
    rotationSpeed,
    rotationIntensity,
    seed,
    slots,
    $$scope
  ];
}
var Float = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      position: 3,
      rotation: 4,
      speed: 5,
      floatIntensity: 6,
      floatingRange: 7,
      rotationSpeed: 8,
      rotationIntensity: 9,
      seed: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Float",
      options,
      id: create_fragment4.name
    });
  }
  get position() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatIntensity() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatIntensity(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingRange() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingRange(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationSpeed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationSpeed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationIntensity() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationIntensity(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get seed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set seed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Float_default = Float;

// node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte
var { console: console_12 } = globals;
var get_default_slot_changes3 = (dirty) => ({ ref: dirty & /*ref*/
67108864 });
var get_default_slot_context3 = (ctx) => ({ ref: (
  /*ref*/
  ctx[26]
) });
function create_if_block3(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*scene*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [
        create_default_slot4,
        ({ ref }) => ({ 26: ref }),
        ({ ref }) => ref ? 67108864 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[18](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*scene, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*scene*/
        1 && { is: (
          /*scene*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      67633152) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(71:0) {#if scene}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        67633152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(72:2) <T     is={scene}     {...$$restProps}     let:ref     bind:this={$component}   >",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*scene*/
    ctx[0] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*scene*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*scene*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "url",
    "useDraco",
    "useMeshopt",
    "ktxTranscoderPath",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GLTF", slots, ["default"]);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  let { url } = $$props;
  let { useDraco = false } = $$props;
  let { useMeshopt = false } = $$props;
  let { ktxTranscoderPath = void 0 } = $$props;
  const dispatch = createRawEventDispatcher();
  let { gltf = void 0 } = $$props;
  let { scene = void 0 } = $$props;
  let { animations = void 0 } = $$props;
  let { asset = void 0 } = $$props;
  let { cameras = void 0 } = $$props;
  let { scenes = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { parser = void 0 } = $$props;
  let { materials = void 0 } = $$props;
  let { nodes = void 0 } = $$props;
  const loader = useGltf({
    useDraco: useDraco ? typeof useDraco === "string" ? useDraco : "https://www.gstatic.com/draco/v1/decoders/" : void 0,
    useMeshopt,
    ktxTranscoderPath
  });
  const onLoad = (data) => {
    if (gltf) dispatch("unload");
    $$invalidate(4, gltf = data);
    $$invalidate(0, scene = data.scene);
    $$invalidate(5, animations = data.animations);
    $$invalidate(6, asset = data.asset);
    $$invalidate(7, cameras = data.cameras);
    $$invalidate(8, scenes = data.scenes);
    $$invalidate(9, userData = data.userData);
    $$invalidate(10, parser = data.parser);
    $$invalidate(11, materials = data.materials);
    $$invalidate(12, nodes = data.nodes);
    dispatch("load", gltf);
  };
  const onError = (error) => {
    console.error(`Error loading GLTF: ${error.message}`);
    $$invalidate(4, gltf = void 0);
    $$invalidate(0, scene = void 0);
    $$invalidate(5, animations = void 0);
    $$invalidate(6, asset = void 0);
    $$invalidate(7, cameras = void 0);
    $$invalidate(8, scenes = void 0);
    $$invalidate(9, userData = void 0);
    $$invalidate(10, parser = void 0);
    $$invalidate(12, nodes = void 0);
    $$invalidate(11, materials = void 0);
    dispatch("error", error.message);
  };
  const suspend = useSuspense();
  const loadGltf = async (url2) => {
    try {
      const model = await suspend(loader.load(url2));
      onLoad(model);
    } catch (error) {
      onError(error);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console_12.warn("<GLTF> was created without expected prop 'url'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("url" in $$new_props) $$invalidate(13, url = $$new_props.url);
    if ("useDraco" in $$new_props) $$invalidate(14, useDraco = $$new_props.useDraco);
    if ("useMeshopt" in $$new_props) $$invalidate(15, useMeshopt = $$new_props.useMeshopt);
    if ("ktxTranscoderPath" in $$new_props) $$invalidate(16, ktxTranscoderPath = $$new_props.ktxTranscoderPath);
    if ("gltf" in $$new_props) $$invalidate(4, gltf = $$new_props.gltf);
    if ("scene" in $$new_props) $$invalidate(0, scene = $$new_props.scene);
    if ("animations" in $$new_props) $$invalidate(5, animations = $$new_props.animations);
    if ("asset" in $$new_props) $$invalidate(6, asset = $$new_props.asset);
    if ("cameras" in $$new_props) $$invalidate(7, cameras = $$new_props.cameras);
    if ("scenes" in $$new_props) $$invalidate(8, scenes = $$new_props.scenes);
    if ("userData" in $$new_props) $$invalidate(9, userData = $$new_props.userData);
    if ("parser" in $$new_props) $$invalidate(10, parser = $$new_props.parser);
    if ("materials" in $$new_props) $$invalidate(11, materials = $$new_props.materials);
    if ("nodes" in $$new_props) $$invalidate(12, nodes = $$new_props.nodes);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    forwardEventHandlers,
    T,
    useGltf,
    useSuspense,
    component,
    url,
    useDraco,
    useMeshopt,
    ktxTranscoderPath,
    dispatch,
    gltf,
    scene,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    loader,
    onLoad,
    onError,
    suspend,
    loadGltf,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("url" in $$props) $$invalidate(13, url = $$new_props.url);
    if ("useDraco" in $$props) $$invalidate(14, useDraco = $$new_props.useDraco);
    if ("useMeshopt" in $$props) $$invalidate(15, useMeshopt = $$new_props.useMeshopt);
    if ("ktxTranscoderPath" in $$props) $$invalidate(16, ktxTranscoderPath = $$new_props.ktxTranscoderPath);
    if ("gltf" in $$props) $$invalidate(4, gltf = $$new_props.gltf);
    if ("scene" in $$props) $$invalidate(0, scene = $$new_props.scene);
    if ("animations" in $$props) $$invalidate(5, animations = $$new_props.animations);
    if ("asset" in $$props) $$invalidate(6, asset = $$new_props.asset);
    if ("cameras" in $$props) $$invalidate(7, cameras = $$new_props.cameras);
    if ("scenes" in $$props) $$invalidate(8, scenes = $$new_props.scenes);
    if ("userData" in $$props) $$invalidate(9, userData = $$new_props.userData);
    if ("parser" in $$props) $$invalidate(10, parser = $$new_props.parser);
    if ("materials" in $$props) $$invalidate(11, materials = $$new_props.materials);
    if ("nodes" in $$props) $$invalidate(12, nodes = $$new_props.nodes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*url*/
    8192) {
      $: loadGltf(url);
    }
  };
  return [
    scene,
    $component,
    component,
    $$restProps,
    gltf,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    url,
    useDraco,
    useMeshopt,
    ktxTranscoderPath,
    slots,
    t_binding,
    $$scope
  ];
}
var GLTF = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      url: 13,
      useDraco: 14,
      useMeshopt: 15,
      ktxTranscoderPath: 16,
      gltf: 4,
      scene: 0,
      animations: 5,
      asset: 6,
      cameras: 7,
      scenes: 8,
      userData: 9,
      parser: 10,
      materials: 11,
      nodes: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GLTF",
      options,
      id: create_fragment5.name
    });
  }
  get url() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useDraco() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useDraco(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useMeshopt() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useMeshopt(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ktxTranscoderPath() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ktxTranscoderPath(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gltf() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gltf(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scene() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scene(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animations() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animations(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asset() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asset(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cameras() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cameras(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scenes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scenes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get materials() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set materials(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GLTF_default = GLTF;

// node_modules/@threlte/extras/dist/components/Gizmo/Gizmo.svelte
function get_context(ctx) {
  const constants_0 = -20;
  ctx[60] = constants_0;
}
function create_default_slot_10(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*xColor*/
          ctx[0],
          /*xLabel*/
          ctx[3]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][0] >= 0 ? 1 : 0.5
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, xColor, xLabel*/
      32777) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*xColor*/
        ctx2[0],
        /*xLabel*/
        ctx2[3]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][0] >= 0 ? 1 : 0.5;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: "(247:4) <T.Sprite       renderOrder={1}       bind:ref={posX}       position.x={1}       userData.targetPosition={[1, 0, 0]}       userData.targetEuler={[0, Math.PI * 0.5, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let t0;
  let t1;
  let t_meshbasicmaterial;
  let current;
  t0 = new T({
    props: { is: (
      /*stemGeometry*/
      ctx[18]
    ) },
    $$inline: true
  });
  t_meshbasicmaterial = new T.MeshBasicMaterial({
    props: {
      transparent: true,
      opacity: (
        /*p*/
        ctx[6][0] >= 0 ? 1 : 0.5
      ),
      color: (
        /*xColor*/
        ctx[0]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        ctx[13] && /*frontMostAxisIndex*/
        ctx[14] === 0 && /*p*/
        ctx[6][0] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        ctx[60]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      create_component(t_meshbasicmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_meshbasicmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_meshbasicmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_meshbasicmaterial_changes = {};
      if (dirty[0] & /*p*/
      64) t_meshbasicmaterial_changes.opacity = /*p*/
      ctx2[6][0] >= 0 ? 1 : 0.5;
      if (dirty[0] & /*xColor*/
      1) t_meshbasicmaterial_changes.color = /*xColor*/
      ctx2[0];
      if (dirty[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      24640) t_meshbasicmaterial_changes.polygonOffset = /*usePolygonOffset*/
      ctx2[13] && /*frontMostAxisIndex*/
      ctx2[14] === 0 && /*p*/
      ctx2[6][0] < 0.75;
      t_meshbasicmaterial.$set(t_meshbasicmaterial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(t_meshbasicmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(t_meshbasicmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
      }
      destroy_component(t0, detaching);
      destroy_component(t_meshbasicmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: "(260:4) <T.Mesh       position.x={0.39}       renderOrder={frontMostAxisIndex === 0 ? -1 : 0}     >",
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*xColor*/
          ctx[0]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][0] >= 0 ? 0.5 : 1
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, xColor*/
      32769) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*xColor*/
        ctx2[0]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][0] >= 0 ? 0.5 : 1;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: "(274:4) <T.Sprite       renderOrder={1}       bind:ref={negX}       position.x={-1}       scale={0.8}       userData.targetPosition={[-1, 0, 0]}       userData.targetEuler={[0, -Math.PI * 0.5, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*yColor*/
          ctx[1],
          /*yLabel*/
          ctx[4]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][1] >= 0 ? 1 : 0.5
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, yColor, yLabel*/
      32786) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*yColor*/
        ctx2[1],
        /*yLabel*/
        ctx2[4]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][1] >= 0 ? 1 : 0.5;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(289:4) <T.Sprite       renderOrder={1}       bind:ref={posY}       position.y={1}       userData.targetPosition={[0, 1, 0]}       userData.targetEuler={[-Math.PI * 0.5, 0, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let t0;
  let t1;
  let t_meshbasicmaterial;
  let current;
  t0 = new T({
    props: { is: (
      /*stemGeometry*/
      ctx[18]
    ) },
    $$inline: true
  });
  t_meshbasicmaterial = new T.MeshBasicMaterial({
    props: {
      transparent: true,
      opacity: (
        /*p*/
        ctx[6][1] >= 0 ? 1 : 0.5
      ),
      color: (
        /*yColor*/
        ctx[1]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        ctx[13] && /*frontMostAxisIndex*/
        ctx[14] === 1 && /*p*/
        ctx[6][1] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        ctx[60]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      create_component(t_meshbasicmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_meshbasicmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_meshbasicmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_meshbasicmaterial_changes = {};
      if (dirty[0] & /*p*/
      64) t_meshbasicmaterial_changes.opacity = /*p*/
      ctx2[6][1] >= 0 ? 1 : 0.5;
      if (dirty[0] & /*yColor*/
      2) t_meshbasicmaterial_changes.color = /*yColor*/
      ctx2[1];
      if (dirty[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      24640) t_meshbasicmaterial_changes.polygonOffset = /*usePolygonOffset*/
      ctx2[13] && /*frontMostAxisIndex*/
      ctx2[14] === 1 && /*p*/
      ctx2[6][1] < 0.75;
      t_meshbasicmaterial.$set(t_meshbasicmaterial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(t_meshbasicmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(t_meshbasicmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
      }
      destroy_component(t0, detaching);
      destroy_component(t_meshbasicmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(302:4) <T.Mesh       position.y={0.39}       rotation.z={Math.PI / 2}       renderOrder={frontMostAxisIndex === 1 ? -1 : 0}     >",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*yColor*/
          ctx[1]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][1] >= 0 ? 0.5 : 1
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, yColor*/
      32770) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*yColor*/
        ctx2[1]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][1] >= 0 ? 0.5 : 1;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(317:4) <T.Sprite       renderOrder={1}       bind:ref={negY}       position.y={-1}       scale={0.8}       userData.targetPosition={[0, -1, 0]}       userData.targetEuler={[Math.PI * 0.5, 0, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*zColor*/
          ctx[2],
          /*zLabel*/
          ctx[5]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][2] >= 0 ? 1 : 0.5
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, zColor, zLabel*/
      32804) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*zColor*/
        ctx2[2],
        /*zLabel*/
        ctx2[5]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][2] >= 0 ? 1 : 0.5;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(332:4) <T.Sprite       renderOrder={1}       bind:ref={posZ}       position.z={1}       userData.targetPosition={[0, 0, 1]}       userData.targetEuler={[0, 0, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t0;
  let t1;
  let t_meshbasicmaterial;
  let current;
  t0 = new T({
    props: { is: (
      /*stemGeometry*/
      ctx[18]
    ) },
    $$inline: true
  });
  t_meshbasicmaterial = new T.MeshBasicMaterial({
    props: {
      transparent: true,
      opacity: (
        /*p*/
        ctx[6][2] >= 0 ? 1 : 0.5
      ),
      color: (
        /*zColor*/
        ctx[2]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        ctx[13] && /*frontMostAxisIndex*/
        ctx[14] === 2 && /*p*/
        ctx[6][2] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        ctx[60]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      create_component(t_meshbasicmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_meshbasicmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_meshbasicmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_meshbasicmaterial_changes = {};
      if (dirty[0] & /*p*/
      64) t_meshbasicmaterial_changes.opacity = /*p*/
      ctx2[6][2] >= 0 ? 1 : 0.5;
      if (dirty[0] & /*zColor*/
      4) t_meshbasicmaterial_changes.color = /*zColor*/
      ctx2[2];
      if (dirty[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      24640) t_meshbasicmaterial_changes.polygonOffset = /*usePolygonOffset*/
      ctx2[13] && /*frontMostAxisIndex*/
      ctx2[14] === 2 && /*p*/
      ctx2[6][2] < 0.75;
      t_meshbasicmaterial.$set(t_meshbasicmaterial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(t_meshbasicmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(t_meshbasicmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
      }
      destroy_component(t0, detaching);
      destroy_component(t_meshbasicmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(345:4) <T.Mesh       position.z={0.39}       rotation.y={-Math.PI / 2}       renderOrder={frontMostAxisIndex === 2 ? -1 : 0}     >",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t_spritematerial;
  let current;
  t_spritematerial = new T.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        ctx[17](
          /*textureSize*/
          ctx[15],
          /*zColor*/
          ctx[2]
        )
      ),
      opacity: (
        /*p*/
        ctx[6][2] >= 0 ? 0.5 : 1
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spritematerial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spritematerial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spritematerial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spritematerial_changes = {};
      if (dirty[0] & /*textureSize, zColor*/
      32772) t_spritematerial_changes.map = /*getSpriteTexture*/
      ctx2[17](
        /*textureSize*/
        ctx2[15],
        /*zColor*/
        ctx2[2]
      );
      if (dirty[0] & /*p*/
      64) t_spritematerial_changes.opacity = /*p*/
      ctx2[6][2] >= 0 ? 0.5 : 1;
      t_spritematerial.$set(t_spritematerial_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_spritematerial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spritematerial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spritematerial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(360:4) <T.Sprite       renderOrder={1}       bind:ref={negZ}       position.z={-1}       scale={0.8}       userData.targetPosition={[0, 0, -1]}       userData.targetEuler={[0, Math.PI, 0]}     >",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  get_context(ctx);
  let t_sprite0;
  let updating_ref;
  let t0;
  let t_mesh0;
  let t1;
  let t_sprite1;
  let updating_ref_1;
  let t2;
  let t_sprite2;
  let updating_ref_2;
  let t3;
  let t_mesh1;
  let t4;
  let t_sprite3;
  let updating_ref_3;
  let t5;
  let t_sprite4;
  let updating_ref_4;
  let t6;
  let t_mesh2;
  let t7;
  let t_sprite5;
  let updating_ref_5;
  let current;
  function t_sprite0_ref_binding(value) {
    ctx[30](value);
  }
  let t_sprite0_props = {
    renderOrder: 1,
    "position.x": 1,
    "userData.targetPosition": [1, 0, 0],
    "userData.targetEuler": [0, Math.PI * 0.5, 0],
    $$slots: { default: [create_default_slot_10] },
    $$scope: { ctx }
  };
  if (
    /*posX*/
    ctx[7] !== void 0
  ) {
    t_sprite0_props.ref = /*posX*/
    ctx[7];
  }
  t_sprite0 = new T.Sprite({ props: t_sprite0_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite0, "ref", t_sprite0_ref_binding));
  t_mesh0 = new T.Mesh({
    props: {
      "position.x": 0.39,
      renderOrder: (
        /*frontMostAxisIndex*/
        ctx[14] === 0 ? -1 : 0
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function t_sprite1_ref_binding(value) {
    ctx[31](value);
  }
  let t_sprite1_props = {
    renderOrder: 1,
    "position.x": -1,
    scale: 0.8,
    "userData.targetPosition": [-1, 0, 0],
    "userData.targetEuler": [0, -Math.PI * 0.5, 0],
    $$slots: { default: [create_default_slot_8] },
    $$scope: { ctx }
  };
  if (
    /*negX*/
    ctx[10] !== void 0
  ) {
    t_sprite1_props.ref = /*negX*/
    ctx[10];
  }
  t_sprite1 = new T.Sprite({ props: t_sprite1_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite1, "ref", t_sprite1_ref_binding));
  function t_sprite2_ref_binding(value) {
    ctx[32](value);
  }
  let t_sprite2_props = {
    renderOrder: 1,
    "position.y": 1,
    "userData.targetPosition": [0, 1, 0],
    "userData.targetEuler": [-Math.PI * 0.5, 0, 0],
    $$slots: { default: [create_default_slot_7] },
    $$scope: { ctx }
  };
  if (
    /*posY*/
    ctx[8] !== void 0
  ) {
    t_sprite2_props.ref = /*posY*/
    ctx[8];
  }
  t_sprite2 = new T.Sprite({ props: t_sprite2_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite2, "ref", t_sprite2_ref_binding));
  t_mesh1 = new T.Mesh({
    props: {
      "position.y": 0.39,
      "rotation.z": Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        ctx[14] === 1 ? -1 : 0
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function t_sprite3_ref_binding(value) {
    ctx[33](value);
  }
  let t_sprite3_props = {
    renderOrder: 1,
    "position.y": -1,
    scale: 0.8,
    "userData.targetPosition": [0, -1, 0],
    "userData.targetEuler": [Math.PI * 0.5, 0, 0],
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  if (
    /*negY*/
    ctx[11] !== void 0
  ) {
    t_sprite3_props.ref = /*negY*/
    ctx[11];
  }
  t_sprite3 = new T.Sprite({ props: t_sprite3_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite3, "ref", t_sprite3_ref_binding));
  function t_sprite4_ref_binding(value) {
    ctx[34](value);
  }
  let t_sprite4_props = {
    renderOrder: 1,
    "position.z": 1,
    "userData.targetPosition": [0, 0, 1],
    "userData.targetEuler": [0, 0, 0],
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  if (
    /*posZ*/
    ctx[9] !== void 0
  ) {
    t_sprite4_props.ref = /*posZ*/
    ctx[9];
  }
  t_sprite4 = new T.Sprite({ props: t_sprite4_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite4, "ref", t_sprite4_ref_binding));
  t_mesh2 = new T.Mesh({
    props: {
      "position.z": 0.39,
      "rotation.y": -Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        ctx[14] === 2 ? -1 : 0
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function t_sprite5_ref_binding(value) {
    ctx[35](value);
  }
  let t_sprite5_props = {
    renderOrder: 1,
    "position.z": -1,
    scale: 0.8,
    "userData.targetPosition": [0, 0, -1],
    "userData.targetEuler": [0, Math.PI, 0],
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  if (
    /*negZ*/
    ctx[12] !== void 0
  ) {
    t_sprite5_props.ref = /*negZ*/
    ctx[12];
  }
  t_sprite5 = new T.Sprite({ props: t_sprite5_props, $$inline: true });
  binding_callbacks.push(() => bind(t_sprite5, "ref", t_sprite5_ref_binding));
  const block = {
    c: function create() {
      create_component(t_sprite0.$$.fragment);
      t0 = space();
      create_component(t_mesh0.$$.fragment);
      t1 = space();
      create_component(t_sprite1.$$.fragment);
      t2 = space();
      create_component(t_sprite2.$$.fragment);
      t3 = space();
      create_component(t_mesh1.$$.fragment);
      t4 = space();
      create_component(t_sprite3.$$.fragment);
      t5 = space();
      create_component(t_sprite4.$$.fragment);
      t6 = space();
      create_component(t_mesh2.$$.fragment);
      t7 = space();
      create_component(t_sprite5.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_sprite0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_mesh0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_sprite1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(t_sprite2.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(t_mesh1.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(t_sprite3.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(t_sprite4.$$.fragment, nodes);
      t6 = claim_space(nodes);
      claim_component(t_mesh2.$$.fragment, nodes);
      t7 = claim_space(nodes);
      claim_component(t_sprite5.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_sprite0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_mesh0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_sprite1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(t_sprite2, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(t_mesh1, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(t_sprite3, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(t_sprite4, target, anchor);
      insert_hydration_dev(target, t6, anchor);
      mount_component(t_mesh2, target, anchor);
      insert_hydration_dev(target, t7, anchor);
      mount_component(t_sprite5, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      get_context(ctx2);
      const t_sprite0_changes = {};
      if (dirty[0] & /*textureSize, xColor, xLabel, p*/
      32841 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty[0] & /*posX*/
      128) {
        updating_ref = true;
        t_sprite0_changes.ref = /*posX*/
        ctx2[7];
        add_flush_callback(() => updating_ref = false);
      }
      t_sprite0.$set(t_sprite0_changes);
      const t_mesh0_changes = {};
      if (dirty[0] & /*frontMostAxisIndex*/
      16384) t_mesh0_changes.renderOrder = /*frontMostAxisIndex*/
      ctx2[14] === 0 ? -1 : 0;
      if (dirty[0] & /*p, xColor, usePolygonOffset, frontMostAxisIndex*/
      24641 | dirty[1] & /*$$scope*/
      1073741824) {
        t_mesh0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_mesh0.$set(t_mesh0_changes);
      const t_sprite1_changes = {};
      if (dirty[0] & /*textureSize, xColor, p*/
      32833 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_1 && dirty[0] & /*negX*/
      1024) {
        updating_ref_1 = true;
        t_sprite1_changes.ref = /*negX*/
        ctx2[10];
        add_flush_callback(() => updating_ref_1 = false);
      }
      t_sprite1.$set(t_sprite1_changes);
      const t_sprite2_changes = {};
      if (dirty[0] & /*textureSize, yColor, yLabel, p*/
      32850 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_2 && dirty[0] & /*posY*/
      256) {
        updating_ref_2 = true;
        t_sprite2_changes.ref = /*posY*/
        ctx2[8];
        add_flush_callback(() => updating_ref_2 = false);
      }
      t_sprite2.$set(t_sprite2_changes);
      const t_mesh1_changes = {};
      if (dirty[0] & /*frontMostAxisIndex*/
      16384) t_mesh1_changes.renderOrder = /*frontMostAxisIndex*/
      ctx2[14] === 1 ? -1 : 0;
      if (dirty[0] & /*p, yColor, usePolygonOffset, frontMostAxisIndex*/
      24642 | dirty[1] & /*$$scope*/
      1073741824) {
        t_mesh1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_mesh1.$set(t_mesh1_changes);
      const t_sprite3_changes = {};
      if (dirty[0] & /*textureSize, yColor, p*/
      32834 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_3 && dirty[0] & /*negY*/
      2048) {
        updating_ref_3 = true;
        t_sprite3_changes.ref = /*negY*/
        ctx2[11];
        add_flush_callback(() => updating_ref_3 = false);
      }
      t_sprite3.$set(t_sprite3_changes);
      const t_sprite4_changes = {};
      if (dirty[0] & /*textureSize, zColor, zLabel, p*/
      32868 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_4 && dirty[0] & /*posZ*/
      512) {
        updating_ref_4 = true;
        t_sprite4_changes.ref = /*posZ*/
        ctx2[9];
        add_flush_callback(() => updating_ref_4 = false);
      }
      t_sprite4.$set(t_sprite4_changes);
      const t_mesh2_changes = {};
      if (dirty[0] & /*frontMostAxisIndex*/
      16384) t_mesh2_changes.renderOrder = /*frontMostAxisIndex*/
      ctx2[14] === 2 ? -1 : 0;
      if (dirty[0] & /*p, zColor, usePolygonOffset, frontMostAxisIndex*/
      24644 | dirty[1] & /*$$scope*/
      1073741824) {
        t_mesh2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_mesh2.$set(t_mesh2_changes);
      const t_sprite5_changes = {};
      if (dirty[0] & /*textureSize, zColor, p*/
      32836 | dirty[1] & /*$$scope*/
      1073741824) {
        t_sprite5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref_5 && dirty[0] & /*negZ*/
      4096) {
        updating_ref_5 = true;
        t_sprite5_changes.ref = /*negZ*/
        ctx2[12];
        add_flush_callback(() => updating_ref_5 = false);
      }
      t_sprite5.$set(t_sprite5_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_sprite0.$$.fragment, local);
      transition_in(t_mesh0.$$.fragment, local);
      transition_in(t_sprite1.$$.fragment, local);
      transition_in(t_sprite2.$$.fragment, local);
      transition_in(t_mesh1.$$.fragment, local);
      transition_in(t_sprite3.$$.fragment, local);
      transition_in(t_sprite4.$$.fragment, local);
      transition_in(t_mesh2.$$.fragment, local);
      transition_in(t_sprite5.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_sprite0.$$.fragment, local);
      transition_out(t_mesh0.$$.fragment, local);
      transition_out(t_sprite1.$$.fragment, local);
      transition_out(t_sprite2.$$.fragment, local);
      transition_out(t_mesh1.$$.fragment, local);
      transition_out(t_sprite3.$$.fragment, local);
      transition_out(t_sprite4.$$.fragment, local);
      transition_out(t_mesh2.$$.fragment, local);
      transition_out(t_sprite5.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(t7);
      }
      destroy_component(t_sprite0, detaching);
      destroy_component(t_mesh0, detaching);
      destroy_component(t_sprite1, detaching);
      destroy_component(t_sprite2, detaching);
      destroy_component(t_mesh1, detaching);
      destroy_component(t_sprite3, detaching);
      destroy_component(t_sprite4, detaching);
      destroy_component(t_mesh2, detaching);
      destroy_component(t_sprite5, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(243:2) <T is={root}>",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*root*/
        ctx[16]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, zLabel, negY, yColor, posY, yLabel, negX, xColor, posX, xLabel*/
      65535 | dirty[1] & /*$$scope*/
      1073741824) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(242:0) <HierarchicalObject>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hierarchicalobject_changes = {};
      if (dirty[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, zLabel, negY, yColor, posY, yLabel, negX, xColor, posX, xLabel*/
      65535 | dirty[1] & /*$$scope*/
      1073741824) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let centerVec;
  let textureSize;
  let frontMostAxisIndex;
  let usePolygonOffset;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gizmo", slots, []);
  let { renderTask = void 0 } = $$props;
  let { animationTask = void 0 } = $$props;
  let { turnRate = 2 * Math.PI } = $$props;
  let { center = [0, 0, 0] } = $$props;
  let { verticalPlacement = "bottom" } = $$props;
  let { horizontalPlacement = "right" } = $$props;
  let { size = 128 } = $$props;
  let { xColor = 16725587 } = $$props;
  let { yColor = 9100032 } = $$props;
  let { zColor = 2920447 } = $$props;
  let { toneMapped = false } = $$props;
  let { paddingX = 0 } = $$props;
  let { paddingY = 0 } = $$props;
  let { xLabel = "X" } = $$props;
  let { yLabel = "Y" } = $$props;
  let { zLabel = "Z" } = $$props;
  const { autoRenderTask, renderer, camera, invalidate } = useThrelte();
  const orthoCam = new OrthographicCamera(-1.25, 1.25, 1.25, -1.25, 0, 4);
  orthoCam.position.set(0, 0, 2);
  const root = new Scene();
  const viewport = new Vector4();
  useTask(
    (renderTask == null ? void 0 : renderTask.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      const autoClear = renderer.autoClear;
      $$invalidate(29, renderer.autoClear = false, renderer);
      renderer.getViewport(viewport);
      const toneMapping = renderer.toneMapping;
      $$invalidate(29, renderer.toneMapping = toneMapped ? renderer.toneMapping : 0, renderer);
      const x = horizontalPlacement === "left" ? paddingX : renderer.domElement.offsetWidth - size - paddingX;
      const y = verticalPlacement === "bottom" ? paddingY : renderer.domElement.offsetHeight - size - paddingY;
      renderer.setViewport(x, y, size, size);
      renderer.render(root, orthoCam);
      renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
      $$invalidate(29, renderer.autoClear = autoClear, renderer);
      $$invalidate(29, renderer.toneMapping = toneMapping, renderer);
    },
    {
      ...renderTask ?? { after: autoRenderTask },
      autoInvalidate: false
    }
  );
  const clickTarget = document.createElement("div");
  const renderTarget = renderer.domElement;
  const boundingRect = renderTarget.getBoundingClientRect();
  clickTarget.style.position = "absolute";
  let posX;
  let posY;
  let posZ;
  let negX;
  let negY;
  let negZ;
  const targetPosition = new Vector3();
  const targetQuaternion = new Quaternion();
  const currentQuaternion = new Quaternion();
  const finalQuaternion = new Quaternion();
  let radius = 0;
  let animating = false;
  const mouse = new Vector2();
  const raycaster = new Raycaster();
  const quaternionsAreEqual = (a, b, threshold) => {
    const delta = Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z) + Math.abs(a.w - b.w);
    return delta < threshold;
  };
  const handleIntersection = (intersection) => {
    const object = intersection.object;
    const targetPos = object.userData.targetPosition;
    const targetEuler = object.userData.targetEuler;
    radius = camera.current.position.distanceTo(centerVec);
    targetPosition.set(...targetPos).multiplyScalar(radius).add(centerVec);
    targetQuaternion.setFromEuler(new Euler(...targetEuler));
    const dummy = new Object3D();
    dummy.position.copy(centerVec);
    dummy.lookAt(camera.current.position);
    currentQuaternion.copy(dummy.quaternion);
    dummy.lookAt(targetPosition);
    finalQuaternion.copy(dummy.quaternion);
    if (quaternionsAreEqual(finalQuaternion, currentQuaternion, 1e-4)) {
      return true;
    }
    animating = true;
    return false;
  };
  const handleClick = (event) => {
    if (animating) {
      return;
    }
    const rect = clickTarget.getBoundingClientRect();
    const offsetX = rect.left + (clickTarget.offsetWidth - size);
    const offsetY = rect.top + (clickTarget.offsetHeight - size);
    mouse.x = (event.clientX - offsetX) / (rect.right - offsetX) * 2 - 1;
    mouse.y = -((event.clientY - offsetY) / (rect.bottom - offsetY)) * 2 + 1;
    raycaster.setFromCamera(mouse, orthoCam);
    const intersects = raycaster.intersectObjects([posX, posY, posZ, negX, negY, negZ]);
    if (intersects.length > 0) {
      const alreadyReached = handleIntersection(intersects[0]);
      if (alreadyReached) {
        if (intersects.length > 1) {
          handleIntersection(intersects[1]);
        }
      }
    }
  };
  onMount(() => {
    var _a;
    (_a = renderer.domElement.parentElement) == null ? void 0 : _a.appendChild(clickTarget);
    clickTarget.addEventListener("click", handleClick);
  });
  onDestroy(() => {
    var _a;
    (_a = renderer.domElement.parentElement) == null ? void 0 : _a.removeChild(clickTarget);
    clickTarget.removeEventListener("click", handleClick);
  });
  const point = new Vector3();
  let p = [0, 0, 0];
  useTask(
    (animationTask == null ? void 0 : animationTask.key) ?? Symbol("threlte-extras-gizmo-animation"),
    (delta) => {
      point.set(0, 0, 1).applyQuaternion(camera.current.quaternion);
      if (point.x !== p[0] || point.y !== p[1] || point.z !== p[2]) {
        $$invalidate(6, p = [point.x, point.y, point.z]);
        root.quaternion.copy(camera.current.quaternion).invert();
        invalidate();
      }
      if (animating) {
        const step = delta * turnRate;
        currentQuaternion.rotateTowards(finalQuaternion, step);
        camera.current.position.set(0, 0, 1).applyQuaternion(currentQuaternion).multiplyScalar(radius).add(centerVec);
        camera.current.quaternion.rotateTowards(targetQuaternion, step);
        if (currentQuaternion.angleTo(finalQuaternion) === 0) {
          animating = false;
        }
        invalidate();
      }
    },
    { ...animationTask, autoInvalidate: false }
  );
  const findClosestPow2LargerThan = (x) => {
    if (x <= 0) {
      return 1;
    }
    let pow2 = 1;
    while (pow2 < x) {
      pow2 <<= 1;
    }
    return pow2;
  };
  const textures = {};
  const color = new Color();
  const getSpriteTexture = (size2, colorRepresentation, text = "") => {
    color.set(colorRepresentation);
    const key = `${color.getHexString()}-${text}`;
    if (textures[key]) {
      textures[key].dispose();
    }
    const canvas = document.createElement("canvas");
    canvas.width = size2;
    canvas.height = size2;
    const context = canvas.getContext("2d");
    context.beginPath();
    context.arc(size2 / 2, size2 / 2, size2 / 4, 0, 2 * Math.PI);
    context.closePath();
    context.fillStyle = color.convertSRGBToLinear().getStyle();
    context.fill();
    if (text) {
      const textSize = Math.abs(size2 * (24 / 64));
      context.font = `${textSize}px Arial`;
      context.textAlign = "center";
      context.fillStyle = "#000000";
      const textY = size2 * (41 / 64);
      context.fillText(text, size2 / 2, textY);
    }
    const texture = new CanvasTexture(canvas);
    textures[key] = texture;
    return texture;
  };
  const stemGeometry = new CapsuleGeometry(0.025, 0.78);
  stemGeometry.rotateZ(Math.PI / 2);
  const writable_props = [
    "renderTask",
    "animationTask",
    "turnRate",
    "center",
    "verticalPlacement",
    "horizontalPlacement",
    "size",
    "xColor",
    "yColor",
    "zColor",
    "toneMapped",
    "paddingX",
    "paddingY",
    "xLabel",
    "yLabel",
    "zLabel"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Gizmo> was created with unknown prop '${key}'`);
  });
  function t_sprite0_ref_binding(value) {
    posX = value;
    $$invalidate(7, posX);
  }
  function t_sprite1_ref_binding(value) {
    negX = value;
    $$invalidate(10, negX);
  }
  function t_sprite2_ref_binding(value) {
    posY = value;
    $$invalidate(8, posY);
  }
  function t_sprite3_ref_binding(value) {
    negY = value;
    $$invalidate(11, negY);
  }
  function t_sprite4_ref_binding(value) {
    posZ = value;
    $$invalidate(9, posZ);
  }
  function t_sprite5_ref_binding(value) {
    negZ = value;
    $$invalidate(12, negZ);
  }
  $$self.$$set = ($$props2) => {
    if ("renderTask" in $$props2) $$invalidate(19, renderTask = $$props2.renderTask);
    if ("animationTask" in $$props2) $$invalidate(20, animationTask = $$props2.animationTask);
    if ("turnRate" in $$props2) $$invalidate(21, turnRate = $$props2.turnRate);
    if ("center" in $$props2) $$invalidate(22, center = $$props2.center);
    if ("verticalPlacement" in $$props2) $$invalidate(23, verticalPlacement = $$props2.verticalPlacement);
    if ("horizontalPlacement" in $$props2) $$invalidate(24, horizontalPlacement = $$props2.horizontalPlacement);
    if ("size" in $$props2) $$invalidate(25, size = $$props2.size);
    if ("xColor" in $$props2) $$invalidate(0, xColor = $$props2.xColor);
    if ("yColor" in $$props2) $$invalidate(1, yColor = $$props2.yColor);
    if ("zColor" in $$props2) $$invalidate(2, zColor = $$props2.zColor);
    if ("toneMapped" in $$props2) $$invalidate(26, toneMapped = $$props2.toneMapped);
    if ("paddingX" in $$props2) $$invalidate(27, paddingX = $$props2.paddingX);
    if ("paddingY" in $$props2) $$invalidate(28, paddingY = $$props2.paddingY);
    if ("xLabel" in $$props2) $$invalidate(3, xLabel = $$props2.xLabel);
    if ("yLabel" in $$props2) $$invalidate(4, yLabel = $$props2.yLabel);
    if ("zLabel" in $$props2) $$invalidate(5, zLabel = $$props2.zLabel);
  };
  $$self.$capture_state = () => ({
    HierarchicalObject: HierarchicalObject_default,
    T,
    useTask,
    useThrelte,
    onDestroy,
    onMount,
    CanvasTexture,
    CapsuleGeometry,
    Color,
    Euler,
    Object3D,
    OrthographicCamera,
    Quaternion,
    Raycaster,
    Scene,
    Vector2,
    Vector3,
    Vector4,
    renderTask,
    animationTask,
    turnRate,
    center,
    verticalPlacement,
    horizontalPlacement,
    size,
    xColor,
    yColor,
    zColor,
    toneMapped,
    paddingX,
    paddingY,
    xLabel,
    yLabel,
    zLabel,
    autoRenderTask,
    renderer,
    camera,
    invalidate,
    orthoCam,
    root,
    viewport,
    clickTarget,
    renderTarget,
    boundingRect,
    posX,
    posY,
    posZ,
    negX,
    negY,
    negZ,
    targetPosition,
    targetQuaternion,
    currentQuaternion,
    finalQuaternion,
    radius,
    animating,
    mouse,
    raycaster,
    quaternionsAreEqual,
    handleIntersection,
    handleClick,
    point,
    p,
    findClosestPow2LargerThan,
    textures,
    color,
    getSpriteTexture,
    stemGeometry,
    usePolygonOffset,
    frontMostAxisIndex,
    textureSize,
    centerVec
  });
  $$self.$inject_state = ($$props2) => {
    if ("renderTask" in $$props2) $$invalidate(19, renderTask = $$props2.renderTask);
    if ("animationTask" in $$props2) $$invalidate(20, animationTask = $$props2.animationTask);
    if ("turnRate" in $$props2) $$invalidate(21, turnRate = $$props2.turnRate);
    if ("center" in $$props2) $$invalidate(22, center = $$props2.center);
    if ("verticalPlacement" in $$props2) $$invalidate(23, verticalPlacement = $$props2.verticalPlacement);
    if ("horizontalPlacement" in $$props2) $$invalidate(24, horizontalPlacement = $$props2.horizontalPlacement);
    if ("size" in $$props2) $$invalidate(25, size = $$props2.size);
    if ("xColor" in $$props2) $$invalidate(0, xColor = $$props2.xColor);
    if ("yColor" in $$props2) $$invalidate(1, yColor = $$props2.yColor);
    if ("zColor" in $$props2) $$invalidate(2, zColor = $$props2.zColor);
    if ("toneMapped" in $$props2) $$invalidate(26, toneMapped = $$props2.toneMapped);
    if ("paddingX" in $$props2) $$invalidate(27, paddingX = $$props2.paddingX);
    if ("paddingY" in $$props2) $$invalidate(28, paddingY = $$props2.paddingY);
    if ("xLabel" in $$props2) $$invalidate(3, xLabel = $$props2.xLabel);
    if ("yLabel" in $$props2) $$invalidate(4, yLabel = $$props2.yLabel);
    if ("zLabel" in $$props2) $$invalidate(5, zLabel = $$props2.zLabel);
    if ("posX" in $$props2) $$invalidate(7, posX = $$props2.posX);
    if ("posY" in $$props2) $$invalidate(8, posY = $$props2.posY);
    if ("posZ" in $$props2) $$invalidate(9, posZ = $$props2.posZ);
    if ("negX" in $$props2) $$invalidate(10, negX = $$props2.negX);
    if ("negY" in $$props2) $$invalidate(11, negY = $$props2.negY);
    if ("negZ" in $$props2) $$invalidate(12, negZ = $$props2.negZ);
    if ("radius" in $$props2) radius = $$props2.radius;
    if ("animating" in $$props2) animating = $$props2.animating;
    if ("p" in $$props2) $$invalidate(6, p = $$props2.p);
    if ("usePolygonOffset" in $$props2) $$invalidate(13, usePolygonOffset = $$props2.usePolygonOffset);
    if ("frontMostAxisIndex" in $$props2) $$invalidate(14, frontMostAxisIndex = $$props2.frontMostAxisIndex);
    if ("textureSize" in $$props2) $$invalidate(15, textureSize = $$props2.textureSize);
    if ("centerVec" in $$props2) centerVec = $$props2.centerVec;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*center*/
    4194304) {
      $: centerVec = new Vector3(...center);
    }
    if ($$self.$$.dirty[0] & /*size, horizontalPlacement, verticalPlacement, toneMapped, paddingX, paddingY*/
    528482304) {
      $: size, horizontalPlacement, verticalPlacement, toneMapped, paddingX, paddingY, invalidate();
    }
    if ($$self.$$.dirty[0] & /*horizontalPlacement, size, paddingX, verticalPlacement, paddingY*/
    461373440) {
      $: {
        if (horizontalPlacement === "right") {
          clickTarget.style.right = "";
          clickTarget.style.left = `${boundingRect.right - size - paddingX}px`;
        } else {
          clickTarget.style.right = "";
          clickTarget.style.left = `${paddingX + boundingRect.left}px`;
        }
        if (verticalPlacement === "bottom") {
          clickTarget.style.bottom = "";
          clickTarget.style.top = `${boundingRect.bottom - size - paddingY}px`;
        } else {
          clickTarget.style.bottom = "";
          clickTarget.style.top = `${paddingY + boundingRect.top}px`;
        }
        clickTarget.style.height = `${size}px`;
        clickTarget.style.width = `${size}px`;
      }
    }
    if ($$self.$$.dirty[0] & /*size, renderer*/
    570425344) {
      $: $$invalidate(15, textureSize = findClosestPow2LargerThan(size * 0.3 * renderer.getPixelRatio()));
    }
    if ($$self.$$.dirty[0] & /*p*/
    64) {
      $: $$invalidate(14, frontMostAxisIndex = p.indexOf(Math.max(...p)));
    }
    if ($$self.$$.dirty[0] & /*p*/
    64) {
      $: $$invalidate(13, usePolygonOffset = p.some((v) => v < 0));
    }
  };
  return [
    xColor,
    yColor,
    zColor,
    xLabel,
    yLabel,
    zLabel,
    p,
    posX,
    posY,
    posZ,
    negX,
    negY,
    negZ,
    usePolygonOffset,
    frontMostAxisIndex,
    textureSize,
    root,
    getSpriteTexture,
    stemGeometry,
    renderTask,
    animationTask,
    turnRate,
    center,
    verticalPlacement,
    horizontalPlacement,
    size,
    toneMapped,
    paddingX,
    paddingY,
    renderer,
    t_sprite0_ref_binding,
    t_sprite1_ref_binding,
    t_sprite2_ref_binding,
    t_sprite3_ref_binding,
    t_sprite4_ref_binding,
    t_sprite5_ref_binding
  ];
}
var Gizmo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        renderTask: 19,
        animationTask: 20,
        turnRate: 21,
        center: 22,
        verticalPlacement: 23,
        horizontalPlacement: 24,
        size: 25,
        xColor: 0,
        yColor: 1,
        zColor: 2,
        toneMapped: 26,
        paddingX: 27,
        paddingY: 28,
        xLabel: 3,
        yLabel: 4,
        zLabel: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gizmo",
      options,
      id: create_fragment6.name
    });
  }
  get renderTask() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderTask(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animationTask() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animationTask(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get turnRate() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set turnRate(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get verticalPlacement() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set verticalPlacement(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontalPlacement() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontalPlacement(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xColor() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xColor(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yColor() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yColor(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zColor() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zColor(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toneMapped() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toneMapped(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paddingX() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paddingX(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paddingY() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paddingY(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xLabel() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xLabel(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yLabel() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yLabel(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zLabel() {
    throw new Error("<Gizmo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zLabel(value) {
    throw new Error("<Gizmo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Gizmo_default = Gizmo;

// node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  name: "HorizontalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "h": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  name: "VerticalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "v": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/@threlte/extras/dist/lib/useMemo.js
var useMemo = (callback) => {
  let initialCallDone = false;
  const memoized = writable(callback());
  const memoize2 = (..._args) => {
    if (!initialCallDone) {
      initialCallDone = true;
      return;
    }
    memoized.set(callback());
  };
  return {
    ...memoized,
    memoize: memoize2
  };
};

// node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte
var get_default_slot_changes4 = (dirty) => ({ ref: dirty[1] & /*ref*/
1024 });
var get_default_slot_context4 = (ctx) => ({ ref: (
  /*ref*/
  ctx[41]
) });
function create_default_slot_12(ctx) {
  let t_mesh;
  let t0;
  let t1;
  let t2;
  let current;
  t_mesh = new T.Mesh({
    props: {
      "scale.y": -1,
      "rotation.x": -Math.PI / 2,
      material: (
        /*shadowMaterial*/
        ctx[10]
      ),
      geometry: (
        /*$planeGeometry*/
        ctx[0]
      )
    },
    $$inline: true
  });
  t1 = new T({
    props: {
      is: (
        /*shadowCamera*/
        ctx[9]
      ),
      manual: true
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
      t0 = space();
      create_component(t1.$$.fragment);
      t2 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_mesh_changes = {};
      if (dirty[0] & /*$planeGeometry*/
      1) t_mesh_changes.geometry = /*$planeGeometry*/
      ctx2[0];
      t_mesh.$set(t_mesh_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912 | dirty[1] & /*ref*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_mesh.$$.fragment, local);
      transition_in(t1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      transition_out(t1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t2);
      }
      destroy_component(t_mesh, detaching);
      destroy_component(t1, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(152:2) <T.Group rotation.x={Math.PI / 2}>",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t_group;
  let current;
  t_group = new T.Group({
    props: {
      "rotation.x": Math.PI / 2,
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = {};
      if (dirty[0] & /*$$scope, $planeGeometry*/
      536870913 | dirty[1] & /*ref*/
      1024) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(147:0) <T.Group   {...$$restProps}   let:ref   bind:this={$components} >",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let t_group;
  let current;
  const t_group_spread_levels = [
    /*$$restProps*/
    ctx[12]
  ];
  let t_group_props = {
    $$slots: {
      default: [
        create_default_slot6,
        ({ ref }) => ({ 41: ref }),
        ({ ref }) => [0, ref ? 1024 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_group_spread_levels.length; i += 1) {
    t_group_props = assign(t_group_props, t_group_spread_levels[i]);
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  ctx[28](t_group);
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = dirty[0] & /*$$restProps*/
      4096 ? get_spread_update(t_group_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[12]
      )]) : {};
      if (dirty[0] & /*$$scope, $planeGeometry*/
      536870913 | dirty[1] & /*ref*/
      1024) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[28](null);
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "smooth",
    "resolution",
    "frames",
    "scale",
    "color",
    "depthWrite",
    "refresh"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $depthMaterial;
  let $planeGeometry;
  let $renderTargetBlur;
  let $renderTarget;
  let $blurPlane;
  let $scaledHeight;
  let $scaledWidth;
  let $components;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContactShadows", slots, ["default"]);
  let { opacity = 1 } = $$props;
  let { width = 1 } = $$props;
  let { height = 1 } = $$props;
  let { blur = 1 } = $$props;
  let { far = 10 } = $$props;
  let { smooth = true } = $$props;
  let { resolution = 512 } = $$props;
  let { frames = Infinity } = $$props;
  let { scale = 10 } = $$props;
  let { color = "#000000" } = $$props;
  let { depthWrite = false } = $$props;
  const { scene, renderer } = useThrelte();
  const scaledWidth = useMemo(() => {
    return width * (Array.isArray(scale) ? scale[0] : scale || 1);
  });
  validate_store(scaledWidth, "scaledWidth");
  component_subscribe($$self, scaledWidth, (value) => $$invalidate(26, $scaledWidth = value));
  const scaledHeight = useMemo(() => {
    return height * (Array.isArray(scale) ? scale[1] : scale || 1);
  });
  validate_store(scaledHeight, "scaledHeight");
  component_subscribe($$self, scaledHeight, (value) => $$invalidate(25, $scaledHeight = value));
  const renderTarget = useMemo(() => {
    const rt = new WebGLRenderTarget(resolution, resolution);
    rt.texture.generateMipmaps = false;
    rt.texture.colorSpace = renderer.outputColorSpace;
    return rt;
  });
  validate_store(renderTarget, "renderTarget");
  component_subscribe($$self, renderTarget, (value) => $$invalidate(36, $renderTarget = value));
  const renderTargetBlur = useMemo(() => {
    const rt = new WebGLRenderTarget(resolution, resolution);
    rt.texture.generateMipmaps = false;
    return rt;
  });
  validate_store(renderTargetBlur, "renderTargetBlur");
  component_subscribe($$self, renderTargetBlur, (value) => $$invalidate(35, $renderTargetBlur = value));
  const planeGeometry = useMemo(() => {
    return new PlaneGeometry($scaledWidth, $scaledHeight).rotateX(Math.PI / 2);
  });
  validate_store(planeGeometry, "planeGeometry");
  component_subscribe($$self, planeGeometry, (value) => $$invalidate(0, $planeGeometry = value));
  const blurPlane = useMemo(() => {
    return new Mesh($planeGeometry);
  });
  validate_store(blurPlane, "blurPlane");
  component_subscribe($$self, blurPlane, (value) => $$invalidate(37, $blurPlane = value));
  const depthMaterial = useMemo(() => {
    const dm = new MeshDepthMaterial({ depthTest: false, depthWrite: false });
    dm.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        uColor: {
          value: new Color(color).convertSRGBToLinear()
        }
      };
      shader.fragmentShader = "uniform vec3 uColor;\n" + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );");
      shader.fragmentShader = shader.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    };
    return dm;
  });
  validate_store(depthMaterial, "depthMaterial");
  component_subscribe($$self, depthMaterial, (value) => $$invalidate(34, $depthMaterial = value));
  const horizontalBlurMaterial = new ShaderMaterial({
    ...HorizontalBlurShader,
    depthTest: false
  });
  const verticalBlurMaterial = new ShaderMaterial({ ...VerticalBlurShader, depthTest: false });
  const shadowCamera = new OrthographicCamera(-$scaledWidth / 2, $scaledWidth / 2, $scaledHeight / 2, -$scaledHeight / 2, 0, far);
  shadowCamera.updateProjectionMatrix();
  const shadowMaterial = new MeshBasicMaterial({
    map: $renderTarget.texture,
    transparent: true,
    opacity,
    depthWrite
  });
  const blurShadows = (blur2) => {
    const bp = $blurPlane;
    bp.visible = true;
    bp.material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = $renderTarget.texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    renderer.setRenderTarget($renderTargetBlur);
    renderer.render(bp, shadowCamera);
    bp.material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = $renderTargetBlur.texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    renderer.setRenderTarget($renderTarget);
    renderer.render(bp, shadowCamera);
    bp.visible = false;
  };
  const renderShadows = () => {
    const initialBackground = scene.background;
    scene.background = null;
    const initialOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = $depthMaterial;
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget($renderTarget);
    renderer.render(scene, shadowCamera);
    scene.overrideMaterial = initialOverrideMaterial;
    blurShadows(blur);
    if (smooth) blurShadows(blur * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    renderer.setClearAlpha(initialClearAlpha);
  };
  const refresh = () => {
    renderShadows();
  };
  let count = 0;
  useTask(() => {
    if (frames === Infinity || count < frames) {
      renderShadows();
      count += 1;
    }
  });
  onDestroy(() => {
    $renderTarget.dispose();
    $renderTargetBlur.dispose();
    $planeGeometry.dispose();
    $depthMaterial.dispose();
    horizontalBlurMaterial.dispose();
    verticalBlurMaterial.dispose();
    shadowMaterial.dispose();
  });
  const components = forwardEventHandlers();
  validate_store(components, "components");
  component_subscribe($$self, components, (value) => $$invalidate(1, $components = value));
  function t_group_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $components = $$value;
      components.set($components);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("opacity" in $$new_props) $$invalidate(13, opacity = $$new_props.opacity);
    if ("width" in $$new_props) $$invalidate(14, width = $$new_props.width);
    if ("height" in $$new_props) $$invalidate(15, height = $$new_props.height);
    if ("blur" in $$new_props) $$invalidate(16, blur = $$new_props.blur);
    if ("far" in $$new_props) $$invalidate(17, far = $$new_props.far);
    if ("smooth" in $$new_props) $$invalidate(18, smooth = $$new_props.smooth);
    if ("resolution" in $$new_props) $$invalidate(19, resolution = $$new_props.resolution);
    if ("frames" in $$new_props) $$invalidate(20, frames = $$new_props.frames);
    if ("scale" in $$new_props) $$invalidate(21, scale = $$new_props.scale);
    if ("color" in $$new_props) $$invalidate(22, color = $$new_props.color);
    if ("depthWrite" in $$new_props) $$invalidate(23, depthWrite = $$new_props.depthWrite);
    if ("$$scope" in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useTask,
    useThrelte,
    onDestroy,
    Color,
    Mesh,
    MeshBasicMaterial,
    MeshDepthMaterial,
    OrthographicCamera,
    PlaneGeometry,
    ShaderMaterial,
    WebGLRenderTarget,
    HorizontalBlurShader,
    VerticalBlurShader,
    useMemo,
    opacity,
    width,
    height,
    blur,
    far,
    smooth,
    resolution,
    frames,
    scale,
    color,
    depthWrite,
    scene,
    renderer,
    scaledWidth,
    scaledHeight,
    renderTarget,
    renderTargetBlur,
    planeGeometry,
    blurPlane,
    depthMaterial,
    horizontalBlurMaterial,
    verticalBlurMaterial,
    shadowCamera,
    shadowMaterial,
    blurShadows,
    renderShadows,
    refresh,
    count,
    components,
    $depthMaterial,
    $planeGeometry,
    $renderTargetBlur,
    $renderTarget,
    $blurPlane,
    $scaledHeight,
    $scaledWidth,
    $components
  });
  $$self.$inject_state = ($$new_props) => {
    if ("opacity" in $$props) $$invalidate(13, opacity = $$new_props.opacity);
    if ("width" in $$props) $$invalidate(14, width = $$new_props.width);
    if ("height" in $$props) $$invalidate(15, height = $$new_props.height);
    if ("blur" in $$props) $$invalidate(16, blur = $$new_props.blur);
    if ("far" in $$props) $$invalidate(17, far = $$new_props.far);
    if ("smooth" in $$props) $$invalidate(18, smooth = $$new_props.smooth);
    if ("resolution" in $$props) $$invalidate(19, resolution = $$new_props.resolution);
    if ("frames" in $$props) $$invalidate(20, frames = $$new_props.frames);
    if ("scale" in $$props) $$invalidate(21, scale = $$new_props.scale);
    if ("color" in $$props) $$invalidate(22, color = $$new_props.color);
    if ("depthWrite" in $$props) $$invalidate(23, depthWrite = $$new_props.depthWrite);
    if ("count" in $$props) count = $$new_props.count;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*width, scale*/
    2113536) {
      $: scaledWidth.memoize([width, scale]);
    }
    if ($$self.$$.dirty[0] & /*height, scale*/
    2129920) {
      $: scaledHeight.memoize(height, scale);
    }
    if ($$self.$$.dirty[0] & /*resolution*/
    524288) {
      $: renderTarget.memoize(resolution);
    }
    if ($$self.$$.dirty[0] & /*resolution*/
    524288) {
      $: renderTargetBlur.memoize(resolution);
    }
    if ($$self.$$.dirty[0] & /*$scaledWidth, $scaledHeight*/
    100663296) {
      $: planeGeometry.memoize($scaledWidth, $scaledHeight);
    }
    if ($$self.$$.dirty[0] & /*$planeGeometry*/
    1) {
      $: blurPlane.memoize($planeGeometry);
    }
    if ($$self.$$.dirty[0] & /*color*/
    4194304) {
      $: depthMaterial.memoize(color);
    }
  };
  return [
    $planeGeometry,
    $components,
    scaledWidth,
    scaledHeight,
    renderTarget,
    renderTargetBlur,
    planeGeometry,
    blurPlane,
    depthMaterial,
    shadowCamera,
    shadowMaterial,
    components,
    $$restProps,
    opacity,
    width,
    height,
    blur,
    far,
    smooth,
    resolution,
    frames,
    scale,
    color,
    depthWrite,
    refresh,
    $scaledHeight,
    $scaledWidth,
    slots,
    t_group_binding,
    $$scope
  ];
}
var ContactShadows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        opacity: 13,
        width: 14,
        height: 15,
        blur: 16,
        far: 17,
        smooth: 18,
        resolution: 19,
        frames: 20,
        scale: 21,
        color: 22,
        depthWrite: 23,
        refresh: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContactShadows",
      options,
      id: create_fragment7.name
    });
  }
  get opacity() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smooth() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smooth(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resolution() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resolution(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frames() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frames(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depthWrite() {
    throw new Error("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depthWrite(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[24];
  }
  set refresh(value) {
    throw new Error("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContactShadows_default = ContactShadows;

// node_modules/three/examples/jsm/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(buffer) {
    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
        case rgbe_write_error:
          throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
        case rgbe_format_error:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
        default:
        case rgbe_memory_error:
          throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
      }
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      }
      if (-1 < i) {
        if (false !== consume) buffer2.pos += len + i + 1;
        return s + chunk.slice(0, i);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let line, match;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line.match(magic_token_re))) {
        rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (false === line) break;
        header.string += line + "\n";
        if ("#" === line.charAt(0)) {
          header.comments += line + "\n";
          continue;
        }
        if (match = line.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
      const scanline_width = w2;
      if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
        (2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128)
      ) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w2 * h2);
      if (!data_rgba.length) {
        rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h2;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun) count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i = 0; i < count; i++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i = 0; i < l; i++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
    let data, type;
    let numElements;
    switch (this.type) {
      case FloatType:
        numElements = image_rgba_data.length / 4;
        const floatArray = new Float32Array(numElements * 4);
        for (let j = 0; j < numElements; j++) {
          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
        }
        data = floatArray;
        type = FloatType;
        break;
      case HalfFloatType:
        numElements = image_rgba_data.length / 4;
        const halfArray = new Uint16Array(numElements * 4);
        for (let j = 0; j < numElements; j++) {
          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
        }
        data = halfArray;
        type = HalfFloatType;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
        break;
    }
    return {
      width: w,
      height: h,
      data,
      header: rgbe_header_info.string,
      gamma: rgbe_header_info.gamma,
      exposure: rgbe_header_info.exposure,
      type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
        case HalfFloatType:
          texture.colorSpace = LinearSRGBColorSpace;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad) onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three/examples/jsm/loaders/HDRCubeTextureLoader.js
var HDRCubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.hdrLoader = new RGBELoader();
    this.type = HalfFloatType;
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    texture.type = this.type;
    switch (texture.type) {
      case FloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
      case HalfFloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
    }
    const scope = this;
    let loaded = 0;
    function loadHDRData(i, onLoad2, onProgress2, onError2) {
      new FileLoader(scope.manager).setPath(scope.path).setResponseType("arraybuffer").setWithCredentials(scope.withCredentials).load(urls[i], function(buffer) {
        loaded++;
        const texData = scope.hdrLoader.parse(buffer);
        if (!texData) return;
        if (texData.data !== void 0) {
          const dataTexture = new DataTexture(texData.data, texData.width, texData.height);
          dataTexture.type = texture.type;
          dataTexture.colorSpace = texture.colorSpace;
          dataTexture.format = texture.format;
          dataTexture.minFilter = texture.minFilter;
          dataTexture.magFilter = texture.magFilter;
          dataTexture.generateMipmaps = texture.generateMipmaps;
          texture.images[i] = dataTexture;
        }
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad2) onLoad2(texture);
        }
      }, onProgress2, onError2);
    }
    for (let i = 0; i < urls.length; i++) {
      loadHDRData(i, onLoad, onProgress, onError);
    }
    return texture;
  }
  setDataType(value) {
    this.type = value;
    this.hdrLoader.setDataType(value);
    return this;
  }
};

// node_modules/@threlte/extras/dist/lib/revision.js
var revision2 = Number.parseInt(REVISION.replace("dev", ""));

// node_modules/@threlte/extras/dist/components/Environment/GroundProjectedSkybox.svelte
function create_if_block4(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 4,
    blocks: [, , ,]
  };
  handle_promise(promise = /*module*/
  ctx[1], info);
  const block = {
    c: function create() {
      await_block_anchor = empty();
      info.block.c();
    },
    l: function claim(nodes) {
      await_block_anchor = empty();
      info.block.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(info.block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 3; i += 1) {
        const block2 = info.blocks[i];
        transition_out(block2);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(10:0) {#if envMap}",
    ctx
  });
  return block;
}
function create_catch_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: "(1:0) <script>import { T }",
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    {
      is: revision2 > 160 ? (
        /*result*/
        ctx[4].GroundedSkybox
      ) : (
        /*result*/
        ctx[4].GroundProjectedSkybox
      )
    },
    { args: [
      /*envMap*/
      ctx[0]
    ] },
    /*$$restProps*/
    ctx[2]
  ];
  let t_props = {};
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*module, envMap, $$restProps*/
      7 ? get_spread_update(t_spread_levels, [
        dirty & /*module*/
        2 && {
          is: revision2 > 160 ? (
            /*result*/
            ctx2[4].GroundedSkybox
          ) : (
            /*result*/
            ctx2[4].GroundProjectedSkybox
          )
        },
        dirty & /*envMap*/
        1 && { args: [
          /*envMap*/
          ctx2[0]
        ] },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(11:29)      <T       is={revision > 160 ? result.GroundedSkybox : result.GroundProjectedSkybox}",
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: "(1:0) <script>import { T }",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*envMap*/
    ctx[0] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*envMap*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*envMap*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["envMap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GroundProjectedSkybox", slots, []);
  let { envMap } = $$props;
  const url = revision2 > 160 ? "three/examples/jsm/objects/GroundedSkybox.js" : "three/examples/jsm/objects/GroundProjectedSkybox.js";
  const module = import(
    /* @vite-ignore */
    url
  );
  $$self.$$.on_mount.push(function() {
    if (envMap === void 0 && !("envMap" in $$props || $$self.$$.bound[$$self.$$.props["envMap"]])) {
      console.warn("<GroundProjectedSkybox> was created without expected prop 'envMap'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("envMap" in $$new_props) $$invalidate(0, envMap = $$new_props.envMap);
  };
  $$self.$capture_state = () => ({ T, revision: revision2, envMap, url, module });
  $$self.$inject_state = ($$new_props) => {
    if ("envMap" in $$props) $$invalidate(0, envMap = $$new_props.envMap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [envMap, module, $$restProps];
}
var GroundProjectedSkybox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { envMap: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GroundProjectedSkybox",
      options,
      id: create_fragment8.name
    });
  }
  get envMap() {
    throw new Error("<GroundProjectedSkybox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set envMap(value) {
    throw new Error("<GroundProjectedSkybox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GroundProjectedSkybox_default = GroundProjectedSkybox;

// node_modules/@threlte/extras/dist/components/Environment/Environment.svelte
function create_if_block5(ctx) {
  let groundprojectedskybox;
  let current;
  const groundprojectedskybox_spread_levels = [
    /*groundProjection*/
    ctx[0],
    { envMap: (
      /*previousEnvMap*/
      ctx[1]
    ) }
  ];
  let groundprojectedskybox_props = {};
  for (let i = 0; i < groundprojectedskybox_spread_levels.length; i += 1) {
    groundprojectedskybox_props = assign(groundprojectedskybox_props, groundprojectedskybox_spread_levels[i]);
  }
  groundprojectedskybox = new GroundProjectedSkybox_default({
    props: groundprojectedskybox_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(groundprojectedskybox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(groundprojectedskybox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(groundprojectedskybox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const groundprojectedskybox_changes = dirty & /*groundProjection, previousEnvMap*/
      3 ? get_spread_update(groundprojectedskybox_spread_levels, [
        dirty & /*groundProjection*/
        1 && get_spread_object(
          /*groundProjection*/
          ctx2[0]
        ),
        dirty & /*previousEnvMap*/
        2 && { envMap: (
          /*previousEnvMap*/
          ctx2[1]
        ) }
      ]) : {};
      groundprojectedskybox.$set(groundprojectedskybox_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(groundprojectedskybox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(groundprojectedskybox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(groundprojectedskybox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(91:0) {#if groundProjection}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*groundProjection*/
    ctx[0] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*groundProjection*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*groundProjection*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let isCubeMap;
  let envPath;
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Environment", slots, []);
  let { path = "" } = $$props;
  let { files } = $$props;
  let { isBackground = void 0 } = $$props;
  let { groundProjection = void 0 } = $$props;
  let { format = void 0 } = $$props;
  let { colorSpace = void 0 } = $$props;
  const isScene = (obj) => !!obj.isScene;
  const { scene: globalScene, invalidate } = useThrelte();
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(13, $parent = value));
  let scene = globalScene;
  if (isScene($parent)) scene = $parent;
  let previousSceneEnvironment = scene.environment;
  let previousSceneBackground = scene.background;
  let previousEnvPath = envPath;
  let previousEnvMap;
  let previousFormat;
  const pickLoader = () => {
    const inferredFormat = format || (Array.isArray(files) ? files[0] : files).split(".").pop() == "hdr" ? "hdr" : "ldr";
    if (isCubeMap && inferredFormat == "ldr") return CubeTextureLoader;
    if (!isCubeMap && inferredFormat == "ldr") return TextureLoader;
    if (isCubeMap && inferredFormat == "hdr") return HDRCubeTextureLoader;
    if (!isCubeMap && inferredFormat == "hdr") return RGBELoader;
    return TextureLoader;
  };
  const { remember } = useCache();
  const suspend = useSuspense();
  const loadEnvironment = async () => {
    var _a;
    const LoaderType = pickLoader();
    const loader = new LoaderType();
    (_a = loader.setDataType) == null ? void 0 : _a.call(loader, FloatType);
    const filesKey = Array.isArray(files) ? files.join(",") : files;
    const cacheKey = [LoaderType, path, filesKey];
    const texture = await remember(
      async () => {
        return suspend(new Promise((resolve, reject) => {
          loader.setPath(path).load(files, (texture2) => {
            resolve(texture2);
          });
        }));
      },
      cacheKey
    );
    texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;
    texture.colorSpace = colorSpace ?? isCubeMap ? LinearSRGBColorSpace : SRGBColorSpace;
    $$invalidate(1, previousEnvMap = texture);
    $$invalidate(8, scene.environment = previousEnvMap, scene);
    if (isBackground) $$invalidate(8, scene.background = previousEnvMap, scene);
    invalidate();
    $$invalidate(10, previousFormat = format || void 0);
    $$invalidate(9, previousEnvPath = envPath);
  };
  onDestroy(() => {
    $$invalidate(8, scene.environment = previousSceneEnvironment, scene);
    $$invalidate(8, scene.background = previousSceneBackground, scene);
    if (previousEnvMap) previousEnvMap.dispose();
    $$invalidate(0, groundProjection = void 0);
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<Environment> was created without expected prop 'files'");
    }
  });
  const writable_props = ["path", "files", "isBackground", "groundProjection", "format", "colorSpace"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Environment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2) $$invalidate(3, path = $$props2.path);
    if ("files" in $$props2) $$invalidate(4, files = $$props2.files);
    if ("isBackground" in $$props2) $$invalidate(5, isBackground = $$props2.isBackground);
    if ("groundProjection" in $$props2) $$invalidate(0, groundProjection = $$props2.groundProjection);
    if ("format" in $$props2) $$invalidate(6, format = $$props2.format);
    if ("colorSpace" in $$props2) $$invalidate(7, colorSpace = $$props2.colorSpace);
  };
  $$self.$capture_state = () => ({
    useCache,
    useParent,
    useThrelte,
    onDestroy,
    CubeReflectionMapping,
    CubeTextureLoader,
    EquirectangularReflectionMapping,
    FloatType,
    Texture,
    TextureLoader,
    SRGBColorSpace,
    LinearSRGBColorSpace,
    HDRCubeTextureLoader,
    RGBELoader,
    GroundProjectedSkybox: GroundProjectedSkybox_default,
    useSuspense,
    path,
    files,
    isBackground,
    groundProjection,
    format,
    colorSpace,
    isScene,
    globalScene,
    invalidate,
    parent,
    scene,
    previousSceneEnvironment,
    previousSceneBackground,
    previousEnvPath,
    previousEnvMap,
    previousFormat,
    pickLoader,
    remember,
    suspend,
    loadEnvironment,
    envPath,
    isCubeMap,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2) $$invalidate(3, path = $$props2.path);
    if ("files" in $$props2) $$invalidate(4, files = $$props2.files);
    if ("isBackground" in $$props2) $$invalidate(5, isBackground = $$props2.isBackground);
    if ("groundProjection" in $$props2) $$invalidate(0, groundProjection = $$props2.groundProjection);
    if ("format" in $$props2) $$invalidate(6, format = $$props2.format);
    if ("colorSpace" in $$props2) $$invalidate(7, colorSpace = $$props2.colorSpace);
    if ("scene" in $$props2) $$invalidate(8, scene = $$props2.scene);
    if ("previousSceneEnvironment" in $$props2) previousSceneEnvironment = $$props2.previousSceneEnvironment;
    if ("previousSceneBackground" in $$props2) previousSceneBackground = $$props2.previousSceneBackground;
    if ("previousEnvPath" in $$props2) $$invalidate(9, previousEnvPath = $$props2.previousEnvPath);
    if ("previousEnvMap" in $$props2) $$invalidate(1, previousEnvMap = $$props2.previousEnvMap);
    if ("previousFormat" in $$props2) $$invalidate(10, previousFormat = $$props2.previousFormat);
    if ("envPath" in $$props2) $$invalidate(11, envPath = $$props2.envPath);
    if ("isCubeMap" in $$props2) isCubeMap = $$props2.isCubeMap;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*files*/
    16) {
      $: isCubeMap = Array.isArray(files);
    }
    if ($$self.$$.dirty & /*path, files*/
    24) {
      $: $$invalidate(11, envPath = `${path}${files}`);
    }
    if ($$self.$$.dirty & /*envPath, previousEnvPath, format, previousFormat, previousEnvMap, groundProjection, isBackground, scene*/
    3939) {
      $: {
        if (envPath != previousEnvPath || format != previousFormat) {
          if (previousEnvMap) {
            previousEnvMap.dispose();
          }
          loadEnvironment();
          $$invalidate(0, groundProjection), $$invalidate(11, envPath), $$invalidate(9, previousEnvPath), $$invalidate(6, format), $$invalidate(10, previousFormat), $$invalidate(1, previousEnvMap), $$invalidate(5, isBackground), $$invalidate(8, scene), $$invalidate(3, path), $$invalidate(4, files);
        }
        if (!isBackground && scene.background) {
          $$invalidate(8, scene.background = null, scene);
          invalidate();
        }
        if (isBackground && !scene.background && previousEnvMap) {
          $$invalidate(8, scene.background = previousEnvMap, scene);
          invalidate();
        }
      }
    }
  };
  return [
    groundProjection,
    previousEnvMap,
    parent,
    path,
    files,
    isBackground,
    format,
    colorSpace,
    scene,
    previousEnvPath,
    previousFormat,
    envPath
  ];
}
var Environment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      path: 3,
      files: 4,
      isBackground: 5,
      groundProjection: 0,
      format: 6,
      colorSpace: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Environment",
      options,
      id: create_fragment9.name
    });
  }
  get path() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isBackground() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isBackground(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groundProjection() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groundProjection(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorSpace() {
    throw new Error("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorSpace(value) {
    throw new Error("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Environment_default = Environment;

// node_modules/@threlte/extras/dist/components/ImageMaterial/shaders.js
var vertexShader = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
);
var fragmentShader = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
);

// node_modules/@threlte/extras/dist/components/ImageMaterial/ImageMaterial.svelte
var get_default_slot_changes5 = (dirty) => ({ ref: dirty[0] & /*ref*/
8 });
var get_default_slot_context5 = (ctx) => ({ ref: (
  /*ref*/
  ctx[3]
) });
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*ref*/
        8 | dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(111:0) <T   is={ref}   {uniforms}   {toneMapped}   {transparent}   {side}   {vertexShader}   {fragmentShader}   {...$$restProps}   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[3]
    ) },
    { uniforms: (
      /*uniforms*/
      ctx[4]
    ) },
    { toneMapped: (
      /*toneMapped*/
      ctx[0]
    ) },
    { transparent: (
      /*transparent*/
      ctx[1]
    ) },
    { side: (
      /*side*/
      ctx[2]
    ) },
    { vertexShader },
    { fragmentShader },
    /*$$restProps*/
    ctx[10]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[31](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty[0] & /*ref, uniforms, toneMapped, transparent, side, $$restProps*/
      1055 ? get_spread_update(t_spread_levels, [
        dirty[0] & /*ref*/
        8 && { is: (
          /*ref*/
          ctx2[3]
        ) },
        dirty[0] & /*uniforms*/
        16 && { uniforms: (
          /*uniforms*/
          ctx2[4]
        ) },
        dirty[0] & /*toneMapped*/
        1 && { toneMapped: (
          /*toneMapped*/
          ctx2[0]
        ) },
        dirty[0] & /*transparent*/
        2 && { transparent: (
          /*transparent*/
          ctx2[1]
        ) },
        dirty[0] & /*side*/
        4 && { side: (
          /*side*/
          ctx2[2]
        ) },
        t_spread_levels[5],
        t_spread_levels[6],
        dirty[0] & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        )
      ]) : {};
      if (dirty[0] & /*ref*/
      8 | dirty[1] & /*$$scope*/
      2) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[31](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let textureStore;
  const omit_props_names = [
    "color",
    "zoom",
    "radius",
    "alphaThreshold",
    "alphaSmoothing",
    "brightness",
    "contrast",
    "hue",
    "saturation",
    "lightness",
    "negative",
    "opacity",
    "toneMapped",
    "transparent",
    "texture",
    "monochromeColor",
    "monochromeStrength",
    "colorProcessingTexture",
    "side",
    "url",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $textureStore, $$unsubscribe_textureStore = noop, $$subscribe_textureStore = () => ($$unsubscribe_textureStore(), $$unsubscribe_textureStore = subscribe(textureStore, ($$value) => $$invalidate(28, $textureStore = $$value)), textureStore);
  let $size;
  let $component;
  $$self.$$.on_destroy.push(() => $$unsubscribe_textureStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageMaterial", slots, ["default"]);
  let { color = "white" } = $$props;
  let { zoom = 1 } = $$props;
  let { radius = 0 } = $$props;
  let { alphaThreshold = 0 } = $$props;
  let { alphaSmoothing = 0.1 } = $$props;
  let { brightness = 0 } = $$props;
  let { contrast = 0 } = $$props;
  let { hue = 0 } = $$props;
  let { saturation = 0 } = $$props;
  let { lightness = 0 } = $$props;
  let { negative = false } = $$props;
  let { opacity = 1 } = $$props;
  let { toneMapped = true } = $$props;
  let { transparent = false } = $$props;
  let { texture = void 0 } = $$props;
  let { monochromeColor = void 0 } = $$props;
  let { monochromeStrength = void 0 } = $$props;
  let { colorProcessingTexture = void 0 } = $$props;
  let { side = void 0 } = $$props;
  let { url = void 0 } = $$props;
  let { ref = new ShaderMaterial() } = $$props;
  const suspend = useSuspense();
  let { size } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(29, $size = value));
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(33, $parent = value));
  const uniforms = {
    color: { value: new Color(color) },
    scale: { value: new Vector2() },
    imageBounds: { value: new Vector2(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: zoom },
    radius: { value: radius },
    alphaThreshold: { value: alphaThreshold },
    alphaSmoothing: { value: alphaSmoothing },
    brightness: { value: brightness },
    contrast: { value: contrast },
    monochromeColor: { value: new Color(monochromeColor) },
    monochromeStrength: { value: monochromeStrength ?? 0 },
    negative: { value: negative ? 1 : 0 },
    opacity: { value: opacity },
    hsl: { value: new Vector3(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  useTask(() => {
    const mesh = $parent;
    if (mesh === void 0) {
      return;
    }
    uniforms.scale.value.set(mesh.scale.x, mesh.scale.y);
    const geometry = mesh.geometry;
    if (geometry !== void 0 && "parameters" in geometry) {
      const { width, height } = geometry.parameters;
      uniforms.scale.value.set(uniforms.scale.value.x * width, uniforms.scale.value.y * height);
    }
  });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(6, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props) $$invalidate(11, color = $$new_props.color);
    if ("zoom" in $$new_props) $$invalidate(12, zoom = $$new_props.zoom);
    if ("radius" in $$new_props) $$invalidate(13, radius = $$new_props.radius);
    if ("alphaThreshold" in $$new_props) $$invalidate(14, alphaThreshold = $$new_props.alphaThreshold);
    if ("alphaSmoothing" in $$new_props) $$invalidate(15, alphaSmoothing = $$new_props.alphaSmoothing);
    if ("brightness" in $$new_props) $$invalidate(16, brightness = $$new_props.brightness);
    if ("contrast" in $$new_props) $$invalidate(17, contrast = $$new_props.contrast);
    if ("hue" in $$new_props) $$invalidate(18, hue = $$new_props.hue);
    if ("saturation" in $$new_props) $$invalidate(19, saturation = $$new_props.saturation);
    if ("lightness" in $$new_props) $$invalidate(20, lightness = $$new_props.lightness);
    if ("negative" in $$new_props) $$invalidate(21, negative = $$new_props.negative);
    if ("opacity" in $$new_props) $$invalidate(22, opacity = $$new_props.opacity);
    if ("toneMapped" in $$new_props) $$invalidate(0, toneMapped = $$new_props.toneMapped);
    if ("transparent" in $$new_props) $$invalidate(1, transparent = $$new_props.transparent);
    if ("texture" in $$new_props) $$invalidate(23, texture = $$new_props.texture);
    if ("monochromeColor" in $$new_props) $$invalidate(24, monochromeColor = $$new_props.monochromeColor);
    if ("monochromeStrength" in $$new_props) $$invalidate(25, monochromeStrength = $$new_props.monochromeStrength);
    if ("colorProcessingTexture" in $$new_props) $$invalidate(26, colorProcessingTexture = $$new_props.colorProcessingTexture);
    if ("side" in $$new_props) $$invalidate(2, side = $$new_props.side);
    if ("url" in $$new_props) $$invalidate(27, url = $$new_props.url);
    if ("ref" in $$new_props) $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(32, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Color,
    Vector2,
    Vector3,
    ShaderMaterial,
    T,
    asyncWritable,
    forwardEventHandlers,
    useParent,
    useTask,
    useThrelte,
    useTexture,
    useSuspense,
    vertexShader,
    fragmentShader,
    color,
    zoom,
    radius,
    alphaThreshold,
    alphaSmoothing,
    brightness,
    contrast,
    hue,
    saturation,
    lightness,
    negative,
    opacity,
    toneMapped,
    transparent,
    texture,
    monochromeColor,
    monochromeStrength,
    colorProcessingTexture,
    side,
    url,
    ref,
    suspend,
    size,
    parent,
    uniforms,
    component,
    textureStore,
    $parent,
    $textureStore,
    $size,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props) $$invalidate(11, color = $$new_props.color);
    if ("zoom" in $$props) $$invalidate(12, zoom = $$new_props.zoom);
    if ("radius" in $$props) $$invalidate(13, radius = $$new_props.radius);
    if ("alphaThreshold" in $$props) $$invalidate(14, alphaThreshold = $$new_props.alphaThreshold);
    if ("alphaSmoothing" in $$props) $$invalidate(15, alphaSmoothing = $$new_props.alphaSmoothing);
    if ("brightness" in $$props) $$invalidate(16, brightness = $$new_props.brightness);
    if ("contrast" in $$props) $$invalidate(17, contrast = $$new_props.contrast);
    if ("hue" in $$props) $$invalidate(18, hue = $$new_props.hue);
    if ("saturation" in $$props) $$invalidate(19, saturation = $$new_props.saturation);
    if ("lightness" in $$props) $$invalidate(20, lightness = $$new_props.lightness);
    if ("negative" in $$props) $$invalidate(21, negative = $$new_props.negative);
    if ("opacity" in $$props) $$invalidate(22, opacity = $$new_props.opacity);
    if ("toneMapped" in $$props) $$invalidate(0, toneMapped = $$new_props.toneMapped);
    if ("transparent" in $$props) $$invalidate(1, transparent = $$new_props.transparent);
    if ("texture" in $$props) $$invalidate(23, texture = $$new_props.texture);
    if ("monochromeColor" in $$props) $$invalidate(24, monochromeColor = $$new_props.monochromeColor);
    if ("monochromeStrength" in $$props) $$invalidate(25, monochromeStrength = $$new_props.monochromeStrength);
    if ("colorProcessingTexture" in $$props) $$invalidate(26, colorProcessingTexture = $$new_props.colorProcessingTexture);
    if ("side" in $$props) $$invalidate(2, side = $$new_props.side);
    if ("url" in $$props) $$invalidate(27, url = $$new_props.url);
    if ("ref" in $$props) $$invalidate(3, ref = $$new_props.ref);
    if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
    if ("textureStore" in $$props) $$subscribe_textureStore($$invalidate(5, textureStore = $$new_props.textureStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*url, texture*/
    142606336) {
      $: $$subscribe_textureStore($$invalidate(5, textureStore = suspend(url ? useTexture(url) : asyncWritable(Promise.resolve(texture)))));
    }
    if ($$self.$$.dirty[0] & /*$size*/
    536870912) {
      $: $$invalidate(4, uniforms.resolution.value = Math.max($size.width, $size.height), uniforms);
    }
    if ($$self.$$.dirty[0] & /*zoom*/
    4096) {
      $: $$invalidate(4, uniforms.zoom.value = zoom, uniforms);
    }
    if ($$self.$$.dirty[0] & /*radius*/
    8192) {
      $: $$invalidate(4, uniforms.radius.value = radius, uniforms);
    }
    if ($$self.$$.dirty[0] & /*opacity*/
    4194304) {
      $: $$invalidate(4, uniforms.opacity.value = opacity, uniforms);
    }
    if ($$self.$$.dirty[0] & /*alphaThreshold*/
    16384) {
      $: $$invalidate(4, uniforms.alphaThreshold.value = alphaThreshold, uniforms);
    }
    if ($$self.$$.dirty[0] & /*alphaSmoothing*/
    32768) {
      $: $$invalidate(4, uniforms.alphaSmoothing.value = alphaSmoothing, uniforms);
    }
    if ($$self.$$.dirty[0] & /*brightness*/
    65536) {
      $: $$invalidate(4, uniforms.brightness.value = brightness, uniforms);
    }
    if ($$self.$$.dirty[0] & /*contrast*/
    131072) {
      $: $$invalidate(4, uniforms.contrast.value = contrast, uniforms);
    }
    if ($$self.$$.dirty[0] & /*hue*/
    262144) {
      $: $$invalidate(4, uniforms.hsl.value.x = hue, uniforms);
    }
    if ($$self.$$.dirty[0] & /*saturation*/
    524288) {
      $: $$invalidate(4, uniforms.hsl.value.y = saturation, uniforms);
    }
    if ($$self.$$.dirty[0] & /*lightness*/
    1048576) {
      $: $$invalidate(4, uniforms.hsl.value.z = lightness, uniforms);
    }
    if ($$self.$$.dirty[0] & /*negative*/
    2097152) {
      $: $$invalidate(4, uniforms.negative.value = negative ? 1 : 0, uniforms);
    }
    if ($$self.$$.dirty[0] & /*$textureStore*/
    268435456) {
      $: $$invalidate(4, uniforms.map.value = $textureStore ?? null, uniforms);
    }
    if ($$self.$$.dirty[0] & /*colorProcessingTexture*/
    67108864) {
      $: $$invalidate(4, uniforms.colorProccessingTexture.value = colorProcessingTexture ?? null, uniforms);
    }
    if ($$self.$$.dirty[0] & /*colorProcessingTexture*/
    67108864) {
      $: $$invalidate(4, uniforms.colorProcessingTextureOverride.value = colorProcessingTexture ? 1 : 0, uniforms);
    }
    if ($$self.$$.dirty[0] & /*monochromeColor, uniforms, monochromeStrength*/
    50331664) {
      $: if (monochromeColor !== void 0) {
        uniforms.monochromeColor.value.set(monochromeColor);
        $$invalidate(4, uniforms.monochromeStrength.value = monochromeStrength ?? 1, uniforms);
      } else {
        $$invalidate(4, uniforms.monochromeStrength.value = 0, uniforms);
      }
    }
    if ($$self.$$.dirty[0] & /*monochromeColor, monochromeStrength, brightness, contrast, hue, saturation, lightness, colorProcessingTexture*/
    119472128) {
      $: {
        let colorProcessingEnabled = 0;
        const monochromeCheck = (monochromeColor ? 1 : 0) * (monochromeStrength === void 0 ? 1 : monochromeStrength);
        for (const value of [
          brightness,
          contrast,
          hue,
          saturation,
          lightness,
          monochromeCheck,
          colorProcessingTexture ? 1 : 0
        ]) {
          if (value !== 0) {
            colorProcessingEnabled = 1;
            break;
          }
        }
        $$invalidate(4, uniforms.colorProcessingEnabled.value = colorProcessingEnabled, uniforms);
      }
    }
    if ($$self.$$.dirty[0] & /*uniforms, color*/
    2064) {
      $: uniforms.color.value.set(color);
    }
    if ($$self.$$.dirty[0] & /*uniforms, $textureStore*/
    268435472) {
      $: uniforms.imageBounds.value.set(($textureStore == null ? void 0 : $textureStore.image.width) ?? 0, ($textureStore == null ? void 0 : $textureStore.image.height) ?? 0);
    }
  };
  return [
    toneMapped,
    transparent,
    side,
    ref,
    uniforms,
    textureStore,
    $component,
    size,
    parent,
    component,
    $$restProps,
    color,
    zoom,
    radius,
    alphaThreshold,
    alphaSmoothing,
    brightness,
    contrast,
    hue,
    saturation,
    lightness,
    negative,
    opacity,
    texture,
    monochromeColor,
    monochromeStrength,
    colorProcessingTexture,
    url,
    $textureStore,
    $size,
    slots,
    t_binding,
    $$scope
  ];
}
var ImageMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        color: 11,
        zoom: 12,
        radius: 13,
        alphaThreshold: 14,
        alphaSmoothing: 15,
        brightness: 16,
        contrast: 17,
        hue: 18,
        saturation: 19,
        lightness: 20,
        negative: 21,
        opacity: 22,
        toneMapped: 0,
        transparent: 1,
        texture: 23,
        monochromeColor: 24,
        monochromeStrength: 25,
        colorProcessingTexture: 26,
        side: 2,
        url: 27,
        ref: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageMaterial",
      options,
      id: create_fragment10.name
    });
  }
  get color() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoom() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alphaThreshold() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alphaThreshold(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alphaSmoothing() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alphaSmoothing(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get brightness() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set brightness(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contrast() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contrast(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hue() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hue(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get saturation() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set saturation(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightness() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightness(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get negative() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set negative(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toneMapped() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toneMapped(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get texture() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get monochromeColor() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set monochromeColor(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get monochromeStrength() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set monochromeStrength(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorProcessingTexture() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorProcessingTexture(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ImageMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ImageMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageMaterial_default = ImageMaterial;

// node_modules/@threlte/extras/dist/components/Grid/gridShaders.js
var vertexShader2 = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
);
var fragmentShader2 = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>
	}
`
);

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
var get_default_slot_changes6 = (dirty) => ({ ref: dirty[0] & /*ref*/
1 });
var get_default_slot_context6 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function fallback_block(ctx) {
  let t_planegeometry;
  let current;
  t_planegeometry = new T.PlaneGeometry({
    props: {
      args: typeof /*gridSize*/
      ctx[1] == "number" ? [
        /*gridSize*/
        ctx[1],
        /*gridSize*/
        ctx[1]
      ] : (
        /*gridSize*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_planegeometry.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_planegeometry.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_planegeometry, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_planegeometry_changes = {};
      if (dirty[0] & /*gridSize*/
      2) t_planegeometry_changes.args = typeof /*gridSize*/
      ctx2[1] == "number" ? [
        /*gridSize*/
        ctx2[1],
        /*gridSize*/
        ctx2[1]
      ] : (
        /*gridSize*/
        ctx2[1]
      );
      t_planegeometry.$set(t_planegeometry_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_planegeometry.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_planegeometry.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_planegeometry, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(189:14)      ",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let t_shadermaterial;
  let t2;
  let current;
  t_shadermaterial = new T.ShaderMaterial({
    props: {
      fragmentShader: fragmentShader2,
      vertexShader: vertexShader2,
      uniforms: (
        /*uniforms*/
        ctx[3]
      ),
      transparent: true,
      side: (
        /*side*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context6
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      create_component(t_shadermaterial.$$.fragment);
      t2 = space();
      if (default_slot_or_fallback) default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      claim_component(t_shadermaterial.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_shadermaterial, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_shadermaterial_changes = {};
      if (dirty[0] & /*uniforms*/
      8) t_shadermaterial_changes.uniforms = /*uniforms*/
      ctx2[3];
      if (dirty[0] & /*side*/
      4) t_shadermaterial_changes.side = /*side*/
      ctx2[2];
      t_shadermaterial.$set(t_shadermaterial_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, ref*/
        268435457)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*gridSize*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_shadermaterial.$$.fragment, local);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_shadermaterial.$$.fragment, local);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(t_shadermaterial, detaching);
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(175:0) <T.Mesh   bind:this={$component}   bind:ref   frustumCulled={false}   {...$$restProps}   let:ref >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let t_mesh;
  let updating_ref;
  let current;
  const t_mesh_spread_levels = [
    { frustumCulled: false },
    /*$$restProps*/
    ctx[6]
  ];
  function t_mesh_ref_binding(value) {
    ctx[27](value);
  }
  let t_mesh_props = {
    $$slots: {
      default: [create_default_slot8, ({ ref }) => ({ 0: ref }), ({ ref }) => [ref ? 1 : 0]]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_mesh_spread_levels.length; i += 1) {
    t_mesh_props = assign(t_mesh_props, t_mesh_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    t_mesh_props.ref = /*ref*/
    ctx[0];
  }
  t_mesh = new T.Mesh({ props: t_mesh_props, $$inline: true });
  ctx[26](t_mesh);
  binding_callbacks.push(() => bind(t_mesh, "ref", t_mesh_ref_binding));
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_mesh_changes = dirty[0] & /*$$restProps*/
      64 ? get_spread_update(t_mesh_spread_levels, [t_mesh_spread_levels[0], get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty[0] & /*$$scope, gridSize, ref, uniforms, side*/
      268435471) {
        t_mesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty[0] & /*ref*/
      1) {
        updating_ref = true;
        t_mesh_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t_mesh.$set(t_mesh_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_mesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[26](null);
      destroy_component(t_mesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "cellColor",
    "sectionColor",
    "cellSize",
    "backgroundColor",
    "backgroundOpacity",
    "sectionSize",
    "plane",
    "gridSize",
    "followCamera",
    "infiniteGrid",
    "fadeDistance",
    "fadeStrength",
    "cellThickness",
    "sectionThickness",
    "side",
    "type",
    "axis",
    "maxRadius",
    "cellDividers",
    "sectionDividers",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { cellColor = "#000000" } = $$props;
  let { sectionColor = "#0000ee" } = $$props;
  let { cellSize = 1 } = $$props;
  let { backgroundColor = "#dadada" } = $$props;
  let { backgroundOpacity = 0 } = $$props;
  let { sectionSize = 10 } = $$props;
  let { plane = "xz" } = $$props;
  let { gridSize = [20, 20] } = $$props;
  let { followCamera = false } = $$props;
  let { infiniteGrid = false } = $$props;
  let { fadeDistance = 100 } = $$props;
  let { fadeStrength = 1 } = $$props;
  let { cellThickness = 1 } = $$props;
  let { sectionThickness = 2 } = $$props;
  let { side = DoubleSide } = $$props;
  let { type = "grid" } = $$props;
  let { axis = "x" } = $$props;
  let { maxRadius = 0 } = $$props;
  let { cellDividers = 6 } = $$props;
  let { sectionDividers = 2 } = $$props;
  let { ref } = $$props;
  const { invalidate, camera } = useThrelte();
  const gridPlane = new Plane();
  const upVector = new Vector3(0, 1, 0);
  const zeroVector = new Vector3(0, 0, 0);
  const axisToInt = { x: 0, y: 1, z: 2 };
  const planeToAxes = { xz: "xzy", xy: "xyz", zy: "zyx" };
  const gridType = { grid: 0, lines: 1, circular: 2, polar: 3 };
  const uniforms = {
    cellSize: { value: cellSize },
    sectionSize: { value: sectionSize },
    cellColor: { value: new Color(cellColor) },
    sectionColor: { value: new Color(sectionColor) },
    backgroundColor: { value: new Color(backgroundColor) },
    backgroundOpacity: { value: backgroundOpacity },
    fadeDistance: { value: fadeDistance },
    fadeStrength: { value: fadeStrength },
    cellThickness: { value: cellThickness },
    sectionThickness: { value: sectionThickness },
    infiniteGrid: { value: infiniteGrid },
    followCamera: { value: followCamera },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: gridType.grid },
    lineGridCoord: { value: axisToInt[axis] },
    circleGridMaxRadius: { value: maxRadius },
    polarCellDividers: { value: cellDividers },
    polarSectionDividers: { value: sectionDividers },
    worldCamProjPosition: { value: new Vector3() },
    worldPlanePosition: { value: new Vector3() }
  };
  useTask(() => {
    gridPlane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(ref.matrixWorld);
    const material = ref.material;
    const worldCamProjPosition = material.uniforms.worldCamProjPosition;
    const worldPlanePosition = material.uniforms.worldPlanePosition;
    gridPlane.projectPoint(camera.current.position, worldCamProjPosition.value);
    worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref.matrixWorld);
    invalidate();
  });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(4, $component = value));
  $$self.$$.on_mount.push(function() {
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<Grid> was created without expected prop 'ref'");
    }
  });
  function t_mesh_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  function t_mesh_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("cellColor" in $$new_props) $$invalidate(7, cellColor = $$new_props.cellColor);
    if ("sectionColor" in $$new_props) $$invalidate(8, sectionColor = $$new_props.sectionColor);
    if ("cellSize" in $$new_props) $$invalidate(9, cellSize = $$new_props.cellSize);
    if ("backgroundColor" in $$new_props) $$invalidate(10, backgroundColor = $$new_props.backgroundColor);
    if ("backgroundOpacity" in $$new_props) $$invalidate(11, backgroundOpacity = $$new_props.backgroundOpacity);
    if ("sectionSize" in $$new_props) $$invalidate(12, sectionSize = $$new_props.sectionSize);
    if ("plane" in $$new_props) $$invalidate(13, plane = $$new_props.plane);
    if ("gridSize" in $$new_props) $$invalidate(1, gridSize = $$new_props.gridSize);
    if ("followCamera" in $$new_props) $$invalidate(14, followCamera = $$new_props.followCamera);
    if ("infiniteGrid" in $$new_props) $$invalidate(15, infiniteGrid = $$new_props.infiniteGrid);
    if ("fadeDistance" in $$new_props) $$invalidate(16, fadeDistance = $$new_props.fadeDistance);
    if ("fadeStrength" in $$new_props) $$invalidate(17, fadeStrength = $$new_props.fadeStrength);
    if ("cellThickness" in $$new_props) $$invalidate(18, cellThickness = $$new_props.cellThickness);
    if ("sectionThickness" in $$new_props) $$invalidate(19, sectionThickness = $$new_props.sectionThickness);
    if ("side" in $$new_props) $$invalidate(2, side = $$new_props.side);
    if ("type" in $$new_props) $$invalidate(20, type = $$new_props.type);
    if ("axis" in $$new_props) $$invalidate(21, axis = $$new_props.axis);
    if ("maxRadius" in $$new_props) $$invalidate(22, maxRadius = $$new_props.maxRadius);
    if ("cellDividers" in $$new_props) $$invalidate(23, cellDividers = $$new_props.cellDividers);
    if ("sectionDividers" in $$new_props) $$invalidate(24, sectionDividers = $$new_props.sectionDividers);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    forwardEventHandlers,
    useTask,
    useThrelte,
    Color,
    DoubleSide,
    Plane,
    Vector3,
    fragmentShader: fragmentShader2,
    vertexShader: vertexShader2,
    cellColor,
    sectionColor,
    cellSize,
    backgroundColor,
    backgroundOpacity,
    sectionSize,
    plane,
    gridSize,
    followCamera,
    infiniteGrid,
    fadeDistance,
    fadeStrength,
    cellThickness,
    sectionThickness,
    side,
    type,
    axis,
    maxRadius,
    cellDividers,
    sectionDividers,
    ref,
    invalidate,
    camera,
    gridPlane,
    upVector,
    zeroVector,
    axisToInt,
    planeToAxes,
    gridType,
    uniforms,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("cellColor" in $$props) $$invalidate(7, cellColor = $$new_props.cellColor);
    if ("sectionColor" in $$props) $$invalidate(8, sectionColor = $$new_props.sectionColor);
    if ("cellSize" in $$props) $$invalidate(9, cellSize = $$new_props.cellSize);
    if ("backgroundColor" in $$props) $$invalidate(10, backgroundColor = $$new_props.backgroundColor);
    if ("backgroundOpacity" in $$props) $$invalidate(11, backgroundOpacity = $$new_props.backgroundOpacity);
    if ("sectionSize" in $$props) $$invalidate(12, sectionSize = $$new_props.sectionSize);
    if ("plane" in $$props) $$invalidate(13, plane = $$new_props.plane);
    if ("gridSize" in $$props) $$invalidate(1, gridSize = $$new_props.gridSize);
    if ("followCamera" in $$props) $$invalidate(14, followCamera = $$new_props.followCamera);
    if ("infiniteGrid" in $$props) $$invalidate(15, infiniteGrid = $$new_props.infiniteGrid);
    if ("fadeDistance" in $$props) $$invalidate(16, fadeDistance = $$new_props.fadeDistance);
    if ("fadeStrength" in $$props) $$invalidate(17, fadeStrength = $$new_props.fadeStrength);
    if ("cellThickness" in $$props) $$invalidate(18, cellThickness = $$new_props.cellThickness);
    if ("sectionThickness" in $$props) $$invalidate(19, sectionThickness = $$new_props.sectionThickness);
    if ("side" in $$props) $$invalidate(2, side = $$new_props.side);
    if ("type" in $$props) $$invalidate(20, type = $$new_props.type);
    if ("axis" in $$props) $$invalidate(21, axis = $$new_props.axis);
    if ("maxRadius" in $$props) $$invalidate(22, maxRadius = $$new_props.maxRadius);
    if ("cellDividers" in $$props) $$invalidate(23, cellDividers = $$new_props.cellDividers);
    if ("sectionDividers" in $$props) $$invalidate(24, sectionDividers = $$new_props.sectionDividers);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*plane*/
    8192) {
      $: {
        const axes = planeToAxes[plane];
        const c0 = axes.charAt(0);
        const c1 = axes.charAt(1);
        const c2 = axes.charAt(2);
        $$invalidate(3, uniforms.coord0.value = axisToInt[c0], uniforms);
        $$invalidate(3, uniforms.coord1.value = axisToInt[c1], uniforms);
        $$invalidate(3, uniforms.coord2.value = axisToInt[c2], uniforms);
      }
    }
    if ($$self.$$.dirty[0] & /*cellSize*/
    512) {
      $: $$invalidate(3, uniforms.cellSize.value = cellSize, uniforms);
    }
    if ($$self.$$.dirty[0] & /*sectionSize*/
    4096) {
      $: $$invalidate(3, uniforms.sectionSize.value = sectionSize, uniforms);
    }
    if ($$self.$$.dirty[0] & /*backgroundOpacity*/
    2048) {
      $: $$invalidate(3, uniforms.backgroundOpacity.value = backgroundOpacity, uniforms);
    }
    if ($$self.$$.dirty[0] & /*fadeDistance*/
    65536) {
      $: $$invalidate(3, uniforms.fadeDistance.value = fadeDistance, uniforms);
    }
    if ($$self.$$.dirty[0] & /*fadeStrength*/
    131072) {
      $: $$invalidate(3, uniforms.fadeStrength.value = fadeStrength, uniforms);
    }
    if ($$self.$$.dirty[0] & /*cellThickness*/
    262144) {
      $: $$invalidate(3, uniforms.cellThickness.value = cellThickness, uniforms);
    }
    if ($$self.$$.dirty[0] & /*sectionThickness*/
    524288) {
      $: $$invalidate(3, uniforms.sectionThickness.value = sectionThickness, uniforms);
    }
    if ($$self.$$.dirty[0] & /*followCamera*/
    16384) {
      $: $$invalidate(3, uniforms.followCamera.value = followCamera, uniforms);
    }
    if ($$self.$$.dirty[0] & /*infiniteGrid*/
    32768) {
      $: $$invalidate(3, uniforms.infiniteGrid.value = infiniteGrid, uniforms);
    }
    if ($$self.$$.dirty[0] & /*type, axis, maxRadius, cellDividers, sectionDividers*/
    32505856) {
      $: {
        switch (type) {
          case "grid": {
            $$invalidate(3, uniforms.gridType.value = gridType.grid, uniforms);
            break;
          }
          case "lines": {
            $$invalidate(3, uniforms.gridType.value = gridType.lines, uniforms);
            $$invalidate(3, uniforms.lineGridCoord.value = axisToInt[axis], uniforms);
            break;
          }
          case "circular": {
            $$invalidate(3, uniforms.gridType.value = gridType.circular, uniforms);
            $$invalidate(3, uniforms.circleGridMaxRadius.value = maxRadius, uniforms);
            break;
          }
          case "polar": {
            $$invalidate(3, uniforms.gridType.value = gridType.polar, uniforms);
            $$invalidate(3, uniforms.circleGridMaxRadius.value = maxRadius, uniforms);
            $$invalidate(3, uniforms.polarCellDividers.value = cellDividers, uniforms);
            $$invalidate(3, uniforms.polarSectionDividers.value = sectionDividers, uniforms);
            break;
          }
        }
        invalidate();
      }
    }
    if ($$self.$$.dirty[0] & /*uniforms, cellColor*/
    136) {
      $: uniforms.cellColor.value.set(cellColor);
    }
    if ($$self.$$.dirty[0] & /*uniforms, sectionColor*/
    264) {
      $: uniforms.sectionColor.value.set(sectionColor);
    }
    if ($$self.$$.dirty[0] & /*uniforms, backgroundColor*/
    1032) {
      $: uniforms.backgroundColor.value.set(backgroundColor);
    }
  };
  return [
    ref,
    gridSize,
    side,
    uniforms,
    $component,
    component,
    $$restProps,
    cellColor,
    sectionColor,
    cellSize,
    backgroundColor,
    backgroundOpacity,
    sectionSize,
    plane,
    followCamera,
    infiniteGrid,
    fadeDistance,
    fadeStrength,
    cellThickness,
    sectionThickness,
    type,
    axis,
    maxRadius,
    cellDividers,
    sectionDividers,
    slots,
    t_mesh_binding,
    t_mesh_ref_binding,
    $$scope
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        cellColor: 7,
        sectionColor: 8,
        cellSize: 9,
        backgroundColor: 10,
        backgroundOpacity: 11,
        sectionSize: 12,
        plane: 13,
        gridSize: 1,
        followCamera: 14,
        infiniteGrid: 15,
        fadeDistance: 16,
        fadeStrength: 17,
        cellThickness: 18,
        sectionThickness: 19,
        side: 2,
        type: 20,
        axis: 21,
        maxRadius: 22,
        cellDividers: 23,
        sectionDividers: 24,
        ref: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment11.name
    });
  }
  get cellColor() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellColor(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionColor() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionColor(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundOpacity() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundOpacity(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plane() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plane(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gridSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gridSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get followCamera() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set followCamera(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteGrid() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteGrid(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeDistance() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeDistance(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeStrength() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeStrength(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellThickness() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellThickness(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionThickness() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionThickness(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axis() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axis(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxRadius() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxRadius(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellDividers() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellDividers(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionDividers() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionDividers(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/@threlte/extras/dist/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte
var get_default_slot_changes7 = (dirty) => ({ ref: dirty & /*ref*/
131072 });
var get_default_slot_context7 = (ctx) => ({ ref: (
  /*ref*/
  ctx[17]
) });
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        163840)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(35:0) <T.ExtrudeGeometry   let:ref   bind:this={$component}   args={[shape, params]}   on:create={({ ref }) => {     ref.center()     toCreasedNormals(ref, creaseAngle)   }} >",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let t_extrudegeometry;
  let current;
  let t_extrudegeometry_props = {
    args: [
      /*shape*/
      ctx[2],
      /*params*/
      ctx[1]
    ],
    $$slots: {
      default: [
        create_default_slot9,
        ({ ref }) => ({ 17: ref }),
        ({ ref }) => ref ? 131072 : 0
      ]
    },
    $$scope: { ctx }
  };
  t_extrudegeometry = new T.ExtrudeGeometry({
    props: t_extrudegeometry_props,
    $$inline: true
  });
  ctx[13](t_extrudegeometry);
  t_extrudegeometry.$on(
    "create",
    /*create_handler*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(t_extrudegeometry.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_extrudegeometry.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_extrudegeometry, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_extrudegeometry_changes = {};
      if (dirty & /*shape, params*/
      6) t_extrudegeometry_changes.args = [
        /*shape*/
        ctx2[2],
        /*params*/
        ctx2[1]
      ];
      if (dirty & /*$$scope, ref*/
      163840) {
        t_extrudegeometry_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_extrudegeometry.$set(t_extrudegeometry_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_extrudegeometry.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_extrudegeometry.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[13](null);
      destroy_component(t_extrudegeometry, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var eps = 1e-5;
function instance12($$self, $$props, $$invalidate) {
  let width;
  let height;
  let depth;
  let shape;
  let params;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RoundedBoxGeometry", slots, ["default"]);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(3, $component = value));
  let { args = [] } = $$props;
  let { radius = 0.05 } = $$props;
  let { smoothness = 4 } = $$props;
  let { creaseAngle = 0.4 } = $$props;
  let { steps = 1 } = $$props;
  const createShape = (width2, height2, radius0) => {
    const shape2 = new Shape();
    const radius2 = radius0 - eps;
    shape2.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
    shape2.absarc(eps, height2 - radius2 * 2, eps, Math.PI, Math.PI / 2, true);
    shape2.absarc(width2 - radius2 * 2, height2 - radius2 * 2, eps, Math.PI / 2, 0, true);
    shape2.absarc(width2 - radius2 * 2, eps, eps, 0, -Math.PI / 2, true);
    return shape2;
  };
  const writable_props = ["args", "radius", "smoothness", "creaseAngle", "steps"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RoundedBoxGeometry> was created with unknown prop '${key}'`);
  });
  function t_extrudegeometry_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  const create_handler = ({ ref }) => {
    ref.center();
    toCreasedNormals(ref, creaseAngle);
  };
  $$self.$$set = ($$props2) => {
    if ("args" in $$props2) $$invalidate(5, args = $$props2.args);
    if ("radius" in $$props2) $$invalidate(6, radius = $$props2.radius);
    if ("smoothness" in $$props2) $$invalidate(7, smoothness = $$props2.smoothness);
    if ("creaseAngle" in $$props2) $$invalidate(0, creaseAngle = $$props2.creaseAngle);
    if ("steps" in $$props2) $$invalidate(8, steps = $$props2.steps);
    if ("$$scope" in $$props2) $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Shape,
    T,
    forwardEventHandlers,
    toCreasedNormals,
    component,
    args,
    radius,
    smoothness,
    creaseAngle,
    steps,
    eps,
    createShape,
    depth,
    params,
    height,
    width,
    shape,
    $component
  });
  $$self.$inject_state = ($$props2) => {
    if ("args" in $$props2) $$invalidate(5, args = $$props2.args);
    if ("radius" in $$props2) $$invalidate(6, radius = $$props2.radius);
    if ("smoothness" in $$props2) $$invalidate(7, smoothness = $$props2.smoothness);
    if ("creaseAngle" in $$props2) $$invalidate(0, creaseAngle = $$props2.creaseAngle);
    if ("steps" in $$props2) $$invalidate(8, steps = $$props2.steps);
    if ("depth" in $$props2) $$invalidate(9, depth = $$props2.depth);
    if ("params" in $$props2) $$invalidate(1, params = $$props2.params);
    if ("height" in $$props2) $$invalidate(10, height = $$props2.height);
    if ("width" in $$props2) $$invalidate(11, width = $$props2.width);
    if ("shape" in $$props2) $$invalidate(2, shape = $$props2.shape);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*args*/
    32) {
      $: $$invalidate(11, width = args[0] ?? 1);
    }
    if ($$self.$$.dirty & /*args*/
    32) {
      $: $$invalidate(10, height = args[1] ?? 1);
    }
    if ($$self.$$.dirty & /*args*/
    32) {
      $: $$invalidate(9, depth = args[2] ?? 1);
    }
    if ($$self.$$.dirty & /*width, height, radius*/
    3136) {
      $: $$invalidate(2, shape = createShape(width, height, radius));
    }
    if ($$self.$$.dirty & /*depth, radius, smoothness, steps*/
    960) {
      $: $$invalidate(1, params = {
        depth: depth - radius * 2,
        bevelEnabled: true,
        bevelSegments: smoothness * 2,
        steps,
        bevelSize: radius - eps,
        bevelThickness: radius,
        curveSegments: smoothness
      });
    }
  };
  return [
    creaseAngle,
    params,
    shape,
    $component,
    component,
    args,
    radius,
    smoothness,
    steps,
    depth,
    height,
    width,
    slots,
    t_extrudegeometry_binding,
    create_handler,
    $$scope
  ];
}
var RoundedBoxGeometry = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      args: 5,
      radius: 6,
      smoothness: 7,
      creaseAngle: 0,
      steps: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RoundedBoxGeometry",
      options,
      id: create_fragment12.name
    });
  }
  get args() {
    throw new Error("<RoundedBoxGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<RoundedBoxGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<RoundedBoxGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<RoundedBoxGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smoothness() {
    throw new Error("<RoundedBoxGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smoothness(value) {
    throw new Error("<RoundedBoxGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get creaseAngle() {
    throw new Error("<RoundedBoxGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set creaseAngle(value) {
    throw new Error("<RoundedBoxGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get steps() {
    throw new Error("<RoundedBoxGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set steps(value) {
    throw new Error("<RoundedBoxGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RoundedBoxGeometry_default = RoundedBoxGeometry;

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown", mode: null };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Controls {
  constructor(camera, domElement = null) {
    super(void 0, domElement);
    const root = new TransformControlsRoot(this);
    this._root = root;
    const gizmo = new TransformControlsGizmo();
    this._gizmo = gizmo;
    root.add(gizmo);
    const plane = new TransformControlsPlane();
    this._plane = plane;
    root.add(plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            plane[propName] = value;
            gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName] = defaultValue;
      plane[propName] = defaultValue;
      gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    defineProperty("minX", -Infinity);
    defineProperty("maxX", Infinity);
    defineProperty("minY", -Infinity);
    defineProperty("maxY", Infinity);
    defineProperty("minZ", -Infinity);
    defineProperty("maxZ", Infinity);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    if (domElement !== null) {
      this.connect();
    }
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true) return;
    if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0) return;
    if (this.axis !== null) {
      if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space2 = this.space;
    if (mode === "scale") {
      space2 = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space2 = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1) return;
    if (pointer !== null) _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect) return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1) this._offset.x = 0;
      if (axis.indexOf("Y") === -1) this._offset.y = 0;
      if (axis.indexOf("Z") === -1) this._offset.z = 0;
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space2 === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space2 === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
      object.position.x = Math.max(this.minX, Math.min(this.maxX, object.position.x));
      object.position.y = Math.max(this.minY, Math.min(this.maxY, object.position.y));
      object.position.z = Math.max(this.minZ, Math.min(this.maxZ, object.position.z));
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0) d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space2 === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap) this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space2 === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer !== null && pointer.button !== 0) return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.disconnect();
    this._root.dispose();
  }
  // Set current object
  attach(object) {
    this.object = object;
    this._root.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.axis = null;
    this._root.visible = false;
    return this;
  }
  reset() {
    if (!this.enabled) return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space2) {
    this.space = space2;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled) return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled) return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled) return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled) return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsRoot = class extends Object3D {
  constructor(controls) {
    super();
    this.isTransformControlsRoot = true;
    this.controls = controls;
    this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(force) {
    const controls = this.controls;
    if (controls.object !== void 0) {
      controls.object.updateMatrixWorld();
      if (controls.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        controls.object.parent.matrixWorld.decompose(controls._parentPosition, controls._parentQuaternion, controls._parentScale);
      }
      controls.object.matrixWorld.decompose(controls.worldPosition, controls.worldQuaternion, controls._worldScale);
      controls._parentQuaternionInv.copy(controls._parentQuaternion).invert();
      controls._worldQuaternionInv.copy(controls.worldQuaternion).invert();
    }
    controls.camera.updateMatrixWorld();
    controls.camera.matrixWorld.decompose(controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale);
    if (controls.camera.isOrthographicCamera) {
      controls.camera.getWorldDirection(controls.eye).negate();
    } else {
      controls.eye.copy(controls.cameraPosition).sub(controls.worldPosition).normalize();
    }
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.traverse(function(child) {
      if (child.geometry) child.geometry.dispose();
      if (child.material) child.material.dispose();
    });
  }
};
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space2 = this.mode === "scale" ? "local" : this.space;
    const quaternion = space2 === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space2 = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale") space2 = "local";
    _v1.copy(_unitX).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@threlte/extras/dist/components/controls/useControlsContext.js
var useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0),
    trackballControls: writable(void 0)
  });
};

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
var get_default_slot_changes8 = (dirty) => ({ ref: dirty & /*ref*/
536870912 });
var get_default_slot_context8 = (ctx) => ({ ref: (
  /*ref*/
  ctx[29]
) });
function create_default_slot_13(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*$controlsStore*/
      ctx[1]
    ) },
    /*transformProps*/
    ctx[2]
  ];
  let t_props = {};
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[15](t2);
  t2.$on(
    "dragging-changed",
    /*onDraggingChanged*/
    ctx[7]
  );
  t2.$on(
    "change",
    /*invalidate*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*$controlsStore, transformProps*/
      6 ? get_spread_update(t_spread_levels, [
        dirty & /*$controlsStore*/
        2 && { is: (
          /*$controlsStore*/
          ctx2[1]
        ) },
        dirty & /*transformProps*/
        4 && get_spread_object(
          /*transformProps*/
          ctx2[2]
        )
      ]) : {};
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[15](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(90:0) <HierarchicalObject   onChildMount={(child) => {     scene.add(child)   }}   onChildDestroy={(child) => {     scene.remove(child)   }} >",
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        537133056)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(107:0) <T   is={group}   let:ref   {...objectProps} >",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let hierarchicalobject;
  let t0;
  let t1;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      onChildMount: (
        /*func*/
        ctx[16]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[17]
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const t1_spread_levels = [
    { is: (
      /*group*/
      ctx[0]
    ) },
    /*objectProps*/
    ctx[3]
  ];
  let t1_props = {
    $$slots: {
      default: [
        create_default_slot10,
        ({ ref }) => ({ 29: ref }),
        ({ ref }) => ref ? 536870912 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t1_spread_levels.length; i += 1) {
    t1_props = assign(t1_props, t1_spread_levels[i]);
  }
  t1 = new T({ props: t1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t0 = space();
      create_component(t1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope, $controlsStore, transformProps, $component*/
      262166) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      const t1_changes = dirty & /*group, objectProps*/
      9 ? get_spread_update(t1_spread_levels, [
        dirty & /*group*/
        1 && { is: (
          /*group*/
          ctx2[0]
        ) },
        dirty & /*objectProps*/
        8 && get_spread_object(
          /*objectProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      537133056) {
        t1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t1.$set(t1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(t1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(t1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
      }
      destroy_component(hierarchicalobject, detaching);
      destroy_component(t1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "autoPauseOrbitControls",
    "autoPauseTrackballControls",
    "object",
    "group",
    "controls"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $controlsStore;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformControls", slots, ["default"]);
  let { autoPauseOrbitControls = true } = $$props;
  let { autoPauseTrackballControls = true } = $$props;
  let { object = void 0 } = $$props;
  const { camera, renderer, invalidate, scene } = useThrelte();
  const { orbitControls, trackballControls } = useControlsContext();
  const isDragging = writable(false);
  const useAutoPauseOrbitControls = writable(autoPauseOrbitControls ?? true);
  const useAutoPauseTrackballControls = writable(autoPauseTrackballControls ?? true);
  const onDraggingChanged = (e) => {
    isDragging.set(e.value);
  };
  watch([orbitControls, isDragging, useAutoPauseOrbitControls], ([orbitControls2, isDragging2, useAutoPauseOrbitControls2]) => {
    if (!orbitControls2 || !orbitControls2.enabled && isDragging2) return;
    orbitControls2.enabled = !(isDragging2 && useAutoPauseOrbitControls2);
    return () => {
      orbitControls2.enabled = true;
    };
  });
  watch([trackballControls, isDragging, useAutoPauseTrackballControls], ([trackballControls2, isDragging2, useAutoPausetrackballControls]) => {
    if (!trackballControls2 || !trackballControls2.enabled && isDragging2) return;
    trackballControls2.enabled = !(isDragging2 && useAutoPausetrackballControls);
    return () => {
      trackballControls2.enabled = true;
    };
  });
  const group = new Group();
  const controlsStore = derived(camera, (camera2) => {
    return new TransformControls(camera2, renderer.domElement);
  });
  validate_store(controlsStore, "controlsStore");
  component_subscribe($$self, controlsStore, (value) => $$invalidate(1, $controlsStore = value));
  let { controls = $controlsStore } = $$props;
  const attachTo = writable(object ?? group);
  watch([controlsStore, attachTo], ([controls2, attachTo2]) => {
    controls2.attach(attachTo2);
    return () => {
      controls2.detach();
    };
  });
  const transformOnlyPropNames = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible"
  ];
  let transformProps = {};
  let objectProps = {};
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(4, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  const func3 = (child) => {
    scene.add(child);
  };
  const func_12 = (child) => {
    scene.remove(child);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("autoPauseOrbitControls" in $$new_props) $$invalidate(11, autoPauseOrbitControls = $$new_props.autoPauseOrbitControls);
    if ("autoPauseTrackballControls" in $$new_props) $$invalidate(12, autoPauseTrackballControls = $$new_props.autoPauseTrackballControls);
    if ("object" in $$new_props) $$invalidate(13, object = $$new_props.object);
    if ("controls" in $$new_props) $$invalidate(10, controls = $$new_props.controls);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    HierarchicalObject: HierarchicalObject_default,
    T,
    useThrelte,
    watch,
    Group,
    TransformControls,
    derived,
    writable,
    useControlsContext,
    autoPauseOrbitControls,
    autoPauseTrackballControls,
    object,
    camera,
    renderer,
    invalidate,
    scene,
    orbitControls,
    trackballControls,
    isDragging,
    useAutoPauseOrbitControls,
    useAutoPauseTrackballControls,
    onDraggingChanged,
    group,
    controlsStore,
    controls,
    attachTo,
    transformOnlyPropNames,
    transformProps,
    objectProps,
    component,
    $controlsStore,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("autoPauseOrbitControls" in $$props) $$invalidate(11, autoPauseOrbitControls = $$new_props.autoPauseOrbitControls);
    if ("autoPauseTrackballControls" in $$props) $$invalidate(12, autoPauseTrackballControls = $$new_props.autoPauseTrackballControls);
    if ("object" in $$props) $$invalidate(13, object = $$new_props.object);
    if ("controls" in $$props) $$invalidate(10, controls = $$new_props.controls);
    if ("transformProps" in $$props) $$invalidate(2, transformProps = $$new_props.transformProps);
    if ("objectProps" in $$props) $$invalidate(3, objectProps = $$new_props.objectProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoPauseOrbitControls*/
    2048) {
      $: useAutoPauseOrbitControls.set(autoPauseOrbitControls ?? true);
    }
    if ($$self.$$.dirty & /*autoPauseTrackballControls*/
    4096) {
      $: useAutoPauseTrackballControls.set(autoPauseTrackballControls ?? true);
    }
    if ($$self.$$.dirty & /*$controlsStore*/
    2) {
      $: $$invalidate(10, controls = $controlsStore);
    }
    $: {
      $$invalidate(2, transformProps = {});
      $$invalidate(3, objectProps = {});
      for (let [key, value] of Object.entries($$restProps)) {
        if (transformOnlyPropNames.includes(key)) {
          $$invalidate(2, transformProps[key] = value, transformProps);
        } else {
          $$invalidate(3, objectProps[key] = value, objectProps);
        }
      }
    }
  };
  return [
    group,
    $controlsStore,
    transformProps,
    objectProps,
    $component,
    invalidate,
    scene,
    onDraggingChanged,
    controlsStore,
    component,
    controls,
    autoPauseOrbitControls,
    autoPauseTrackballControls,
    object,
    slots,
    t_binding,
    func3,
    func_12,
    $$scope
  ];
}
var TransformControls_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      autoPauseOrbitControls: 11,
      autoPauseTrackballControls: 12,
      object: 13,
      group: 0,
      controls: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformControls_1",
      options,
      id: create_fragment13.name
    });
  }
  get autoPauseOrbitControls() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPauseOrbitControls(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPauseTrackballControls() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPauseTrackballControls(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformControls_default = TransformControls_1;

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent2 = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray();
var _plane = new Plane();
var _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var _v = new Vector3();
var _twoPI = 2 * Math.PI;
var _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
var _EPS = 1e-6;
var OrbitControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.enabled = true;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove2.bind(this);
    this._onPointerDown = onPointerDown2.bind(this);
    this._onPointerUp = onPointerUp2.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect();
    }
    this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent2);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position = this.object.position;
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min = this.minAzimuthAngle;
    let max = this.maxAzimuthAngle;
    if (isFinite(min) && isFinite(max)) {
      if (min < -Math.PI) min += _twoPI;
      else if (min > Math.PI) min -= _twoPI;
      if (max < -Math.PI) max += _twoPI;
      else if (max > Math.PI) max -= _twoPI;
      if (min <= max) {
        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent2);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance);
    this._panOffset.add(_v);
  }
  _panUp(distance, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position = this.object.position;
      _v.copy(position).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y - rect.top;
    const w = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x, y);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panStart.set(x, y);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x, y);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x, y);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
};
function onPointerDown2(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove2(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp2(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}

// node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte
var { Error: Error_13 } = globals;
var get_default_slot_changes9 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context9 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        257)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(30:0) <T   is={ref}   let:ref   {...$$restProps}   bind:this={$component}   on:change={invalidate} >",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot11, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[7](t2);
  t2.$on(
    "change",
    /*invalidate*/
    ctx[3]
  );
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      33 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      257) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrbitControls", slots, ["default"]);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(9, $parent = value));
  const isCamera = (p) => {
    return p.isCamera;
  };
  const { renderer, invalidate } = useThrelte();
  if (!isCamera($parent)) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const ref = new OrbitControls($parent, renderer.domElement);
  const { start, stop } = useTask(() => ref.update(), { autoStart: false, autoInvalidate: false });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  const { orbitControls } = useControlsContext();
  orbitControls.set(ref);
  onDestroy(() => orbitControls.set(void 0));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useTask,
    useParent,
    useThrelte,
    ThreeOrbitControls: OrbitControls,
    onDestroy,
    useControlsContext,
    parent,
    isCamera,
    renderer,
    invalidate,
    ref,
    start,
    stop,
    component,
    orbitControls,
    $parent,
    $component
  });
  $$self.$$.update = () => {
    $: {
      if ($$restProps.autoRotate || $$restProps.enableDamping) start();
      else stop();
    }
  };
  return [
    ref,
    $component,
    parent,
    invalidate,
    component,
    $$restProps,
    slots,
    t_binding,
    $$scope
  ];
}
var OrbitControls2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrbitControls",
      options,
      id: create_fragment14.name
    });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrbitControls_default = OrbitControls2;

// node_modules/three/examples/jsm/controls/TrackballControls.js
var _changeEvent3 = { type: "change" };
var _startEvent2 = { type: "start" };
var _endEvent2 = { type: "end" };
var _EPS2 = 1e-6;
var _STATE2 = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
var _v22 = new Vector2();
var _mouseChange = new Vector2();
var _objectUp = new Vector3();
var _pan = new Vector3();
var _axis = new Vector3();
var _quaternion = new Quaternion();
var _eyeDirection = new Vector3();
var _objectUpDirection = new Vector3();
var _objectSidewaysDirection = new Vector3();
var _moveDirection = new Vector3();
var TrackballControls = class extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.enabled = true;
    this.screen = { left: 0, top: 0, width: 0, height: 0 };
    this.rotateSpeed = 1;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;
    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ];
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.state = _STATE2.NONE;
    this.keyState = _STATE2.NONE;
    this.target = new Vector3();
    this._lastPosition = new Vector3();
    this._lastZoom = 1;
    this._touchZoomDistanceStart = 0;
    this._touchZoomDistanceEnd = 0;
    this._lastAngle = 0;
    this._eye = new Vector3();
    this._movePrev = new Vector2();
    this._moveCurr = new Vector2();
    this._lastAxis = new Vector3();
    this._zoomStart = new Vector2();
    this._zoomEnd = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._pointers = [];
    this._pointerPositions = {};
    this._onPointerMove = onPointerMove3.bind(this);
    this._onPointerDown = onPointerDown3.bind(this);
    this._onPointerUp = onPointerUp3.bind(this);
    this._onPointerCancel = onPointerCancel.bind(this);
    this._onContextMenu = onContextMenu2.bind(this);
    this._onMouseWheel = onMouseWheel2.bind(this);
    this._onKeyDown = onKeyDown2.bind(this);
    this._onKeyUp = onKeyUp.bind(this);
    this._onTouchStart = onTouchStart2.bind(this);
    this._onTouchMove = onTouchMove2.bind(this);
    this._onTouchEnd = onTouchEnd.bind(this);
    this._onMouseDown = onMouseDown2.bind(this);
    this._onMouseMove = onMouseMove2.bind(this);
    this._onMouseUp = onMouseUp.bind(this);
    this._target0 = this.target.clone();
    this._position0 = this.object.position.clone();
    this._up0 = this.object.up.clone();
    this._zoom0 = this.object.zoom;
    if (domElement !== null) {
      this.connect();
      this.handleResize();
    }
    this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown);
    window.addEventListener("keyup", this._onKeyUp);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerCancel);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("keyup", this._onKeyUp);
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerCancel);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const box = this.domElement.getBoundingClientRect();
    const d = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target);
    if (!this.noRotate) {
      this._rotateCamera();
    }
    if (!this.noZoom) {
      this._zoomCamera();
    }
    if (!this.noPan) {
      this._panCamera();
    }
    this.object.position.addVectors(this.target, this._eye);
    if (this.object.isPerspectiveCamera) {
      this._checkDistances();
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS2) {
        this.dispatchEvent(_changeEvent3);
        this._lastPosition.copy(this.object.position);
      }
    } else if (this.object.isOrthographicCamera) {
      this.object.lookAt(this.target);
      if (this._lastPosition.distanceToSquared(this.object.position) > _EPS2 || this._lastZoom !== this.object.zoom) {
        this.dispatchEvent(_changeEvent3);
        this._lastPosition.copy(this.object.position);
        this._lastZoom = this.object.zoom;
      }
    } else {
      console.warn("THREE.TrackballControls: Unsupported camera type.");
    }
  }
  reset() {
    this.state = _STATE2.NONE;
    this.keyState = _STATE2.NONE;
    this.target.copy(this._target0);
    this.object.position.copy(this._position0);
    this.object.up.copy(this._up0);
    this.object.zoom = this._zoom0;
    this.object.updateProjectionMatrix();
    this._eye.subVectors(this.object.position, this.target);
    this.object.lookAt(this.target);
    this.dispatchEvent(_changeEvent3);
    this._lastPosition.copy(this.object.position);
    this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    _mouseChange.copy(this._panEnd).sub(this._panStart);
    if (_mouseChange.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;
        const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        _mouseChange.x *= scale_x;
        _mouseChange.y *= scale_y;
      }
      _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
      _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);
      _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));
      this.object.position.add(_pan);
      this.target.add(_pan);
      if (this.staticMoving) {
        this._panStart.copy(this._panEnd);
      } else {
        this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
      }
    }
  }
  _rotateCamera() {
    _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let angle = _moveDirection.length();
    if (angle) {
      this._eye.copy(this.object.position).sub(this.target);
      _eyeDirection.copy(this._eye).normalize();
      _objectUpDirection.copy(this.object.up).normalize();
      _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();
      _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
      _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
      _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));
      _axis.crossVectors(_moveDirection, this._eye).normalize();
      angle *= this.rotateSpeed;
      _quaternion.setFromAxisAngle(_axis, angle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
      this._lastAxis.copy(_axis);
      this._lastAngle = angle;
    } else if (!this.staticMoving && this._lastAngle) {
      this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor);
      this._eye.copy(this.object.position).sub(this.target);
      _quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);
      this._eye.applyQuaternion(_quaternion);
      this.object.up.applyQuaternion(_quaternion);
    }
    this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let factor;
    if (this.state === _STATE2.TOUCH_ZOOM_PAN) {
      factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
      this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
      if (this.object.isPerspectiveCamera) {
        this._eye.multiplyScalar(factor);
      } else if (this.object.isOrthographicCamera) {
        this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
        if (this._lastZoom !== this.object.zoom) {
          this.object.updateProjectionMatrix();
        }
      } else {
        console.warn("THREE.TrackballControls: Unsupported camera type");
      }
    } else {
      factor = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
      if (factor !== 1 && factor > 0) {
        if (this.object.isPerspectiveCamera) {
          this._eye.multiplyScalar(factor);
        } else if (this.object.isOrthographicCamera) {
          this.object.zoom = MathUtils.clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
          if (this._lastZoom !== this.object.zoom) {
            this.object.updateProjectionMatrix();
          }
        } else {
          console.warn("THREE.TrackballControls: Unsupported camera type");
        }
      }
      if (this.staticMoving) {
        this._zoomStart.copy(this._zoomEnd);
      } else {
        this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
      }
    }
  }
  _getMouseOnScreen(pageX, pageY) {
    _v22.set(
      (pageX - this.screen.left) / this.screen.width,
      (pageY - this.screen.top) / this.screen.height
    );
    return _v22;
  }
  _getMouseOnCircle(pageX, pageY) {
    _v22.set(
      (pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width
      // screen.width intentional
    );
    return _v22;
  }
  _addPointer(event) {
    this._pointers.push(event);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i].pointerId == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointer.pointerId];
  }
  _checkDistances() {
    if (!this.noZoom || !this.noPan) {
      if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
      if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
        this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
        this._zoomStart.copy(this._zoomEnd);
      }
    }
  }
};
function onPointerDown3(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove3(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp3(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchEnd(event);
  } else {
    this._onMouseUp();
  }
  this._removePointer(event);
  if (this._pointers.length === 0) {
    this.domElement.releasePointerCapture(event.pointerId);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
  }
}
function onPointerCancel(event) {
  this._removePointer(event);
}
function onKeyUp() {
  if (this.enabled === false) return;
  this.keyState = _STATE2.NONE;
  window.addEventListener("keydown", this._onKeyDown);
}
function onKeyDown2(event) {
  if (this.enabled === false) return;
  window.removeEventListener("keydown", this._onKeyDown);
  if (this.keyState !== _STATE2.NONE) {
    return;
  } else if (event.code === this.keys[_STATE2.ROTATE] && !this.noRotate) {
    this.keyState = _STATE2.ROTATE;
  } else if (event.code === this.keys[_STATE2.ZOOM] && !this.noZoom) {
    this.keyState = _STATE2.ZOOM;
  } else if (event.code === this.keys[_STATE2.PAN] && !this.noPan) {
    this.keyState = _STATE2.PAN;
  }
}
function onMouseDown2(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      this.state = _STATE2.ZOOM;
      break;
    case MOUSE.ROTATE:
      this.state = _STATE2.ROTATE;
      break;
    case MOUSE.PAN:
      this.state = _STATE2.PAN;
      break;
    default:
      this.state = _STATE2.NONE;
  }
  const state = this.keyState !== _STATE2.NONE ? this.keyState : this.state;
  if (state === _STATE2.ROTATE && !this.noRotate) {
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
    this._movePrev.copy(this._moveCurr);
  } else if (state === _STATE2.ZOOM && !this.noZoom) {
    this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._zoomEnd.copy(this._zoomStart);
  } else if (state === _STATE2.PAN && !this.noPan) {
    this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    this._panEnd.copy(this._panStart);
  }
  this.dispatchEvent(_startEvent2);
}
function onMouseMove2(event) {
  const state = this.keyState !== _STATE2.NONE ? this.keyState : this.state;
  if (state === _STATE2.ROTATE && !this.noRotate) {
    this._movePrev.copy(this._moveCurr);
    this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
  } else if (state === _STATE2.ZOOM && !this.noZoom) {
    this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  } else if (state === _STATE2.PAN && !this.noPan) {
    this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
  }
}
function onMouseUp() {
  this.state = _STATE2.NONE;
  this.dispatchEvent(_endEvent2);
}
function onMouseWheel2(event) {
  if (this.enabled === false) return;
  if (this.noZoom === true) return;
  event.preventDefault();
  switch (event.deltaMode) {
    case 2:
      this._zoomStart.y -= event.deltaY * 0.025;
      break;
    case 1:
      this._zoomStart.y -= event.deltaY * 0.01;
      break;
    default:
      this._zoomStart.y -= event.deltaY * 25e-5;
      break;
  }
  this.dispatchEvent(_startEvent2);
  this.dispatchEvent(_endEvent2);
}
function onContextMenu2(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function onTouchStart2(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this.state = _STATE2.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = _STATE2.TOUCH_ZOOM_PAN;
      const dx = this._pointers[0].pageX - this._pointers[1].pageX;
      const dy = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
      const x = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;
      const y = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(x, y));
      this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(_startEvent2);
}
function onTouchMove2(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr);
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      break;
    default:
      const position = this._getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
      const x = (event.pageX + position.x) / 2;
      const y = (event.pageY + position.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(x, y));
      break;
  }
}
function onTouchEnd(event) {
  switch (this._pointers.length) {
    case 0:
      this.state = _STATE2.NONE;
      break;
    case 1:
      this.state = _STATE2.TOUCH_ROTATE;
      this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
      this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = _STATE2.TOUCH_ZOOM_PAN;
      for (let i = 0; i < this._pointers.length; i++) {
        if (this._pointers[i].pointerId !== event.pointerId) {
          const position = this._pointerPositions[this._pointers[i].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));
          this._movePrev.copy(this._moveCurr);
          break;
        }
      }
      break;
  }
  this.dispatchEvent(_endEvent2);
}

// node_modules/@threlte/extras/dist/components/controls/TrackballControls/TrackballControls.svelte
var { Error: Error_14 } = globals;
var get_default_slot_changes10 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context10 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        257)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(23:0) <T   is={ref}   let:ref   {...$$restProps}   bind:this={$component}   on:change={invalidate} >",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot12, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[7](t2);
  t2.$on(
    "change",
    /*invalidate*/
    ctx[3]
  );
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      33 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      257) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrackballControls", slots, ["default"]);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(9, $parent = value));
  const isCamera = (p) => {
    return p.isCamera;
  };
  const { renderer, invalidate } = useThrelte();
  if (!isCamera($parent)) {
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  }
  const ref = new TrackballControls($parent, renderer.domElement);
  useTask(() => ref.update(), { autoInvalidate: false });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  const { trackballControls } = useControlsContext();
  trackballControls.set(ref);
  onDestroy(() => trackballControls.set(void 0));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useTask,
    useParent,
    useThrelte,
    ThreeTrackballControls: TrackballControls,
    onDestroy,
    useControlsContext,
    parent,
    isCamera,
    renderer,
    invalidate,
    ref,
    component,
    trackballControls,
    $parent,
    $component
  });
  return [
    ref,
    $component,
    parent,
    invalidate,
    component,
    $$restProps,
    slots,
    t_binding,
    $$scope
  ];
}
var TrackballControls2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrackballControls",
      options,
      id: create_fragment15.name
    });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_14("<TrackballControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrackballControls_default = TrackballControls2;

// node_modules/@threlte/extras/dist/components/Instancing/api.js
var getContextId = (instancedMeshId) => `threlte-instanced-mesh-${instancedMeshId}`;
var createApi = (instancedMesh, instancedMeshId) => {
  const api = {
    instancedMesh: currentWritable(instancedMesh),
    addInstance(instance44) {
      api.instances.update((arr) => {
        arr.push(instance44);
        return arr;
      });
    },
    removeInstance(instance44) {
      api.instances.update((arr) => {
        const index = arr.indexOf(instance44);
        if (index > -1)
          arr.splice(index, 1);
        return arr;
      });
    },
    instances: currentWritable([])
  };
  setContext(getContextId(instancedMeshId), api);
  return api;
};
var useApi = (instancedMeshId) => {
  const context = getContext(getContextId(instancedMeshId));
  if (!context)
    throw new Error(`No <InstancedMesh> component found for id ${instancedMeshId}`);
  return context;
};

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
function create_fragment16(ctx) {
  let t_instancedbufferattribute0;
  let t0;
  let t_instancedbufferattribute1;
  let t1;
  let current;
  t_instancedbufferattribute0 = new T.InstancedBufferAttribute({
    props: {
      attach: "instanceMatrix",
      count: (
        /*matrices*/
        ctx[1].length / 16
      ),
      array: (
        /*matrices*/
        ctx[1]
      ),
      itemSize: 16,
      usage: DynamicDrawUsage
    },
    $$inline: true
  });
  t_instancedbufferattribute1 = new T.InstancedBufferAttribute({
    props: {
      attach: "instanceColor",
      count: (
        /*colors*/
        ctx[2].length / 3
      ),
      array: (
        /*colors*/
        ctx[2]
      ),
      itemSize: 3,
      usage: DynamicDrawUsage
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      create_component(t_instancedbufferattribute0.$$.fragment);
      t0 = space();
      create_component(t_instancedbufferattribute1.$$.fragment);
      t1 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_instancedbufferattribute0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_instancedbufferattribute1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_instancedbufferattribute0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_instancedbufferattribute1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_instancedbufferattribute0.$$.fragment, local);
      transition_in(t_instancedbufferattribute1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_instancedbufferattribute0.$$.fragment, local);
      transition_out(t_instancedbufferattribute1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(t_instancedbufferattribute0, detaching);
      destroy_component(t_instancedbufferattribute1, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $instances;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Api", slots, ["default"]);
  let { instancedMesh } = $$props;
  let { id } = $$props;
  let { limit } = $$props;
  let { range } = $$props;
  let { update } = $$props;
  const { instances } = createApi(instancedMesh, id);
  validate_store(instances, "instances");
  component_subscribe($$self, instances, (value) => $$invalidate(8, $instances = value));
  const tempMatrix = new Matrix4();
  const matrices = new Float32Array(limit * 16);
  for (let i = 0; i < limit; i++) tempMatrix.identity().toArray(matrices, i * 16);
  const colors = new Float32Array(limit * 3).fill(1);
  const parentMatrix = new Matrix4();
  const instanceMatrix = new Matrix4();
  const translation = new Vector3();
  const rotation = new Quaternion();
  const scale = new Vector3();
  let initialUpdateDone = false;
  useTask(() => {
    instancedMesh.updateMatrix();
    if (update || !initialUpdateDone) {
      instancedMesh.updateMatrixWorld();
      parentMatrix.copy(instancedMesh.matrixWorld).invert();
      if (instancedMesh.instanceColor) {
        $$invalidate(3, instancedMesh.instanceColor.needsUpdate = true, instancedMesh);
      }
      $$invalidate(3, instancedMesh.instanceMatrix.needsUpdate = true, instancedMesh);
      for (let i = 0; i < instances.current.length; i++) {
        const instance44 = instances.current[i];
        instance44.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);
        instanceMatrix.toArray(matrices, i * 16);
        instance44.color.toArray(colors, i * 3);
      }
      initialUpdateDone = true;
    }
  });
  $$self.$$.on_mount.push(function() {
    if (instancedMesh === void 0 && !("instancedMesh" in $$props || $$self.$$.bound[$$self.$$.props["instancedMesh"]])) {
      console.warn("<Api> was created without expected prop 'instancedMesh'");
    }
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Api> was created without expected prop 'id'");
    }
    if (limit === void 0 && !("limit" in $$props || $$self.$$.bound[$$self.$$.props["limit"]])) {
      console.warn("<Api> was created without expected prop 'limit'");
    }
    if (range === void 0 && !("range" in $$props || $$self.$$.bound[$$self.$$.props["range"]])) {
      console.warn("<Api> was created without expected prop 'range'");
    }
    if (update === void 0 && !("update" in $$props || $$self.$$.bound[$$self.$$.props["update"]])) {
      console.warn("<Api> was created without expected prop 'update'");
    }
  });
  const writable_props = ["instancedMesh", "id", "limit", "range", "update"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Api> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("instancedMesh" in $$props2) $$invalidate(3, instancedMesh = $$props2.instancedMesh);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("limit" in $$props2) $$invalidate(5, limit = $$props2.limit);
    if ("range" in $$props2) $$invalidate(6, range = $$props2.range);
    if ("update" in $$props2) $$invalidate(7, update = $$props2.update);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useTask,
    revision,
    DynamicDrawUsage,
    Matrix4,
    Quaternion,
    Vector3,
    createApi,
    instancedMesh,
    id,
    limit,
    range,
    update,
    instances,
    tempMatrix,
    matrices,
    colors,
    parentMatrix,
    instanceMatrix,
    translation,
    rotation,
    scale,
    initialUpdateDone,
    $instances
  });
  $$self.$inject_state = ($$props2) => {
    if ("instancedMesh" in $$props2) $$invalidate(3, instancedMesh = $$props2.instancedMesh);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("limit" in $$props2) $$invalidate(5, limit = $$props2.limit);
    if ("range" in $$props2) $$invalidate(6, range = $$props2.range);
    if ("update" in $$props2) $$invalidate(7, update = $$props2.update);
    if ("initialUpdateDone" in $$props2) initialUpdateDone = $$props2.initialUpdateDone;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*limit, range, $instances, instancedMesh*/
    360) {
      $: {
        const updateRange = Math.min(limit, range !== void 0 ? range : limit, $instances.length);
        $$invalidate(3, instancedMesh.count = updateRange, instancedMesh);
        if (revision >= 159) {
          instancedMesh.instanceMatrix.clearUpdateRanges();
          instancedMesh.instanceMatrix.addUpdateRange(0, updateRange * 16);
        } else {
          $$invalidate(3, instancedMesh.instanceMatrix.updateRange.count = updateRange * 16, instancedMesh);
        }
        if (instancedMesh.instanceColor) {
          if (revision >= 159) {
            instancedMesh.instanceColor.clearUpdateRanges();
            instancedMesh.instanceColor.addUpdateRange(0, updateRange * 3);
          } else {
            $$invalidate(3, instancedMesh.instanceColor.updateRange.count = updateRange * 3, instancedMesh);
          }
        }
      }
    }
  };
  return [
    instances,
    matrices,
    colors,
    instancedMesh,
    id,
    limit,
    range,
    update,
    $instances,
    $$scope,
    slots
  ];
}
var Api = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      instancedMesh: 3,
      id: 4,
      limit: 5,
      range: 6,
      update: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Api",
      options,
      id: create_fragment16.name
    });
  }
  get instancedMesh() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instancedMesh(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Api_default = Api;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
var get_default_slot_changes11 = (dirty) => ({});
var get_default_slot_context11 = (ctx) => ({ ref: (
  /*ref*/
  ctx[4]
) });
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context11
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(21:2) <Api     instancedMesh={ref}     {id}     {limit}     {range}     {update}   >",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let api;
  let current;
  api = new Api_default({
    props: {
      instancedMesh: (
        /*ref*/
        ctx[4]
      ),
      id: (
        /*id*/
        ctx[0]
      ),
      limit: (
        /*limit*/
        ctx[1]
      ),
      range: (
        /*range*/
        ctx[2]
      ),
      update: (
        /*update*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(api.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(api.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const api_changes = {};
      if (dirty & /*id*/
      1) api_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*limit*/
      2) api_changes.limit = /*limit*/
      ctx2[1];
      if (dirty & /*range*/
      4) api_changes.range = /*range*/
      ctx2[2];
      if (dirty & /*update*/
      8) api_changes.update = /*update*/
      ctx2[3];
      if (dirty & /*$$scope*/
      2048) {
        api_changes.$$scope = { dirty, ctx: ctx2 };
      }
      api.$set(api_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(13:0) <T   is={ref}   raycast={() => null}   matrixAutoUpdate={false}   {args}   {...$$restProps}   bind:bind={$dispatchingComponent} >",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let t2;
  let updating_bind;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[4]
    ) },
    { raycast: func },
    { matrixAutoUpdate: false },
    { args: (
      /*args*/
      ctx[7]
    ) },
    /*$$restProps*/
    ctx[8]
  ];
  function t_bind_binding(value) {
    ctx[10](value);
  }
  let t_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  if (
    /*$dispatchingComponent*/
    ctx[5] !== void 0
  ) {
    t_props.bind = /*$dispatchingComponent*/
    ctx[5];
  }
  t2 = new T({ props: t_props, $$inline: true });
  binding_callbacks.push(() => bind(t2, "bind", t_bind_binding));
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, args, $$restProps*/
      400 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        16 && { is: (
          /*ref*/
          ctx2[4]
        ) },
        t_spread_levels[1],
        t_spread_levels[2],
        dirty & /*args*/
        128 && { args: (
          /*args*/
          ctx2[7]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx2[8]
        )
      ]) : {};
      if (dirty & /*$$scope, id, limit, range, update*/
      2063) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_bind && dirty & /*$dispatchingComponent*/
      32) {
        updating_bind = true;
        t_changes.bind = /*$dispatchingComponent*/
        ctx2[5];
        add_flush_callback(() => updating_bind = false);
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = () => null;
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "limit", "range", "update", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMesh", slots, ["default"]);
  let { id = "default" } = $$props;
  let { limit = 1e3 } = $$props;
  let { range = 1e3 } = $$props;
  let { update = true } = $$props;
  const ref = new InstancedMesh(null, null, 0);
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(5, $dispatchingComponent = value));
  const args = [null, null, 0];
  function t_bind_binding(value) {
    $dispatchingComponent = value;
    dispatchingComponent.set($dispatchingComponent);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    if ("limit" in $$new_props) $$invalidate(1, limit = $$new_props.limit);
    if ("range" in $$new_props) $$invalidate(2, range = $$new_props.range);
    if ("update" in $$new_props) $$invalidate(3, update = $$new_props.update);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    forwardEventHandlers,
    Api: Api_default,
    InstancedMesh,
    id,
    limit,
    range,
    update,
    ref,
    dispatchingComponent,
    args,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
    if ("limit" in $$props) $$invalidate(1, limit = $$new_props.limit);
    if ("range" in $$props) $$invalidate(2, range = $$new_props.range);
    if ("update" in $$props) $$invalidate(3, update = $$new_props.update);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    limit,
    range,
    update,
    ref,
    $dispatchingComponent,
    dispatchingComponent,
    args,
    $$restProps,
    slots,
    t_bind_binding,
    $$scope
  ];
}
var InstancedMesh_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      id: 0,
      limit: 1,
      range: 2,
      update: 3,
      ref: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMesh_1",
      options,
      id: create_fragment17.name
    });
  }
  get id() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[4];
  }
  set ref(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMesh_default = InstancedMesh_1;

// node_modules/@threlte/extras/dist/components/Instancing/PositionMesh.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var isMaterial = (o) => {
  return o.isMaterial;
};
var PositionMesh = class extends Group {
  constructor(instancedMesh, instances) {
    super();
    __publicField(this, "color");
    __publicField(this, "instancedMesh");
    __publicField(this, "instances");
    this.color = new Color("white");
    this.instancedMesh = instancedMesh;
    this.instances = instances;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _a;
    return (_a = this.instancedMesh.current) == null ? void 0 : _a.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    var _a;
    const parent = this.instancedMesh.current;
    if (!parent)
      return;
    if (!parent.geometry || !parent.material)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    const instanceId = this.instances.current.indexOf(this);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (isMaterial(parent.material))
      _mesh.material.side = parent.material.side;
    else
      _mesh.material.side = ((_a = parent.material[0]) == null ? void 0 : _a.side) ?? FrontSide;
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
      const intersect = _instanceIntersects[i];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte
var get_default_slot_changes12 = (dirty) => ({});
var get_default_slot_context12 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(15:0) <T   is={ref}   bind:this={$dispatchingComponent}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[6](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      128) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[6](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Instance", slots, ["default"]);
  let { id = "default" } = $$props;
  const { addInstance, removeInstance, instancedMesh, instances } = useApi(id);
  const ref = new PositionMesh(instancedMesh, instances);
  addInstance(ref);
  onDestroy(() => {
    removeInstance(ref);
  });
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(1, $dispatchingComponent = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    forwardEventHandlers,
    onDestroy,
    PositionMesh,
    useApi,
    id,
    addInstance,
    removeInstance,
    instancedMesh,
    instances,
    ref,
    dispatchingComponent,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    $dispatchingComponent,
    dispatchingComponent,
    $$restProps,
    id,
    slots,
    t_binding,
    $$scope
  ];
}
var Instance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { id: 4, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Instance",
      options,
      id: create_fragment18.name
    });
  }
  get id() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Instance_default = Instance;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let instancedmesh;
  let current;
  const instancedmesh_spread_levels = [
    { geometry: (
      /*mesh*/
      ctx[2].geometry
    ) },
    { material: (
      /*mesh*/
      ctx[2].material
    ) },
    { id: (
      /*mesh*/
      ctx[2].uuid
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let instancedmesh_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < instancedmesh_spread_levels.length; i += 1) {
    instancedmesh_props = assign(instancedmesh_props, instancedmesh_spread_levels[i]);
  }
  instancedmesh = new InstancedMesh_default({
    props: instancedmesh_props,
    $$inline: true
  });
  ctx[7](instancedmesh);
  const block = {
    c: function create() {
      create_component(instancedmesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(instancedmesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(instancedmesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const instancedmesh_changes = dirty & /*mesh, $$restProps*/
      20 ? get_spread_update(instancedmesh_spread_levels, [
        dirty & /*mesh*/
        4 && { geometry: (
          /*mesh*/
          ctx2[2].geometry
        ) },
        dirty & /*mesh*/
        4 && { material: (
          /*mesh*/
          ctx2[2].material
        ) },
        dirty & /*mesh*/
        4 && { id: (
          /*mesh*/
          ctx2[2].uuid
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        instancedmesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      instancedmesh.$set(instancedmesh_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(instancedmesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(instancedmesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      destroy_component(instancedmesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(9:0) {#if mesh}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(17:4) <svelte:self meshes={copiedArray}>",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let innerinstancedmeshes;
  let current;
  innerinstancedmeshes = new InnerInstancedMeshes({
    props: {
      meshes: (
        /*copiedArray*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(innerinstancedmeshes.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(innerinstancedmeshes.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(innerinstancedmeshes, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const innerinstancedmeshes_changes = {};
      if (dirty & /*$$scope*/
      256) {
        innerinstancedmeshes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innerinstancedmeshes.$set(innerinstancedmeshes_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(innerinstancedmeshes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(innerinstancedmeshes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(innerinstancedmeshes, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(10:2) <InstancedMesh     geometry={mesh.geometry}     material={mesh.material}     id={mesh.uuid}     bind:this={$dispatchingComponent}     {...$$restProps}   >",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*mesh*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["meshes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InnerInstancedMeshes", slots, ["default"]);
  let { meshes } = $$props;
  const copiedArray = [...meshes];
  const mesh = copiedArray.pop();
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(0, $dispatchingComponent = value));
  $$self.$$.on_mount.push(function() {
    if (meshes === void 0 && !("meshes" in $$props || $$self.$$.bound[$$self.$$.props["meshes"]])) {
      console.warn("<InnerInstancedMeshes> was created without expected prop 'meshes'");
    }
  });
  function instancedmesh_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("meshes" in $$new_props) $$invalidate(5, meshes = $$new_props.meshes);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    InstancedMesh: InstancedMesh_default,
    meshes,
    copiedArray,
    mesh,
    dispatchingComponent,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("meshes" in $$props) $$invalidate(5, meshes = $$new_props.meshes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $dispatchingComponent,
    copiedArray,
    mesh,
    dispatchingComponent,
    $$restProps,
    meshes,
    slots,
    instancedmesh_binding,
    $$scope
  ];
}
var InnerInstancedMeshes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { meshes: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InnerInstancedMeshes",
      options,
      id: create_fragment19.name
    });
  }
  get meshes() {
    throw new Error("<InnerInstancedMeshes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meshes(value) {
    throw new Error("<InnerInstancedMeshes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InnerInstancedMeshes_default = InnerInstancedMeshes;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte
var get_default_slot_changes13 = (dirty) => ({ components: dirty & /*components*/
2 });
var get_default_slot_context13 = (ctx) => ({ components: (
  /*components*/
  ctx[1]
) });
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context13
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, components*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(39:0) <InnerInstancedMeshes   meshes={filteredMeshesArray}   bind:this={$dispatchingComponent}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let innerinstancedmeshes;
  let current;
  const innerinstancedmeshes_spread_levels = [
    { meshes: (
      /*filteredMeshesArray*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let innerinstancedmeshes_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < innerinstancedmeshes_spread_levels.length; i += 1) {
    innerinstancedmeshes_props = assign(innerinstancedmeshes_props, innerinstancedmeshes_spread_levels[i]);
  }
  innerinstancedmeshes = new InnerInstancedMeshes_default({
    props: innerinstancedmeshes_props,
    $$inline: true
  });
  ctx[8](innerinstancedmeshes);
  const block = {
    c: function create() {
      create_component(innerinstancedmeshes.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(innerinstancedmeshes.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(innerinstancedmeshes, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const innerinstancedmeshes_changes = dirty & /*filteredMeshesArray, $$restProps*/
      17 ? get_spread_update(innerinstancedmeshes_spread_levels, [
        dirty & /*filteredMeshesArray*/
        1 && { meshes: (
          /*filteredMeshesArray*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope, components*/
      514) {
        innerinstancedmeshes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innerinstancedmeshes.$set(innerinstancedmeshes_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(innerinstancedmeshes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(innerinstancedmeshes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(innerinstancedmeshes, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let components;
  let meshesArray;
  let filteredMeshesArray;
  const omit_props_names = ["meshes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMeshes", slots, ["default"]);
  let { meshes } = $$props;
  const getInstance = (id) => {
    return new Proxy(
      Instance_default,
      {
        construct(Instance2, args) {
          const opts = {
            ...args[0],
            props: { ...args[0].props, id }
          };
          return new Instance2(opts);
        }
      }
    );
  };
  const getInstanceComponentsArray = (meshes2) => {
    return meshes2.filter((mesh) => mesh.isMesh).map((mesh) => getInstance(mesh.uuid));
  };
  const getInstanceComponentsObject = (meshes2) => {
    return Object.entries(meshes2).reduce(
      (acc, [id, mesh]) => {
        if (!mesh.isMesh) return acc;
        acc[id] = getInstance(mesh.uuid);
        return acc;
      },
      {}
    );
  };
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(2, $dispatchingComponent = value));
  $$self.$$.on_mount.push(function() {
    if (meshes === void 0 && !("meshes" in $$props || $$self.$$.bound[$$self.$$.props["meshes"]])) {
      console.warn("<InstancedMeshes> was created without expected prop 'meshes'");
    }
  });
  function innerinstancedmeshes_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("meshes" in $$new_props) $$invalidate(5, meshes = $$new_props.meshes);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    Instance: Instance_default,
    InnerInstancedMeshes: InnerInstancedMeshes_default,
    meshes,
    getInstance,
    getInstanceComponentsArray,
    getInstanceComponentsObject,
    dispatchingComponent,
    meshesArray,
    filteredMeshesArray,
    components,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("meshes" in $$props) $$invalidate(5, meshes = $$new_props.meshes);
    if ("meshesArray" in $$props) $$invalidate(6, meshesArray = $$new_props.meshesArray);
    if ("filteredMeshesArray" in $$props) $$invalidate(0, filteredMeshesArray = $$new_props.filteredMeshesArray);
    if ("components" in $$props) $$invalidate(1, components = $$new_props.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*meshes*/
    32) {
      $: $$invalidate(1, components = Array.isArray(meshes) ? getInstanceComponentsArray(meshes) : getInstanceComponentsObject(meshes));
    }
    if ($$self.$$.dirty & /*meshes*/
    32) {
      $: $$invalidate(6, meshesArray = Array.isArray(meshes) ? meshes : Object.values(meshes));
    }
    if ($$self.$$.dirty & /*meshesArray*/
    64) {
      $: $$invalidate(0, filteredMeshesArray = meshesArray.filter((mesh) => mesh.isMesh));
    }
  };
  return [
    filteredMeshesArray,
    components,
    $dispatchingComponent,
    dispatchingComponent,
    $$restProps,
    meshes,
    meshesArray,
    slots,
    innerinstancedmeshes_binding,
    $$scope
  ];
}
var InstancedMeshes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { meshes: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMeshes",
      options,
      id: create_fragment20.name
    });
  }
  get meshes() {
    throw new Error("<InstancedMeshes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meshes(value) {
    throw new Error("<InstancedMeshes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMeshes_default = InstancedMeshes;

// node_modules/@threlte/extras/dist/components/SoftShadows/SoftShadows.svelte
function create_fragment21(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let pcss;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SoftShadows", slots, []);
  const { renderer, camera, scene } = useThrelte();
  let { size = 25 } = $$props;
  let { focus = 0 } = $$props;
  let { samples = 10 } = $$props;
  const original = ShaderChunk.shadowmap_pars_fragment;
  const onUpdate = () => {
    ShaderChunk.shadowmap_pars_fragment = original.replace("#ifdef USE_SHADOWMAP", "#ifdef USE_SHADOWMAP\n" + pcss).replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    recompile();
  };
  const recompile = () => {
    scene.traverse((o) => {
      var _a, _b;
      const object = o;
      if (object.material) {
        renderer == null ? void 0 : renderer.properties.remove(object.material);
        (_b = (_a = object.material).dispose) == null ? void 0 : _b.call(_a);
      }
    });
    if (renderer == null ? void 0 : renderer.info.programs) renderer.info.programs.length = 0;
    renderer == null ? void 0 : renderer.compile(scene, camera.current);
  };
  onDestroy(() => {
    ShaderChunk.shadowmap_pars_fragment = original;
    recompile();
  });
  const writable_props = ["size", "focus", "samples"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SoftShadows> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2) $$invalidate(0, size = $$props2.size);
    if ("focus" in $$props2) $$invalidate(1, focus = $$props2.focus);
    if ("samples" in $$props2) $$invalidate(2, samples = $$props2.samples);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    onDestroy,
    ShaderChunk,
    renderer,
    camera,
    scene,
    size,
    focus,
    samples,
    original,
    onUpdate,
    recompile,
    pcss
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2) $$invalidate(0, size = $$props2.size);
    if ("focus" in $$props2) $$invalidate(1, focus = $$props2.focus);
    if ("samples" in $$props2) $$invalidate(2, samples = $$props2.samples);
    if ("pcss" in $$props2) $$invalidate(3, pcss = $$props2.pcss);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size, focus, samples*/
    7) {
      $: $$invalidate(3, pcss = `
		#define PENUMBRA_FILTER_SIZE float(${size})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${focus});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${samples}; i ++) {
				offset = (vogelDiskSample(j, ${samples}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${samples}; i++) {
				vogelSample = vogelDiskSample(j, ${samples}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${size}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${samples}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`);
    }
    if ($$self.$$.dirty & /*pcss*/
    8) {
      $: pcss, onUpdate();
    }
  };
  return [size, focus, samples, pcss];
}
var SoftShadows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { size: 0, focus: 1, samples: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SoftShadows",
      options,
      id: create_fragment21.name
    });
  }
  get size() {
    throw new Error("<SoftShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SoftShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<SoftShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<SoftShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get samples() {
    throw new Error("<SoftShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set samples(value) {
    throw new Error("<SoftShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SoftShadows_default = SoftShadows;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineGeometry.svelte
var get_default_slot_changes14 = (dirty) => ({});
var get_default_slot_context14 = (ctx) => ({ ref: (
  /*geometry*/
  ctx[1]
) });
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context14
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: "(95:0) <T   is={geometry}   bind:this={$component}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*geometry*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[8](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*geometry, $$restProps*/
      10 ? get_spread_update(t_spread_levels, [
        dirty & /*geometry*/
        2 && { is: (
          /*geometry*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      512) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = ["points", "shape", "shapeFunction"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeshLineGeometry", slots, ["default"]);
  let { points = [] } = $$props;
  let { shape = "none" } = $$props;
  let { shapeFunction = (p) => 1 } = $$props;
  let pointCount = points.length;
  const { invalidate } = useThrelte();
  const positions = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const previous = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const next = new BufferAttribute(new Float32Array(pointCount * 6), 3);
  const counters = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const side = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const width = new BufferAttribute(new Float32Array(pointCount * 2), 1);
  const uv = new BufferAttribute(new Float32Array(pointCount * 4), 2);
  const indices = new BufferAttribute(new Uint16Array(pointCount * 6), 1);
  if (shape === "taper") {
    shapeFunction = (p) => 1 * Math.pow(4 * p * (1 - p), 1);
  }
  for (let i = 0, i2 = 0, i3 = 0, i4 = 0; i < pointCount; i += 1, i2 += 2, i3 += 4, i4 += 6) {
    counters.setX(i2, i / points.length);
    counters.setX(i2 + 1, i / points.length);
    side.setX(i2, 1);
    side.setX(i2 + 1, -1);
    const w = shape === "none" ? 1 : shapeFunction(i / (pointCount - 1));
    width.setX(i2, w);
    width.setX(i2 + 1, w);
    uv.setXYZW(i3, i / (pointCount - 1), 0, i / (pointCount - 1), 1);
    if (i < pointCount - 1) {
      const n2 = i * 2;
      indices.setX(i4 + 0, n2 + 0);
      indices.setX(i4 + 1, n2 + 1);
      indices.setX(i4 + 2, n2 + 2);
      indices.setX(i4 + 3, n2 + 2);
      indices.setX(i4 + 4, n2 + 1);
      indices.setX(i4 + 5, n2 + 3);
    }
  }
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", positions);
  geometry.setAttribute("previous", previous);
  geometry.setAttribute("next", next);
  geometry.setAttribute("counters", counters);
  geometry.setAttribute("side", side);
  geometry.setAttribute("width", width);
  geometry.setAttribute("uv", uv);
  geometry.setIndex(indices);
  const setPoints = (points2) => {
    if (points2.length === 0) return;
    if (points2.length !== pointCount) return;
    let positionIndex = 0;
    let previousIndex = 0;
    let nextIndex = 0;
    const p1 = points2[0];
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    previous.setXYZ(previousIndex, p1.x, p1.y, p1.z);
    previousIndex += 1;
    for (let i = 0; i < pointCount; i++) {
      const p = points2[i];
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      positions.setXYZ(positionIndex, p.x, p.y, p.z);
      positionIndex += 1;
      if (i < pointCount - 1) {
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
        previous.setXYZ(previousIndex, p.x, p.y, p.z);
        previousIndex += 1;
      }
      if (i > 0 && i + 1 <= pointCount) {
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
        next.setXYZ(nextIndex, p.x, p.y, p.z);
        nextIndex += 1;
      }
    }
    const p2 = points2[pointCount - 1];
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    next.setXYZ(nextIndex, p2.x, p2.y, p2.z);
    nextIndex += 1;
    positions.needsUpdate = true;
    previous.needsUpdate = true;
    next.needsUpdate = true;
    geometry.computeBoundingSphere();
    invalidate();
  };
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(0, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("points" in $$new_props) $$invalidate(5, points = $$new_props.points);
    if ("shape" in $$new_props) $$invalidate(6, shape = $$new_props.shape);
    if ("shapeFunction" in $$new_props) $$invalidate(4, shapeFunction = $$new_props.shapeFunction);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useThrelte,
    forwardEventHandlers,
    BufferGeometry,
    Vector3,
    BufferAttribute,
    points,
    shape,
    shapeFunction,
    pointCount,
    invalidate,
    positions,
    previous,
    next,
    counters,
    side,
    width,
    uv,
    indices,
    geometry,
    setPoints,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("points" in $$props) $$invalidate(5, points = $$new_props.points);
    if ("shape" in $$props) $$invalidate(6, shape = $$new_props.shape);
    if ("shapeFunction" in $$props) $$invalidate(4, shapeFunction = $$new_props.shapeFunction);
    if ("pointCount" in $$props) pointCount = $$new_props.pointCount;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*points*/
    32) {
      $: setPoints(points);
    }
  };
  return [
    $component,
    geometry,
    component,
    $$restProps,
    shapeFunction,
    points,
    shape,
    slots,
    t_binding,
    $$scope
  ];
}
var MeshLineGeometry = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { points: 5, shape: 6, shapeFunction: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeshLineGeometry",
      options,
      id: create_fragment22.name
    });
  }
  get points() {
    throw new Error("<MeshLineGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<MeshLineGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<MeshLineGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<MeshLineGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shapeFunction() {
    throw new Error("<MeshLineGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shapeFunction(value) {
    throw new Error("<MeshLineGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeshLineGeometry_default = MeshLineGeometry;

// node_modules/@threlte/extras/dist/components/MeshLine/fragment.js
var fragmentShader3 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

void main()	{
	#include <logdepthbuf_fragment>
	#include <${revision2 < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = LinearTosRGB(c);
}
`;

// node_modules/@threlte/extras/dist/components/MeshLine/vertex.js
var vertexShader3 = `
	  #include <common>
    ${ShaderChunk.logdepthbuf_pars_vertex}
    ${ShaderChunk.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${ShaderChunk.logdepthbuf_vertex}
        ${ShaderChunk.fog_vertex}
    }
`;

// node_modules/@threlte/extras/dist/components/MeshLine/MeshLineMaterial.svelte
var get_default_slot_changes15 = (dirty) => ({});
var get_default_slot_context15 = (ctx) => ({ ref: (
  /*material*/
  ctx[2]
) });
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context15
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: "(47:0) <T   is={material}   bind:this={$component}   {...$$restProps}   {fragmentShader}   {vertexShader} >",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*material*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[4],
    { fragmentShader: fragmentShader3 },
    { vertexShader: vertexShader3 }
  ];
  let t_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[17](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*material, $$restProps*/
      20 ? get_spread_update(t_spread_levels, [
        dirty & /*material*/
        4 && { is: (
          /*material*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        t_spread_levels[2],
        t_spread_levels[3]
      ]) : {};
      if (dirty & /*$$scope*/
      262144) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[17](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "opacity",
    "color",
    "dashOffset",
    "dashArray",
    "dashRatio",
    "attenuate",
    "width",
    "scaleDown",
    "alphaMap"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $size;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeshLineMaterial", slots, ["default"]);
  let { opacity = 1 } = $$props;
  let { color = "#ffffff" } = $$props;
  let { dashOffset = 0 } = $$props;
  let { dashArray = 0 } = $$props;
  let { dashRatio = 0 } = $$props;
  let { attenuate = true } = $$props;
  let { width = 1 } = $$props;
  let { scaleDown = 0 } = $$props;
  let { alphaMap = void 0 } = $$props;
  let { invalidate, size } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(15, $size = value));
  const uniforms = {
    lineWidth: { value: width },
    color: { value: new Color(color) },
    opacity: { value: opacity },
    resolution: { value: new Vector2(1, 1) },
    sizeAttenuation: { value: attenuate ? 1 : 0 },
    dashArray: { value: dashArray },
    dashOffset: { value: dashOffset },
    dashRatio: { value: dashRatio },
    useDash: { value: dashArray > 0 ? 1 : 0 },
    scaleDown: { value: scaleDown / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: alphaMap },
    useAlphaMap: { value: alphaMap ? 1 : 0 }
  };
  const material = new ShaderMaterial({ uniforms });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(0, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("opacity" in $$new_props) $$invalidate(5, opacity = $$new_props.opacity);
    if ("color" in $$new_props) $$invalidate(6, color = $$new_props.color);
    if ("dashOffset" in $$new_props) $$invalidate(7, dashOffset = $$new_props.dashOffset);
    if ("dashArray" in $$new_props) $$invalidate(8, dashArray = $$new_props.dashArray);
    if ("dashRatio" in $$new_props) $$invalidate(9, dashRatio = $$new_props.dashRatio);
    if ("attenuate" in $$new_props) $$invalidate(10, attenuate = $$new_props.attenuate);
    if ("width" in $$new_props) $$invalidate(11, width = $$new_props.width);
    if ("scaleDown" in $$new_props) $$invalidate(12, scaleDown = $$new_props.scaleDown);
    if ("alphaMap" in $$new_props) $$invalidate(13, alphaMap = $$new_props.alphaMap);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useThrelte,
    forwardEventHandlers,
    ShaderMaterial,
    Color,
    Vector2,
    fragmentShader: fragmentShader3,
    vertexShader: vertexShader3,
    opacity,
    color,
    dashOffset,
    dashArray,
    dashRatio,
    attenuate,
    width,
    scaleDown,
    alphaMap,
    invalidate,
    size,
    uniforms,
    material,
    component,
    $size,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("opacity" in $$props) $$invalidate(5, opacity = $$new_props.opacity);
    if ("color" in $$props) $$invalidate(6, color = $$new_props.color);
    if ("dashOffset" in $$props) $$invalidate(7, dashOffset = $$new_props.dashOffset);
    if ("dashArray" in $$props) $$invalidate(8, dashArray = $$new_props.dashArray);
    if ("dashRatio" in $$props) $$invalidate(9, dashRatio = $$new_props.dashRatio);
    if ("attenuate" in $$props) $$invalidate(10, attenuate = $$new_props.attenuate);
    if ("width" in $$props) $$invalidate(11, width = $$new_props.width);
    if ("scaleDown" in $$props) $$invalidate(12, scaleDown = $$new_props.scaleDown);
    if ("alphaMap" in $$props) $$invalidate(13, alphaMap = $$new_props.alphaMap);
    if ("invalidate" in $$props) $$invalidate(19, invalidate = $$new_props.invalidate);
    if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dashRatio, dashArray, dashOffset, width, opacity, uniforms, color*/
    19424) {
      $: {
        $$invalidate(14, uniforms.dashRatio.value = dashRatio, uniforms);
        $$invalidate(14, uniforms.dashArray.value = dashArray, uniforms);
        $$invalidate(14, uniforms.dashOffset.value = dashOffset, uniforms);
        $$invalidate(14, uniforms.lineWidth.value = width, uniforms);
        $$invalidate(14, uniforms.opacity.value = opacity, uniforms);
        uniforms.color.value.set(color);
        invalidate();
      }
    }
    if ($$self.$$.dirty & /*uniforms, $size*/
    49152) {
      $: {
        uniforms.resolution.value.set($size.width, $size.height);
        invalidate();
      }
    }
  };
  return [
    $component,
    size,
    material,
    component,
    $$restProps,
    opacity,
    color,
    dashOffset,
    dashArray,
    dashRatio,
    attenuate,
    width,
    scaleDown,
    alphaMap,
    uniforms,
    $size,
    slots,
    t_binding,
    $$scope
  ];
}
var MeshLineMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      opacity: 5,
      color: 6,
      dashOffset: 7,
      dashArray: 8,
      dashRatio: 9,
      attenuate: 10,
      width: 11,
      scaleDown: 12,
      alphaMap: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeshLineMaterial",
      options,
      id: create_fragment23.name
    });
  }
  get opacity() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashRatio() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashRatio(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attenuate() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attenuate(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleDown() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleDown(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alphaMap() {
    throw new Error("<MeshLineMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alphaMap(value) {
    throw new Error("<MeshLineMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeshLineMaterial_default = MeshLineMaterial;

// node_modules/three/examples/jsm/objects/Sky.js
var Sky = class _Sky extends Mesh {
  constructor() {
    const shader = _Sky.SkyShader;
    const material = new ShaderMaterial({
      name: shader.name,
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      depthWrite: false
    });
    super(new BoxGeometry(1, 1, 1), material);
    this.isSky = true;
  }
};
Sky.SkyShader = {
  name: "SkyShader",
  uniforms: {
    "turbidity": { value: 2 },
    "rayleigh": { value: 1 },
    "mieCoefficient": { value: 5e-3 },
    "mieDirectionalG": { value: 0.8 },
    "sunPosition": { value: new Vector3() },
    "up": { value: new Vector3(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};

// node_modules/@threlte/extras/dist/components/Sky/Sky.svelte
var { console: console_13 } = globals;
var get_default_slot_changes16 = (dirty) => ({ renderTarget: dirty & /*renderTarget*/
1 });
var get_default_slot_context16 = (ctx) => ({
  sunPosition: (
    /*sunPosition*/
    ctx[2]
  ),
  renderTarget: (
    /*renderTarget*/
    ctx[0]
  )
});
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context16
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, renderTarget*/
        16385)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes16
            ),
            get_default_slot_context16
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: "(90:0) <T is={sky}>",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*sky*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = {};
      if (dirty & /*$$scope, renderTarget*/
      16385) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sky", slots, ["default"]);
  let { scale = 1e3 } = $$props;
  let { turbidity = 10 } = $$props;
  let { rayleigh = 3 } = $$props;
  let { mieCoefficient = 5e-3 } = $$props;
  let { mieDirectionalG = 0.7 } = $$props;
  let { elevation = 2 } = $$props;
  let { azimuth = 180 } = $$props;
  let { setEnvironment = true } = $$props;
  let { cubeMapSize = 128 } = $$props;
  let { webGLRenderTargetOptions = {} } = $$props;
  const sky = new Sky();
  const sunPosition = new Vector3();
  const uniforms = sky.material.uniforms;
  const { renderer, scene, invalidate } = useThrelte();
  let renderTarget;
  let cubeCamera;
  const init2 = () => {
    $$invalidate(0, renderTarget = new WebGLCubeRenderTarget(
      cubeMapSize,
      {
        type: HalfFloatType,
        generateMipmaps: true,
        minFilter: LinearMipmapLinearFilter,
        ...webGLRenderTargetOptions
      }
    ));
    cubeCamera = new CubeCamera(1, 1.1, renderTarget);
  };
  const originalEnvironment = scene.environment;
  const { start: scheduleUpdate, stop } = useTask(
    () => {
      sky.scale.setScalar(scale);
      uniforms.turbidity.value = turbidity;
      uniforms.rayleigh.value = rayleigh;
      uniforms.mieCoefficient.value = mieCoefficient;
      uniforms.mieDirectionalG.value = mieDirectionalG;
      const phi = MathUtils.degToRad(90 - elevation);
      const theta = MathUtils.degToRad(azimuth);
      sunPosition.setFromSphericalCoords(1, phi, theta);
      uniforms.sunPosition.value.copy(sunPosition);
      if (setEnvironment) {
        if (!renderTarget || !cubeCamera) init2();
        cubeCamera == null ? void 0 : cubeCamera.update(renderer, sky);
      }
      invalidate();
      stop();
    },
    { autoStart: false, autoInvalidate: false }
  );
  onDestroy(() => {
    sky.material.dispose();
    scene.environment = originalEnvironment;
    try {
      renderTarget == null ? void 0 : renderTarget.dispose();
    } catch (error) {
      console.warn("Could not dispose renderTarget:", error);
    }
  });
  const writable_props = [
    "scale",
    "turbidity",
    "rayleigh",
    "mieCoefficient",
    "mieDirectionalG",
    "elevation",
    "azimuth",
    "setEnvironment",
    "cubeMapSize",
    "webGLRenderTargetOptions"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_13.warn(`<Sky> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("scale" in $$props2) $$invalidate(3, scale = $$props2.scale);
    if ("turbidity" in $$props2) $$invalidate(4, turbidity = $$props2.turbidity);
    if ("rayleigh" in $$props2) $$invalidate(5, rayleigh = $$props2.rayleigh);
    if ("mieCoefficient" in $$props2) $$invalidate(6, mieCoefficient = $$props2.mieCoefficient);
    if ("mieDirectionalG" in $$props2) $$invalidate(7, mieDirectionalG = $$props2.mieDirectionalG);
    if ("elevation" in $$props2) $$invalidate(8, elevation = $$props2.elevation);
    if ("azimuth" in $$props2) $$invalidate(9, azimuth = $$props2.azimuth);
    if ("setEnvironment" in $$props2) $$invalidate(10, setEnvironment = $$props2.setEnvironment);
    if ("cubeMapSize" in $$props2) $$invalidate(11, cubeMapSize = $$props2.cubeMapSize);
    if ("webGLRenderTargetOptions" in $$props2) $$invalidate(12, webGLRenderTargetOptions = $$props2.webGLRenderTargetOptions);
    if ("$$scope" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useTask,
    useThrelte,
    onDestroy,
    CubeCamera,
    HalfFloatType,
    LinearMipmapLinearFilter,
    MathUtils,
    Vector3,
    WebGLCubeRenderTarget,
    Sky,
    scale,
    turbidity,
    rayleigh,
    mieCoefficient,
    mieDirectionalG,
    elevation,
    azimuth,
    setEnvironment,
    cubeMapSize,
    webGLRenderTargetOptions,
    sky,
    sunPosition,
    uniforms,
    renderer,
    scene,
    invalidate,
    renderTarget,
    cubeCamera,
    init: init2,
    originalEnvironment,
    scheduleUpdate,
    stop
  });
  $$self.$inject_state = ($$props2) => {
    if ("scale" in $$props2) $$invalidate(3, scale = $$props2.scale);
    if ("turbidity" in $$props2) $$invalidate(4, turbidity = $$props2.turbidity);
    if ("rayleigh" in $$props2) $$invalidate(5, rayleigh = $$props2.rayleigh);
    if ("mieCoefficient" in $$props2) $$invalidate(6, mieCoefficient = $$props2.mieCoefficient);
    if ("mieDirectionalG" in $$props2) $$invalidate(7, mieDirectionalG = $$props2.mieDirectionalG);
    if ("elevation" in $$props2) $$invalidate(8, elevation = $$props2.elevation);
    if ("azimuth" in $$props2) $$invalidate(9, azimuth = $$props2.azimuth);
    if ("setEnvironment" in $$props2) $$invalidate(10, setEnvironment = $$props2.setEnvironment);
    if ("cubeMapSize" in $$props2) $$invalidate(11, cubeMapSize = $$props2.cubeMapSize);
    if ("webGLRenderTargetOptions" in $$props2) $$invalidate(12, webGLRenderTargetOptions = $$props2.webGLRenderTargetOptions);
    if ("renderTarget" in $$props2) $$invalidate(0, renderTarget = $$props2.renderTarget);
    if ("cubeCamera" in $$props2) cubeCamera = $$props2.cubeCamera;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*setEnvironment, renderTarget*/
    1025) {
      $: if (setEnvironment && renderTarget) {
        scene.environment = renderTarget.texture;
        invalidate();
      } else if (!setEnvironment) {
        scene.environment = originalEnvironment;
        invalidate();
      }
    }
    if ($$self.$$.dirty & /*scale, turbidity, rayleigh, mieCoefficient, mieDirectionalG, elevation, azimuth*/
    1016) {
      $: scale, turbidity, rayleigh, mieCoefficient, mieDirectionalG, elevation, azimuth, scheduleUpdate();
    }
  };
  return [
    renderTarget,
    sky,
    sunPosition,
    scale,
    turbidity,
    rayleigh,
    mieCoefficient,
    mieDirectionalG,
    elevation,
    azimuth,
    setEnvironment,
    cubeMapSize,
    webGLRenderTargetOptions,
    slots,
    $$scope
  ];
}
var Sky_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      scale: 3,
      turbidity: 4,
      rayleigh: 5,
      mieCoefficient: 6,
      mieDirectionalG: 7,
      elevation: 8,
      azimuth: 9,
      setEnvironment: 10,
      cubeMapSize: 11,
      webGLRenderTargetOptions: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sky_1",
      options,
      id: create_fragment24.name
    });
  }
  get scale() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get turbidity() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set turbidity(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rayleigh() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rayleigh(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mieCoefficient() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mieCoefficient(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mieDirectionalG() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mieDirectionalG(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elevation() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elevation(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get azimuth() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set azimuth(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setEnvironment() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setEnvironment(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cubeMapSize() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cubeMapSize(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get webGLRenderTargetOptions() {
    throw new Error("<Sky>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set webGLRenderTargetOptions(value) {
    throw new Error("<Sky>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sky_default = Sky_1;

// node_modules/@threlte/extras/dist/components/Align/alignPlugin.js
var isObject3D = (object) => object.isObject3D;
var injectAlignPlugin = (align) => {
  injectPlugin("align-plugin", ({ ref }) => {
    if (!isObject3D(ref))
      return;
    onMount(() => {
      align();
      return align;
    });
    const waitForTickAndAlign = async () => {
      await tick();
      align();
    };
    return {
      onRefChange() {
        waitForTickAndAlign();
      }
    };
  });
};

// node_modules/@threlte/extras/dist/components/Align/Align.svelte
var get_default_slot_changes17 = (dirty) => ({ ref: dirty & /*ref*/
2097152 });
var get_default_slot_context17 = (ctx) => ({
  align: (
    /*scheduleAligning*/
    ctx[4]
  ),
  ref: (
    /*ref*/
    ctx[21]
  )
});
function create_default_slot_22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context17
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        2228224)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes17
            ),
            get_default_slot_context17
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(93:4) <T is={innerGroup}>",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*innerGroup*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$$scope, ref*/
      2228224) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(92:2) <T is={outerGroup}>",
    ctx
  });
  return block;
}
function create_default_slot20(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*outerGroup*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$$scope, ref*/
      2228224) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(86:0) <T   is={containerGroup}   {...$$restProps}   bind:this={$component}   let:ref >",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*containerGroup*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let t_props = {
    $$slots: {
      default: [
        create_default_slot20,
        ({ ref }) => ({ 21: ref }),
        ({ ref }) => ref ? 2097152 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[16](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*containerGroup, $$restProps*/
      66 ? get_spread_update(t_spread_levels, [
        dirty & /*containerGroup*/
        2 && { is: (
          /*containerGroup*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      2228224) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[16](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  const omit_props_names = ["x", "y", "z", "precise", "auto", "calculate", "align"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Align", slots, ["default"]);
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { z = 0 } = $$props;
  let { precise = false } = $$props;
  let { auto = false } = $$props;
  const dispatch = createRawEventDispatcher();
  const { invalidate } = useThrelte();
  const containerGroup = new Group();
  const innerGroup = new Group();
  const outerGroup = new Group();
  let mounted = false;
  onMount(() => {
    $$invalidate(14, mounted = true);
  });
  const calculate = () => {
    if (!mounted) return;
    if (x === false && y === false && z === false) return;
    outerGroup.matrixWorld.identity();
    const box3 = new Box3().setFromObject(innerGroup, precise);
    const align2 = new Vector3();
    const sphere = new Sphere();
    const width = box3.max.x - box3.min.x;
    const height = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    box3.getCenter(align2);
    box3.getBoundingSphere(sphere);
    const vAlign = (y || 0) * height / 2;
    const hAlign = (x || 0) * width / 2;
    const dAlign = (z || 0) * depth / 2;
    outerGroup.position.set(x === false ? 0 : -align2.x + hAlign, y === false ? 0 : -align2.y + vAlign, z === false ? 0 : -align2.z + dAlign);
    const eventData = {
      boundingBox: box3,
      center: outerGroup.position.clone(),
      boundingSphere: sphere,
      container: containerGroup,
      depth,
      depthAlignment: dAlign,
      height,
      verticalAlignment: vAlign,
      width,
      horizontalAlignment: hAlign
    };
    dispatch("align", eventData);
  };
  const { start: scheduleAligning, stop } = useTask(
    () => {
      calculate();
      invalidate();
      stop();
    },
    { autoStart: false, autoInvalidate: false }
  );
  const align = () => {
    scheduleAligning();
  };
  if (auto) injectAlignPlugin(scheduleAligning);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(0, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("x" in $$new_props) $$invalidate(7, x = $$new_props.x);
    if ("y" in $$new_props) $$invalidate(8, y = $$new_props.y);
    if ("z" in $$new_props) $$invalidate(9, z = $$new_props.z);
    if ("precise" in $$new_props) $$invalidate(10, precise = $$new_props.precise);
    if ("auto" in $$new_props) $$invalidate(11, auto = $$new_props.auto);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    createRawEventDispatcher,
    forwardEventHandlers,
    useTask,
    useThrelte,
    onMount,
    Box3,
    Group,
    Sphere,
    Vector3,
    injectAlignPlugin,
    x,
    y,
    z,
    precise,
    auto,
    dispatch,
    invalidate,
    containerGroup,
    innerGroup,
    outerGroup,
    mounted,
    calculate,
    scheduleAligning,
    stop,
    align,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("x" in $$props) $$invalidate(7, x = $$new_props.x);
    if ("y" in $$props) $$invalidate(8, y = $$new_props.y);
    if ("z" in $$props) $$invalidate(9, z = $$new_props.z);
    if ("precise" in $$props) $$invalidate(10, precise = $$new_props.precise);
    if ("auto" in $$props) $$invalidate(11, auto = $$new_props.auto);
    if ("mounted" in $$props) $$invalidate(14, mounted = $$new_props.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*mounted, x, y, z, precise*/
    18304) {
      $: mounted === true && x, y, z, precise, scheduleAligning();
    }
  };
  return [
    $component,
    containerGroup,
    innerGroup,
    outerGroup,
    scheduleAligning,
    component,
    $$restProps,
    x,
    y,
    z,
    precise,
    auto,
    calculate,
    align,
    mounted,
    slots,
    t_binding,
    $$scope
  ];
}
var Align = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      x: 7,
      y: 8,
      z: 9,
      precise: 10,
      auto: 11,
      calculate: 12,
      align: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Align",
      options,
      id: create_fragment25.name
    });
  }
  get x() {
    throw new Error("<Align>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Align>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get z() {
    throw new Error("<Align>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set z(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get precise() {
    throw new Error("<Align>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set precise(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get auto() {
    throw new Error("<Align>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set auto(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calculate() {
    return this.$$.ctx[12];
  }
  set calculate(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    return this.$$.ctx[13];
  }
  set align(value) {
    throw new Error("<Align>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Align_default = Align;

// node_modules/three/examples/jsm/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class _CSMFrustum {
  constructor(data) {
    data = data || {};
    this.zNear = data.webGL === true ? -1 : 0;
    this.vertices = {
      near: [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ],
      far: [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const zNear = this.zNear;
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, zNear);
    this.vertices.near[1].set(1, -1, zNear);
    this.vertices.near[2].set(-1, -1, zNear);
    this.vertices.near[3].set(-1, 1, zNear);
    this.vertices.near.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v.z);
      if (isOrthographic) {
        v.z *= Math.min(maxFar / absZ, 1);
      } else {
        v.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new _CSMFrustum());
    }
    target.length = breaks.length;
    for (let i = 0; i < breaks.length; i++) {
      const cascade = target[i];
      if (i === 0) {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.near[j].copy(this.vertices.near[j]);
        }
      } else {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);
        }
      }
      if (i === breaks.length - 1) {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.far[j].copy(this.vertices.far[j]);
        }
      } else {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i = 0; i < 4; i++) {
      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);
      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/three/examples/jsm/csm/CSMShader.js
var CSMShader = {
  lights_fragment_begin: (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
  )
};

// node_modules/three/examples/jsm/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum({ webGL: true });
var _center = new Vector3();
var _bbox = new Box3();
var _uniformArray = [];
var _logArray = [];
var _lightOrientationMatrix = new Matrix4();
var _lightOrientationMatrixInverse = new Matrix4();
var _up = new Vector3(0, 1, 0);
var CSM = class {
  constructor(data) {
    this.camera = data.camera;
    this.parent = data.parent;
    this.cascades = data.cascades || 3;
    this.maxFar = data.maxFar || 1e5;
    this.mode = data.mode || "practical";
    this.shadowMapSize = data.shadowMapSize || 2048;
    this.shadowBias = data.shadowBias || 1e-6;
    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();
    this.lightIntensity = data.lightIntensity || 3;
    this.lightNear = data.lightNear || 1;
    this.lightFar = data.lightFar || 2e3;
    this.lightMargin = data.lightMargin || 200;
    this.customSplitsCallback = data.customSplitsCallback;
    this.fade = false;
    this.mainFrustum = new CSMFrustum({ webGL: true });
    this.frustums = [];
    this.breaks = [];
    this.lights = [];
    this.shaders = /* @__PURE__ */ new Map();
    this.createLights();
    this.updateFrustums();
    this.injectInclude();
  }
  createLights() {
    for (let i = 0; i < this.cascades; i++) {
      const light = new DirectionalLight(16777215, this.lightIntensity);
      light.castShadow = true;
      light.shadow.mapSize.width = this.shadowMapSize;
      light.shadow.mapSize.height = this.shadowMapSize;
      light.shadow.camera.near = this.lightNear;
      light.shadow.camera.far = this.lightFar;
      light.shadow.bias = this.shadowBias;
      this.parent.add(light);
      this.parent.add(light.target);
      this.lights.push(light);
    }
  }
  initCascades() {
    const camera = this.camera;
    camera.updateProjectionMatrix();
    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);
    this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const frustums = this.frustums;
    for (let i = 0; i < frustums.length; i++) {
      const light = this.lights[i];
      const shadowCam = light.shadow.camera;
      const frustum = this.frustums[i];
      const nearVerts = frustum.vertices.near;
      const farVerts = frustum.vertices.far;
      const point1 = farVerts[0];
      let point2;
      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
        point2 = farVerts[2];
      } else {
        point2 = nearVerts[2];
      }
      let squaredBBWidth = point1.distanceTo(point2);
      if (this.fade) {
        const camera = this.camera;
        const far = Math.max(camera.far, this.maxFar);
        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);
        const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);
        squaredBBWidth += margin;
      }
      shadowCam.left = -squaredBBWidth / 2;
      shadowCam.right = squaredBBWidth / 2;
      shadowCam.top = squaredBBWidth / 2;
      shadowCam.bottom = -squaredBBWidth / 2;
      shadowCam.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const camera = this.camera;
    const far = Math.min(camera.far, this.maxFar);
    this.breaks.length = 0;
    switch (this.mode) {
      case "uniform":
        uniformSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "logarithmic":
        logarithmicSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "practical":
        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);
        break;
      case "custom":
        if (this.customSplitsCallback === void 0) console.error("CSM: Custom split scheme callback not defined.");
        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);
        break;
    }
    function uniformSplit(amount, near, far2, target) {
      for (let i = 1; i < amount; i++) {
        target.push((near + (far2 - near) * i / amount) / far2);
      }
      target.push(1);
    }
    function logarithmicSplit(amount, near, far2, target) {
      for (let i = 1; i < amount; i++) {
        target.push(near * (far2 / near) ** (i / amount) / far2);
      }
      target.push(1);
    }
    function practicalSplit(amount, near, far2, lambda, target) {
      _uniformArray.length = 0;
      _logArray.length = 0;
      logarithmicSplit(amount, near, far2, _logArray);
      uniformSplit(amount, near, far2, _uniformArray);
      for (let i = 1; i < amount; i++) {
        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));
      }
      target.push(1);
    }
  }
  update() {
    const camera = this.camera;
    const frustums = this.frustums;
    _lightOrientationMatrix.lookAt(new Vector3(), this.lightDirection, _up);
    _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();
    for (let i = 0; i < frustums.length; i++) {
      const light = this.lights[i];
      const shadowCam = light.shadow.camera;
      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
      _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, camera.matrixWorld);
      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
      const nearVerts = _lightSpaceFrustum.vertices.near;
      const farVerts = _lightSpaceFrustum.vertices.far;
      _bbox.makeEmpty();
      for (let j = 0; j < 4; j++) {
        _bbox.expandByPoint(nearVerts[j]);
        _bbox.expandByPoint(farVerts[j]);
      }
      _bbox.getCenter(_center);
      _center.z = _bbox.max.z + this.lightMargin;
      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;
      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;
      _center.applyMatrix4(_lightOrientationMatrix);
      light.position.copy(_center);
      light.target.position.copy(_center);
      light.target.position.x += this.lightDirection.x;
      light.target.position.y += this.lightDirection.y;
      light.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;
    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;
  }
  setupMaterial(material) {
    material.defines = material.defines || {};
    material.defines.USE_CSM = 1;
    material.defines.CSM_CASCADES = this.cascades;
    if (this.fade) {
      material.defines.CSM_FADE = "";
    }
    const breaksVec2 = [];
    const scope = this;
    const shaders = this.shaders;
    material.onBeforeCompile = function(shader) {
      const far = Math.min(scope.camera.far, scope.maxFar);
      scope.getExtendedBreaks(breaksVec2);
      shader.uniforms.CSM_cascades = { value: breaksVec2 };
      shader.uniforms.cameraNear = { value: scope.camera.near };
      shader.uniforms.shadowFar = { value: far };
      shaders.set(material, shader);
    };
    shaders.set(material, null);
  }
  updateUniforms() {
    const far = Math.min(this.camera.far, this.maxFar);
    const shaders = this.shaders;
    shaders.forEach(function(shader, material) {
      if (shader !== null) {
        const uniforms = shader.uniforms;
        this.getExtendedBreaks(uniforms.CSM_cascades.value);
        uniforms.cameraNear.value = this.camera.near;
        uniforms.shadowFar.value = far;
      }
      if (!this.fade && "CSM_FADE" in material.defines) {
        delete material.defines.CSM_FADE;
        material.needsUpdate = true;
      } else if (this.fade && !("CSM_FADE" in material.defines)) {
        material.defines.CSM_FADE = "";
        material.needsUpdate = true;
      }
    }, this);
  }
  getExtendedBreaks(target) {
    while (target.length < this.breaks.length) {
      target.push(new Vector2());
    }
    target.length = this.breaks.length;
    for (let i = 0; i < this.cascades; i++) {
      const amount = this.breaks[i];
      const prev = this.breaks[i - 1] || 0;
      target[i].x = prev;
      target[i].y = amount;
    }
  }
  updateFrustums() {
    this.getBreaks();
    this.initCascades();
    this.updateShadowBounds();
    this.updateUniforms();
  }
  remove() {
    for (let i = 0; i < this.lights.length; i++) {
      this.parent.remove(this.lights[i].target);
      this.parent.remove(this.lights[i]);
    }
  }
  dispose() {
    const shaders = this.shaders;
    shaders.forEach(function(shader, material) {
      delete material.onBeforeCompile;
      delete material.defines.USE_CSM;
      delete material.defines.CSM_CASCADES;
      delete material.defines.CSM_FADE;
      if (shader !== null) {
        delete shader.uniforms.CSM_cascades;
        delete shader.uniforms.cameraNear;
        delete shader.uniforms.shadowFar;
      }
      material.needsUpdate = true;
    });
    shaders.clear();
  }
};

// node_modules/@threlte/extras/dist/components/CSM/useMaterials.js
var useMaterials = () => {
  let setupCallback = void 0;
  const allMaterials = /* @__PURE__ */ new Set();
  const isSupportedMaterial = (material) => {
    return material.isMeshStandardMaterial || material.isMeshPhongMaterial;
  };
  const isMesh = (ref) => {
    return ref.isMesh;
  };
  const addMaterial = (material) => {
    if (allMaterials.has(material))
      return;
    allMaterials.add(material);
    setupCallback == null ? void 0 : setupCallback(material);
  };
  const extractMaterials = (ref) => {
    if (isSupportedMaterial(ref)) {
      addMaterial(ref);
    } else if (isMesh(ref)) {
      if (Array.isArray(ref.material)) {
        ref.material.forEach((material) => {
          if (isSupportedMaterial(material)) {
            addMaterial(material);
          }
        });
      } else {
        if (isSupportedMaterial(ref.material)) {
          addMaterial(ref.material);
        }
      }
    }
  };
  const onNewMaterial = (callback) => {
    setupCallback = callback;
  };
  injectPlugin("csm", ({ ref }) => {
    onMount(() => {
      extractMaterials(ref);
    });
  });
  onDestroy(() => setupCallback = void 0);
  return { onNewMaterial, allMaterials };
};

// node_modules/@threlte/extras/dist/components/CSM/CSM.svelte
var get_disabled_slot_changes = (dirty) => ({});
var get_disabled_slot_context = (ctx) => ({});
function create_if_block7(ctx) {
  let current;
  const disabled_slot_template = (
    /*#slots*/
    ctx[10].disabled
  );
  const disabled_slot = create_slot(
    disabled_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_disabled_slot_context
  );
  const block = {
    c: function create() {
      if (disabled_slot) disabled_slot.c();
    },
    l: function claim(nodes) {
      if (disabled_slot) disabled_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (disabled_slot) {
        disabled_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (disabled_slot) {
        if (disabled_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            disabled_slot,
            disabled_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              disabled_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_disabled_slot_changes
            ),
            get_disabled_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(disabled_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disabled_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (disabled_slot) disabled_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(99:0) {#if !enabled}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let t2;
  let if_block_anchor;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block = !/*enabled*/
  ctx[0] && create_if_block7(ctx);
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
      t2 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!/*enabled*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*enabled*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $csm;
  let $defaultCamera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CSM", slots, ["default", "disabled"]);
  let { enabled = true } = $$props;
  let { args = {} } = $$props;
  let { camera = void 0 } = $$props;
  let { configure = void 0 } = $$props;
  let { lightIntensity = void 0 } = $$props;
  let { lightColor = void 0 } = $$props;
  let { lightDirection = [1, -1, 1] } = $$props;
  const enabledStore = writable(enabled);
  const { camera: defaultCamera, scene, size, useLegacyLights } = useThrelte();
  validate_store(defaultCamera, "defaultCamera");
  component_subscribe($$self, defaultCamera, (value) => $$invalidate(12, $defaultCamera = value));
  const csm = currentWritable(void 0);
  validate_store(csm, "csm");
  component_subscribe($$self, csm, (value) => $$invalidate(11, $csm = value));
  useTask(() => $csm == null ? void 0 : $csm.update(), { autoInvalidate: false });
  const { onNewMaterial, allMaterials } = useMaterials();
  const disposeCsm = () => {
    $csm == null ? void 0 : $csm.remove();
    $csm == null ? void 0 : $csm.dispose();
    set_store_value(csm, $csm = void 0, $csm);
  };
  watch([size, csm], ([_, csm2]) => {
    if (!csm2) return;
    csm2.updateFrustums();
  });
  const cameraStore = writable(camera);
  watch([defaultCamera, cameraStore, csm], ([defaultCamera2, camera2, csm2]) => {
    if (!csm2) return;
    csm2.camera = camera2 ?? defaultCamera2;
    if (args.maxFar !== void 0) csm2.maxFar = args.maxFar;
    if (args.mode !== void 0) csm2.mode = args.mode;
    csm2.updateFrustums();
  });
  watch(enabledStore, (enabled2) => {
    if (enabled2) {
      set_store_value(
        csm,
        $csm = new CSM({
          camera: camera ?? $defaultCamera,
          parent: scene,
          ...args
        }),
        $csm
      );
      configure == null ? void 0 : configure($csm);
      for (const material of allMaterials) {
        $csm.setupMaterial(material);
      }
      onNewMaterial((material) => $csm == null ? void 0 : $csm.setupMaterial(material));
    } else {
      onNewMaterial(void 0);
      disposeCsm();
    }
  });
  const lightIntensityStore = writable(lightIntensity);
  const lightColorStore = writable(lightColor);
  watch([csm, lightIntensityStore, lightColorStore, useLegacyLights], ([csm2, intensity, color, useLegacyLights2]) => {
    csm2 == null ? void 0 : csm2.lights.forEach((light) => {
      if (intensity !== void 0) {
        light.intensity = intensity / (useLegacyLights2 ? 1 : Math.PI);
      }
      if (color !== void 0) {
        light.color.set(color);
      }
    });
  });
  const lightDirectionStore = writable(lightDirection);
  watch([csm, lightDirectionStore], ([csm2, direction]) => {
    csm2 == null ? void 0 : csm2.lightDirection.set(...direction).normalize();
  });
  onDestroy(disposeCsm);
  const writable_props = [
    "enabled",
    "args",
    "camera",
    "configure",
    "lightIntensity",
    "lightColor",
    "lightDirection"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CSM> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("enabled" in $$props2) $$invalidate(0, enabled = $$props2.enabled);
    if ("args" in $$props2) $$invalidate(3, args = $$props2.args);
    if ("camera" in $$props2) $$invalidate(4, camera = $$props2.camera);
    if ("configure" in $$props2) $$invalidate(5, configure = $$props2.configure);
    if ("lightIntensity" in $$props2) $$invalidate(6, lightIntensity = $$props2.lightIntensity);
    if ("lightColor" in $$props2) $$invalidate(7, lightColor = $$props2.lightColor);
    if ("lightDirection" in $$props2) $$invalidate(8, lightDirection = $$props2.lightDirection);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    currentWritable,
    useTask,
    useThrelte,
    watch,
    onDestroy,
    writable,
    CSM,
    useMaterials,
    enabled,
    args,
    camera,
    configure,
    lightIntensity,
    lightColor,
    lightDirection,
    enabledStore,
    defaultCamera,
    scene,
    size,
    useLegacyLights,
    csm,
    onNewMaterial,
    allMaterials,
    disposeCsm,
    cameraStore,
    lightIntensityStore,
    lightColorStore,
    lightDirectionStore,
    $csm,
    $defaultCamera
  });
  $$self.$inject_state = ($$props2) => {
    if ("enabled" in $$props2) $$invalidate(0, enabled = $$props2.enabled);
    if ("args" in $$props2) $$invalidate(3, args = $$props2.args);
    if ("camera" in $$props2) $$invalidate(4, camera = $$props2.camera);
    if ("configure" in $$props2) $$invalidate(5, configure = $$props2.configure);
    if ("lightIntensity" in $$props2) $$invalidate(6, lightIntensity = $$props2.lightIntensity);
    if ("lightColor" in $$props2) $$invalidate(7, lightColor = $$props2.lightColor);
    if ("lightDirection" in $$props2) $$invalidate(8, lightDirection = $$props2.lightDirection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*enabled*/
    1) {
      $: enabledStore.set(enabled);
    }
    if ($$self.$$.dirty & /*camera*/
    16) {
      $: cameraStore.set(camera);
    }
    if ($$self.$$.dirty & /*lightIntensity*/
    64) {
      $: lightIntensityStore.set(lightIntensity);
    }
    if ($$self.$$.dirty & /*lightColor*/
    128) {
      $: lightColorStore.set(lightColor);
    }
    if ($$self.$$.dirty & /*lightDirection*/
    256) {
      $: lightDirectionStore.set(lightDirection);
    }
  };
  return [
    enabled,
    defaultCamera,
    csm,
    args,
    camera,
    configure,
    lightIntensity,
    lightColor,
    lightDirection,
    $$scope,
    slots
  ];
}
var CSM_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      enabled: 0,
      args: 3,
      camera: 4,
      configure: 5,
      lightIntensity: 6,
      lightColor: 7,
      lightDirection: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CSM_1",
      options,
      id: create_fragment26.name
    });
  }
  get enabled() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get args() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get camera() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set camera(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get configure() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set configure(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightIntensity() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightIntensity(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightColor() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightColor(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightDirection() {
    throw new Error("<CSM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightDirection(value) {
    throw new Error("<CSM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CSM_default = CSM_1;

// node_modules/@threlte/extras/dist/components/Billboard/Billboard.svelte
var get_default_slot_changes18 = (dirty) => ({ ref: dirty & /*localRef*/
1 });
var get_default_slot_context18 = (ctx) => ({ ref: (
  /*localRef*/
  ctx[0]
) });
function create_default_slot_17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context18
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, localRef*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes18
            ),
            get_default_slot_context18
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(42:2) <T.Group bind:ref={inner}>",
    ctx
  });
  return block;
}
function create_default_slot21(ctx) {
  let t_group;
  let updating_ref;
  let current;
  function t_group_ref_binding(value) {
    ctx[9](value);
  }
  let t_group_props = {
    $$slots: { default: [create_default_slot_17] },
    $$scope: { ctx }
  };
  if (
    /*inner*/
    ctx[1] !== void 0
  ) {
    t_group_props.ref = /*inner*/
    ctx[1];
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  binding_callbacks.push(() => bind(t_group, "ref", t_group_ref_binding));
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = {};
      if (dirty & /*$$scope, localRef*/
      2049) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*inner*/
      2) {
        updating_ref = true;
        t_group_changes.ref = /*inner*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: "(36:0) <T.Group   bind:ref={localRef}   matrixAutoUpdate={false}   matrixWorldAutoUpdate={false}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let t_group;
  let updating_ref;
  let current;
  const t_group_spread_levels = [
    { matrixAutoUpdate: false },
    { matrixWorldAutoUpdate: false },
    /*$$restProps*/
    ctx[3]
  ];
  function t_group_ref_binding_1(value) {
    ctx[10](value);
  }
  let t_group_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_group_spread_levels.length; i += 1) {
    t_group_props = assign(t_group_props, t_group_spread_levels[i]);
  }
  if (
    /*localRef*/
    ctx[0] !== void 0
  ) {
    t_group_props.ref = /*localRef*/
    ctx[0];
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  binding_callbacks.push(() => bind(t_group, "ref", t_group_ref_binding_1));
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_group_changes = dirty & /*$$restProps*/
      8 ? get_spread_update(t_group_spread_levels, [
        t_group_spread_levels[0],
        t_group_spread_levels[1],
        get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, inner, localRef*/
      2051) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*localRef*/
      1) {
        updating_ref = true;
        t_group_changes.ref = /*localRef*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = ["follow", "lockX", "lockY", "lockZ"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $camera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Billboard", slots, ["default"]);
  let { follow = true } = $$props;
  let { lockX = false } = $$props;
  let { lockY = false } = $$props;
  let { lockZ = false } = $$props;
  let inner;
  let localRef;
  const { camera } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(12, $camera = value));
  const q = new Quaternion();
  const prevRotation = new Euler();
  const { start, stop } = useTask(
    () => {
      prevRotation.copy(localRef.rotation);
      localRef.updateMatrix();
      localRef.updateWorldMatrix(false, false);
      localRef.getWorldQuaternion(q);
      $camera.getWorldQuaternion(inner.quaternion).premultiply(q.invert());
      if (lockX) $$invalidate(0, localRef.rotation.x = prevRotation.x, localRef);
      if (lockY) $$invalidate(0, localRef.rotation.y = prevRotation.y, localRef);
      if (lockZ) $$invalidate(0, localRef.rotation.z = prevRotation.z, localRef);
    },
    { autoStart: false }
  );
  function t_group_ref_binding(value) {
    inner = value;
    $$invalidate(1, inner);
  }
  function t_group_ref_binding_1(value) {
    localRef = value;
    $$invalidate(0, localRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("follow" in $$new_props) $$invalidate(4, follow = $$new_props.follow);
    if ("lockX" in $$new_props) $$invalidate(5, lockX = $$new_props.lockX);
    if ("lockY" in $$new_props) $$invalidate(6, lockY = $$new_props.lockY);
    if ("lockZ" in $$new_props) $$invalidate(7, lockZ = $$new_props.lockZ);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Euler,
    Group,
    Quaternion,
    T,
    useTask,
    useThrelte,
    follow,
    lockX,
    lockY,
    lockZ,
    inner,
    localRef,
    camera,
    q,
    prevRotation,
    start,
    stop,
    $camera
  });
  $$self.$inject_state = ($$new_props) => {
    if ("follow" in $$props) $$invalidate(4, follow = $$new_props.follow);
    if ("lockX" in $$props) $$invalidate(5, lockX = $$new_props.lockX);
    if ("lockY" in $$props) $$invalidate(6, lockY = $$new_props.lockY);
    if ("lockZ" in $$props) $$invalidate(7, lockZ = $$new_props.lockZ);
    if ("inner" in $$props) $$invalidate(1, inner = $$new_props.inner);
    if ("localRef" in $$props) $$invalidate(0, localRef = $$new_props.localRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*follow, localRef*/
    17) {
      $: if (follow && localRef) {
        start();
      } else {
        stop();
      }
    }
  };
  return [
    localRef,
    inner,
    camera,
    $$restProps,
    follow,
    lockX,
    lockY,
    lockZ,
    slots,
    t_group_ref_binding,
    t_group_ref_binding_1,
    $$scope
  ];
}
var Billboard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { follow: 4, lockX: 5, lockY: 6, lockZ: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Billboard",
      options,
      id: create_fragment27.name
    });
  }
  get follow() {
    throw new Error("<Billboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set follow(value) {
    throw new Error("<Billboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lockX() {
    throw new Error("<Billboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lockX(value) {
    throw new Error("<Billboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lockY() {
    throw new Error("<Billboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lockY(value) {
    throw new Error("<Billboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lockZ() {
    throw new Error("<Billboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lockZ(value) {
    throw new Error("<Billboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Billboard_default = Billboard;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/fragment.js
var fragmentShader4 = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/vertex.js
var vertexShader4 = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`;

// node_modules/@threlte/extras/dist/components/FakeGlowMaterial/FakeGlowMaterial.svelte
var get_default_slot_changes19 = (dirty) => ({ ref: dirty & /*material*/
1 });
var get_default_slot_context19 = (ctx) => ({ ref: (
  /*material*/
  ctx[0]
) });
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context19
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, material*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes19
            ),
            get_default_slot_context19
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: "(28:0) <T   is={material}   bind:this={$component}   {fragmentShader}   {vertexShader}   transparent={true}   blending={AdditiveBlending}   depthTest={false}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*material*/
      ctx[0]
    ) },
    { fragmentShader: fragmentShader4 },
    { vertexShader: vertexShader4 },
    { transparent: true },
    { blending: AdditiveBlending },
    { depthTest: false },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[9](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*material, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*material*/
        1 && { is: (
          /*material*/
          ctx2[0]
        ) },
        t_spread_levels[1],
        t_spread_levels[2],
        t_spread_levels[3],
        t_spread_levels[4],
        t_spread_levels[5],
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, material*/
      1025) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[9](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["falloff", "glowInternalRadius", "glowColor", "glowSharpness"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FakeGlowMaterial", slots, ["default"]);
  let { falloff = 0.1 } = $$props;
  let { glowInternalRadius = 6 } = $$props;
  let { glowColor = "green" } = $$props;
  let { glowSharpness = 1 } = $$props;
  let material = new ShaderMaterial({
    uniforms: {
      falloff: { value: falloff },
      glowInternalRadius: { value: glowInternalRadius },
      glowColor: { value: new Color(glowColor) },
      glowSharpness: { value: glowSharpness }
    }
  });
  let { invalidate } = useThrelte();
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("falloff" in $$new_props) $$invalidate(4, falloff = $$new_props.falloff);
    if ("glowInternalRadius" in $$new_props) $$invalidate(5, glowInternalRadius = $$new_props.glowInternalRadius);
    if ("glowColor" in $$new_props) $$invalidate(6, glowColor = $$new_props.glowColor);
    if ("glowSharpness" in $$new_props) $$invalidate(7, glowSharpness = $$new_props.glowSharpness);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useThrelte,
    forwardEventHandlers,
    Color,
    AdditiveBlending,
    ShaderMaterial,
    fragmentShader: fragmentShader4,
    vertexShader: vertexShader4,
    falloff,
    glowInternalRadius,
    glowColor,
    glowSharpness,
    material,
    invalidate,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("falloff" in $$props) $$invalidate(4, falloff = $$new_props.falloff);
    if ("glowInternalRadius" in $$props) $$invalidate(5, glowInternalRadius = $$new_props.glowInternalRadius);
    if ("glowColor" in $$props) $$invalidate(6, glowColor = $$new_props.glowColor);
    if ("glowSharpness" in $$props) $$invalidate(7, glowSharpness = $$new_props.glowSharpness);
    if ("material" in $$props) $$invalidate(0, material = $$new_props.material);
    if ("invalidate" in $$props) $$invalidate(11, invalidate = $$new_props.invalidate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*falloff, glowInternalRadius, glowColor, glowSharpness*/
    240) {
      $: {
        $$invalidate(0, material.uniforms.falloff.value = falloff, material);
        $$invalidate(0, material.uniforms.glowInternalRadius.value = glowInternalRadius, material);
        $$invalidate(0, material.uniforms.glowColor.value = new Color(glowColor), material);
        $$invalidate(0, material.uniforms.glowSharpness.value = glowSharpness, material);
        invalidate();
      }
    }
  };
  return [
    material,
    $component,
    component,
    $$restProps,
    falloff,
    glowInternalRadius,
    glowColor,
    glowSharpness,
    slots,
    t_binding,
    $$scope
  ];
}
var FakeGlowMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      falloff: 4,
      glowInternalRadius: 5,
      glowColor: 6,
      glowSharpness: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FakeGlowMaterial",
      options,
      id: create_fragment28.name
    });
  }
  get falloff() {
    throw new Error("<FakeGlowMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set falloff(value) {
    throw new Error("<FakeGlowMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get glowInternalRadius() {
    throw new Error("<FakeGlowMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set glowInternalRadius(value) {
    throw new Error("<FakeGlowMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get glowColor() {
    throw new Error("<FakeGlowMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set glowColor(value) {
    throw new Error("<FakeGlowMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get glowSharpness() {
    throw new Error("<FakeGlowMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set glowSharpness(value) {
    throw new Error("<FakeGlowMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FakeGlowMaterial_default = FakeGlowMaterial;

// node_modules/@threlte/extras/dist/components/Stars/fragment.js
var fragmentShader5 = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/Stars/vertex.js
var vertexShader5 = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;

// node_modules/@threlte/extras/dist/components/Stars/Stars.svelte
var get_default_slot_changes20 = (dirty) => ({ ref: dirty & /*ref*/
33554432 });
var get_default_slot_context20 = (ctx) => ({ ref: (
  /*ref*/
  ctx[25]
) });
function create_default_slot_18(ctx) {
  let t_bufferattribute0;
  let t0;
  let t_bufferattribute1;
  let t1;
  let t_bufferattribute2;
  let current;
  t_bufferattribute0 = new T.BufferAttribute({
    props: {
      attach: func2,
      args: [
        /*positionsArray*/
        ctx[2],
        3
      ]
    },
    $$inline: true
  });
  t_bufferattribute1 = new T.BufferAttribute({
    props: {
      attach: func_1,
      args: [
        /*colorsArray*/
        ctx[3],
        3
      ]
    },
    $$inline: true
  });
  t_bufferattribute2 = new T.BufferAttribute({
    props: {
      attach: func_2,
      args: [
        /*sizesArray*/
        ctx[4],
        1
      ]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_bufferattribute0.$$.fragment);
      t0 = space();
      create_component(t_bufferattribute1.$$.fragment);
      t1 = space();
      create_component(t_bufferattribute2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_bufferattribute0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_bufferattribute1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_bufferattribute2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_bufferattribute0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_bufferattribute1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_bufferattribute2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_bufferattribute0_changes = {};
      if (dirty & /*positionsArray*/
      4) t_bufferattribute0_changes.args = [
        /*positionsArray*/
        ctx2[2],
        3
      ];
      t_bufferattribute0.$set(t_bufferattribute0_changes);
      const t_bufferattribute1_changes = {};
      if (dirty & /*colorsArray*/
      8) t_bufferattribute1_changes.args = [
        /*colorsArray*/
        ctx2[3],
        3
      ];
      t_bufferattribute1.$set(t_bufferattribute1_changes);
      const t_bufferattribute2_changes = {};
      if (dirty & /*sizesArray*/
      16) t_bufferattribute2_changes.args = [
        /*sizesArray*/
        ctx2[4],
        1
      ];
      t_bufferattribute2.$set(t_bufferattribute2_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_bufferattribute0.$$.fragment, local);
      transition_in(t_bufferattribute1.$$.fragment, local);
      transition_in(t_bufferattribute2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_bufferattribute0.$$.fragment, local);
      transition_out(t_bufferattribute1.$$.fragment, local);
      transition_out(t_bufferattribute2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(t_bufferattribute0, detaching);
      destroy_component(t_bufferattribute1, detaching);
      destroy_component(t_bufferattribute2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: "(63:2) <T.BufferGeometry>",
    ctx
  });
  return block;
}
function create_default_slot23(ctx) {
  let t_buffergeometry;
  let t0;
  let t1;
  let t2;
  let current;
  t_buffergeometry = new T.BufferGeometry({
    props: {
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  t1 = new T({
    props: {
      is: (
        /*material*/
        ctx[8]
      ),
      blending: AdditiveBlending,
      "uniforms.fade.value": (
        /*fade*/
        ctx[0] ? 1 : 0
      ),
      "uniforms.time.value": (
        /*time*/
        ctx[5]
      ),
      "uniforms.opacity.value": (
        /*opacity*/
        ctx[1]
      ),
      depthWrite: false,
      transparent: true,
      vertexColors: true
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context20
  );
  const block = {
    c: function create() {
      create_component(t_buffergeometry.$$.fragment);
      t0 = space();
      create_component(t1.$$.fragment);
      t2 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_buffergeometry.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_buffergeometry, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_buffergeometry_changes = {};
      if (dirty & /*$$scope, sizesArray, colorsArray, positionsArray*/
      524316) {
        t_buffergeometry_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_buffergeometry.$set(t_buffergeometry_changes);
      const t1_changes = {};
      if (dirty & /*fade*/
      1) t1_changes["uniforms.fade.value"] = /*fade*/
      ctx2[0] ? 1 : 0;
      if (dirty & /*time*/
      32) t1_changes["uniforms.time.value"] = /*time*/
      ctx2[5];
      if (dirty & /*opacity*/
      2) t1_changes["uniforms.opacity.value"] = /*opacity*/
      ctx2[1];
      t1.$set(t1_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        34078720)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes20
            ),
            get_default_slot_context20
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_buffergeometry.$$.fragment, local);
      transition_in(t1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_buffergeometry.$$.fragment, local);
      transition_out(t1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t2);
      }
      destroy_component(t_buffergeometry, detaching);
      destroy_component(t1, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: "(58:0) <T.Points   bind:this={$component}   {...$$restProps}   let:ref >",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let t_points;
  let current;
  const t_points_spread_levels = [
    /*$$restProps*/
    ctx[9]
  ];
  let t_points_props = {
    $$slots: {
      default: [
        create_default_slot23,
        ({ ref }) => ({ 25: ref }),
        ({ ref }) => ref ? 33554432 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_points_spread_levels.length; i += 1) {
    t_points_props = assign(t_points_props, t_points_spread_levels[i]);
  }
  t_points = new T.Points({ props: t_points_props, $$inline: true });
  ctx[18](t_points);
  const block = {
    c: function create() {
      create_component(t_points.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_points.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_points, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_points_changes = dirty & /*$$restProps*/
      512 ? get_spread_update(t_points_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[9]
      )]) : {};
      if (dirty & /*$$scope, ref, fade, time, opacity, sizesArray, colorsArray, positionsArray*/
      34078783) {
        t_points_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_points.$set(t_points_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_points.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_points.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(t_points, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = (parent, self2) => {
  parent.setAttribute("position", self2);
  return () => {
  };
};
var func_1 = (parent, self2) => {
  parent.setAttribute("color", self2);
  return () => {
  };
};
var func_2 = (parent, self2) => {
  parent.setAttribute("size", self2);
  return () => {
  };
};
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "count",
    "radius",
    "depth",
    "factor",
    "saturation",
    "lightness",
    "speed",
    "fade",
    "opacity"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stars", slots, ["default"]);
  let { count = 5e3 } = $$props;
  let { radius = 50 } = $$props;
  let { depth = 50 } = $$props;
  let { factor = 6 } = $$props;
  let { saturation = 1 } = $$props;
  let { lightness = 0.8 } = $$props;
  let { speed = 1 } = $$props;
  let { fade = true } = $$props;
  let { opacity = 1 } = $$props;
  const vec3 = new Vector3();
  const spherical = new Spherical();
  const genStar = (r) => {
    return vec3.setFromSpherical(spherical.set(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  };
  let positionsArray;
  let colorsArray;
  let sizesArray;
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(6, $component = value));
  let time = 0;
  const { stop, start } = useTask(
    (dt) => {
      $$invalidate(5, time += dt * speed);
    },
    { autoStart: false }
  );
  const material = new ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      fade: { value: 1 },
      opacity: { value: 1 }
    },
    vertexShader: vertexShader5,
    fragmentShader: fragmentShader5
  });
  function t_points_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("count" in $$new_props) $$invalidate(10, count = $$new_props.count);
    if ("radius" in $$new_props) $$invalidate(11, radius = $$new_props.radius);
    if ("depth" in $$new_props) $$invalidate(12, depth = $$new_props.depth);
    if ("factor" in $$new_props) $$invalidate(13, factor = $$new_props.factor);
    if ("saturation" in $$new_props) $$invalidate(14, saturation = $$new_props.saturation);
    if ("lightness" in $$new_props) $$invalidate(15, lightness = $$new_props.lightness);
    if ("speed" in $$new_props) $$invalidate(16, speed = $$new_props.speed);
    if ("fade" in $$new_props) $$invalidate(0, fade = $$new_props.fade);
    if ("opacity" in $$new_props) $$invalidate(1, opacity = $$new_props.opacity);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    AdditiveBlending,
    Color,
    ShaderMaterial,
    Spherical,
    Vector3,
    T,
    forwardEventHandlers,
    useTask,
    fragmentShader: fragmentShader5,
    vertexShader: vertexShader5,
    count,
    radius,
    depth,
    factor,
    saturation,
    lightness,
    speed,
    fade,
    opacity,
    vec3,
    spherical,
    genStar,
    positionsArray,
    colorsArray,
    sizesArray,
    component,
    time,
    stop,
    start,
    material,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("count" in $$props) $$invalidate(10, count = $$new_props.count);
    if ("radius" in $$props) $$invalidate(11, radius = $$new_props.radius);
    if ("depth" in $$props) $$invalidate(12, depth = $$new_props.depth);
    if ("factor" in $$props) $$invalidate(13, factor = $$new_props.factor);
    if ("saturation" in $$props) $$invalidate(14, saturation = $$new_props.saturation);
    if ("lightness" in $$props) $$invalidate(15, lightness = $$new_props.lightness);
    if ("speed" in $$props) $$invalidate(16, speed = $$new_props.speed);
    if ("fade" in $$props) $$invalidate(0, fade = $$new_props.fade);
    if ("opacity" in $$props) $$invalidate(1, opacity = $$new_props.opacity);
    if ("positionsArray" in $$props) $$invalidate(2, positionsArray = $$new_props.positionsArray);
    if ("colorsArray" in $$props) $$invalidate(3, colorsArray = $$new_props.colorsArray);
    if ("sizesArray" in $$props) $$invalidate(4, sizesArray = $$new_props.sizesArray);
    if ("time" in $$props) $$invalidate(5, time = $$new_props.time);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*count, factor, radius, depth, saturation, lightness*/
    64512) {
      $: {
        const positions = [];
        const colors = [];
        const sizes = Array.from({ length: count }, () => (0.5 + 0.5 * Math.random()) * factor);
        const color = new Color();
        let r = radius + depth;
        const increment = depth / count;
        for (let i = 0; i < count; i++) {
          r -= increment * Math.random();
          const position = genStar(r);
          positions.push(position.x, position.y, position.z);
          color.setHSL(i / count, saturation, lightness);
          colors.push(color.r, color.g, color.b);
        }
        $$invalidate(2, positionsArray = new Float32Array(positions));
        $$invalidate(3, colorsArray = new Float32Array(colors));
        $$invalidate(4, sizesArray = new Float32Array(sizes));
      }
    }
    if ($$self.$$.dirty & /*speed*/
    65536) {
      $: if (speed !== 0) {
        start();
      } else {
        stop();
      }
    }
  };
  return [
    fade,
    opacity,
    positionsArray,
    colorsArray,
    sizesArray,
    time,
    $component,
    component,
    material,
    $$restProps,
    count,
    radius,
    depth,
    factor,
    saturation,
    lightness,
    speed,
    slots,
    t_points_binding,
    $$scope
  ];
}
var Stars = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      count: 10,
      radius: 11,
      depth: 12,
      factor: 13,
      saturation: 14,
      lightness: 15,
      speed: 16,
      fade: 0,
      opacity: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stars",
      options,
      id: create_fragment29.name
    });
  }
  get count() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depth() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depth(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get factor() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set factor(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get saturation() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set saturation(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lightness() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lightness(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Stars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Stars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stars_default = Stars;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/fragment.js
var fragmentShader6 = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${shaderStructs}
${shaderIntersectFunction}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/vertex.js
var vertexShader6 = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;

// node_modules/@threlte/extras/dist/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte
function create_fragment30(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*material*/
        ctx[5]
      ),
      "uniforms.envMap.value": (
        /*envMap*/
        ctx[0]
      ),
      "uniforms.bounces.value": (
        /*bounces*/
        ctx[1]
      ),
      "uniforms.ior.value": (
        /*ior*/
        ctx[2]
      ),
      "uniforms.fresnel.value": (
        /*fresnel*/
        ctx[3]
      ),
      "uniforms.aberrationStrength.value": (
        /*aberrationStrength*/
        ctx[4]
      ),
      "uniforms.color.value": (
        /*colorObj*/
        ctx[10]
      ),
      "uniforms.resolution.value": [
        /*$size*/
        ctx[7].width,
        /*$size*/
        ctx[7].height
      ],
      defines: (
        /*defines*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = {};
      if (dirty & /*material*/
      32) t_changes.is = /*material*/
      ctx2[5];
      if (dirty & /*envMap*/
      1) t_changes["uniforms.envMap.value"] = /*envMap*/
      ctx2[0];
      if (dirty & /*bounces*/
      2) t_changes["uniforms.bounces.value"] = /*bounces*/
      ctx2[1];
      if (dirty & /*ior*/
      4) t_changes["uniforms.ior.value"] = /*ior*/
      ctx2[2];
      if (dirty & /*fresnel*/
      8) t_changes["uniforms.fresnel.value"] = /*fresnel*/
      ctx2[3];
      if (dirty & /*aberrationStrength*/
      16) t_changes["uniforms.aberrationStrength.value"] = /*aberrationStrength*/
      ctx2[4];
      if (dirty & /*$size*/
      128) t_changes["uniforms.resolution.value"] = [
        /*$size*/
        ctx2[7].width,
        /*$size*/
        ctx2[7].height
      ];
      if (dirty & /*defines*/
      64) t_changes.defines = /*defines*/
      ctx2[6];
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let $parent;
  let $size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeshRefractionMaterial", slots, []);
  let { envMap } = $$props;
  let { bounces = 2 } = $$props;
  let { ior = 2.4 } = $$props;
  let { fresnel = 0 } = $$props;
  let { aberrationStrength = 0 } = $$props;
  let { color = "white" } = $$props;
  let { fastChroma = true } = $$props;
  let material = new ShaderMaterial({
    fragmentShader: fragmentShader6,
    vertexShader: vertexShader6,
    uniforms: {
      envMap: { value: null },
      bounces: { value: 2 },
      ior: { value: 2.4 },
      correctMips: { value: true },
      aberrationStrength: { value: 0.01 },
      fresnel: { value: 0 },
      bvh: { value: new MeshBVHUniformStruct() },
      color: { value: new Color("white") },
      resolution: { value: new Vector2() },
      viewMatrixInverse: { value: new Matrix4() },
      projectionMatrixInverse: { value: new Matrix4() }
    }
  });
  const { size, invalidate, camera } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(7, $size = value));
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(13, $parent = value));
  const isCubeTexture = (def) => def && def.isCubeTexture;
  let defines = {};
  const updateDefines = (envMap2, aberrationStrength2, fastChroma2) => {
    var _a;
    const temp = {};
    const isCubeMap = isCubeTexture(envMap2);
    const w = (isCubeMap ? (_a = envMap2.image[0]) == null ? void 0 : _a.width : envMap2.image.width) ?? 1024;
    const cubeSize = w / 4;
    const lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, lodMax);
    const width = 3 * Math.max(_cubeSize, 16 * 7);
    const height = 4 * _cubeSize;
    if (isCubeMap) temp.ENVMAP_TYPE_CUBEM = "";
    temp.CUBEUV_TEXEL_WIDTH = `${1 / width}`;
    temp.CUBEUV_TEXEL_HEIGHT = `${1 / height}`;
    temp.CUBEUV_MAX_MIP = `${lodMax}.0`;
    if (aberrationStrength2 > 0) temp.CHROMATIC_ABERRATIONS = "";
    if (fastChroma2) temp.FAST_CHROMA = "";
    return temp;
  };
  onMount(() => {
    if ($parent && $parent instanceof Mesh && $parent.geometry) {
      $$invalidate(5, material.uniforms.bvh.value = new MeshBVHUniformStruct(), material);
      material.uniforms.bvh.value.updateFrom(new MeshBVH($parent == null ? void 0 : $parent.geometry.clone().toNonIndexed(), { strategy: SAH }));
    }
  });
  useTask(
    () => {
      $$invalidate(5, material.uniforms.viewMatrixInverse.value = camera.current.matrixWorld, material);
      $$invalidate(5, material.uniforms.projectionMatrixInverse.value = camera.current.projectionMatrixInverse, material);
    },
    { autoInvalidate: false }
  );
  const colorObj = new Color(color);
  $$self.$$.on_mount.push(function() {
    if (envMap === void 0 && !("envMap" in $$props || $$self.$$.bound[$$self.$$.props["envMap"]])) {
      console.warn("<MeshRefractionMaterial> was created without expected prop 'envMap'");
    }
  });
  const writable_props = [
    "envMap",
    "bounces",
    "ior",
    "fresnel",
    "aberrationStrength",
    "color",
    "fastChroma"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MeshRefractionMaterial> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("envMap" in $$props2) $$invalidate(0, envMap = $$props2.envMap);
    if ("bounces" in $$props2) $$invalidate(1, bounces = $$props2.bounces);
    if ("ior" in $$props2) $$invalidate(2, ior = $$props2.ior);
    if ("fresnel" in $$props2) $$invalidate(3, fresnel = $$props2.fresnel);
    if ("aberrationStrength" in $$props2) $$invalidate(4, aberrationStrength = $$props2.aberrationStrength);
    if ("color" in $$props2) $$invalidate(11, color = $$props2.color);
    if ("fastChroma" in $$props2) $$invalidate(12, fastChroma = $$props2.fastChroma);
  };
  $$self.$capture_state = () => ({
    T,
    useParent,
    useTask,
    useThrelte,
    Color,
    Matrix4,
    Mesh,
    ShaderMaterial,
    Texture,
    Vector2,
    onMount,
    MeshBVH,
    MeshBVHUniformStruct,
    SAH,
    fragmentShader: fragmentShader6,
    vertexShader: vertexShader6,
    envMap,
    bounces,
    ior,
    fresnel,
    aberrationStrength,
    color,
    fastChroma,
    material,
    size,
    invalidate,
    camera,
    parent,
    isCubeTexture,
    defines,
    updateDefines,
    colorObj,
    $parent,
    $size
  });
  $$self.$inject_state = ($$props2) => {
    if ("envMap" in $$props2) $$invalidate(0, envMap = $$props2.envMap);
    if ("bounces" in $$props2) $$invalidate(1, bounces = $$props2.bounces);
    if ("ior" in $$props2) $$invalidate(2, ior = $$props2.ior);
    if ("fresnel" in $$props2) $$invalidate(3, fresnel = $$props2.fresnel);
    if ("aberrationStrength" in $$props2) $$invalidate(4, aberrationStrength = $$props2.aberrationStrength);
    if ("color" in $$props2) $$invalidate(11, color = $$props2.color);
    if ("fastChroma" in $$props2) $$invalidate(12, fastChroma = $$props2.fastChroma);
    if ("material" in $$props2) $$invalidate(5, material = $$props2.material);
    if ("defines" in $$props2) $$invalidate(6, defines = $$props2.defines);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*envMap, aberrationStrength, fastChroma*/
    4113) {
      $: $$invalidate(6, defines = updateDefines(envMap, aberrationStrength, fastChroma));
    }
    if ($$self.$$.dirty & /*color*/
    2048) {
      $: {
        colorObj.set(color);
        invalidate();
      }
    }
  };
  return [
    envMap,
    bounces,
    ior,
    fresnel,
    aberrationStrength,
    material,
    defines,
    $size,
    size,
    parent,
    colorObj,
    color,
    fastChroma
  ];
}
var MeshRefractionMaterial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      envMap: 0,
      bounces: 1,
      ior: 2,
      fresnel: 3,
      aberrationStrength: 4,
      color: 11,
      fastChroma: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeshRefractionMaterial",
      options,
      id: create_fragment30.name
    });
  }
  get envMap() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set envMap(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bounces() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bounces(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ior() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ior(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fresnel() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fresnel(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aberrationStrength() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aberrationStrength(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fastChroma() {
    throw new Error("<MeshRefractionMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fastChroma(value) {
    throw new Error("<MeshRefractionMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeshRefractionMaterial_default = MeshRefractionMaterial;

// node_modules/three/examples/jsm/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, parameters.size);
      if (parameters.depth === void 0 && parameters.height !== void 0) {
        console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead");
      }
      parameters.depth = parameters.depth !== void 0 ? parameters.depth : parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
      super(shapes, parameters);
    }
    this.type = "TextGeometry";
  }
};

// node_modules/three/examples/jsm/loaders/FontLoader.js
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      const font = scope.parse(JSON.parse(text));
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    this.isFont = true;
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      shapes.push(...paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}

// node_modules/@threlte/extras/dist/components/Text3DGeometry/Text3DGeometry.svelte
var get_default_slot_changes21 = (dirty) => ({ ref: dirty & /*ref*/
134217728 });
var get_default_slot_context21 = (ctx) => ({ ref: (
  /*ref*/
  ctx[27]
) });
function create_if_block8(ctx) {
  let t2;
  let current;
  let t_props = {
    is: (
      /*$creasedGeometry*/
      ctx[1]
    ),
    $$slots: {
      default: [
        create_default_slot24,
        ({ ref }) => ({ 27: ref }),
        ({ ref }) => ref ? 134217728 : 0
      ]
    },
    $$scope: { ctx }
  };
  t2 = new T({ props: t_props, $$inline: true });
  ctx[24](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$creasedGeometry*/
      2) t_changes.is = /*$creasedGeometry*/
      ctx2[1];
      if (dirty & /*$$scope, ref*/
      167772160) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[24](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(67:0) {#if $creasedGeometry}",
    ctx
  });
  return block;
}
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_default_slot_context21
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        167772160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_default_slot_changes21
            ),
            get_default_slot_context21
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(68:2) <T     is={$creasedGeometry}     bind:this={$component}     let:ref   >",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$creasedGeometry*/
    ctx[1] && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$creasedGeometry*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$creasedGeometry*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let loadedFont;
  let options;
  let baseGeometry;
  let smoothStore;
  let creasedGeometry;
  let $creasedGeometry, $$unsubscribe_creasedGeometry = noop, $$subscribe_creasedGeometry = () => ($$unsubscribe_creasedGeometry(), $$unsubscribe_creasedGeometry = subscribe(creasedGeometry, ($$value) => $$invalidate(1, $creasedGeometry = $$value)), creasedGeometry);
  let $component;
  $$self.$$.on_destroy.push(() => $$unsubscribe_creasedGeometry());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text3DGeometry", slots, ["default"]);
  let { text } = $$props;
  let { font = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json" } = $$props;
  let { size = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { curveSegments = void 0 } = $$props;
  let { bevelEnabled = void 0 } = $$props;
  let { bevelThickness = void 0 } = $$props;
  let { bevelSize = void 0 } = $$props;
  let { bevelOffset = void 0 } = $$props;
  let { bevelSegments = void 0 } = $$props;
  let { smooth = void 0 } = $$props;
  let { depth = void 0 } = $$props;
  let { extrudePath = void 0 } = $$props;
  let { steps = void 0 } = $$props;
  let { UVGenerator = void 0 } = $$props;
  const suspend = useSuspense();
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(2, $component = value));
  $$self.$$.on_mount.push(function() {
    if (text === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Text3DGeometry> was created without expected prop 'text'");
    }
  });
  const writable_props = [
    "text",
    "font",
    "size",
    "height",
    "curveSegments",
    "bevelEnabled",
    "bevelThickness",
    "bevelSize",
    "bevelOffset",
    "bevelSegments",
    "smooth",
    "depth",
    "extrudePath",
    "steps",
    "UVGenerator"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Text3DGeometry> was created with unknown prop '${key}'`);
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2) $$invalidate(4, text = $$props2.text);
    if ("font" in $$props2) $$invalidate(5, font = $$props2.font);
    if ("size" in $$props2) $$invalidate(6, size = $$props2.size);
    if ("height" in $$props2) $$invalidate(7, height = $$props2.height);
    if ("curveSegments" in $$props2) $$invalidate(8, curveSegments = $$props2.curveSegments);
    if ("bevelEnabled" in $$props2) $$invalidate(9, bevelEnabled = $$props2.bevelEnabled);
    if ("bevelThickness" in $$props2) $$invalidate(10, bevelThickness = $$props2.bevelThickness);
    if ("bevelSize" in $$props2) $$invalidate(11, bevelSize = $$props2.bevelSize);
    if ("bevelOffset" in $$props2) $$invalidate(12, bevelOffset = $$props2.bevelOffset);
    if ("bevelSegments" in $$props2) $$invalidate(13, bevelSegments = $$props2.bevelSegments);
    if ("smooth" in $$props2) $$invalidate(14, smooth = $$props2.smooth);
    if ("depth" in $$props2) $$invalidate(15, depth = $$props2.depth);
    if ("extrudePath" in $$props2) $$invalidate(16, extrudePath = $$props2.extrudePath);
    if ("steps" in $$props2) $$invalidate(17, steps = $$props2.steps);
    if ("UVGenerator" in $$props2) $$invalidate(18, UVGenerator = $$props2.UVGenerator);
    if ("$$scope" in $$props2) $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    asyncWritable,
    forwardEventHandlers,
    useLoader,
    derived,
    writable,
    TextGeometry,
    FontLoader,
    toCreasedNormals,
    useSuspense,
    text,
    font,
    size,
    height,
    curveSegments,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    smooth,
    depth,
    extrudePath,
    steps,
    UVGenerator,
    suspend,
    component,
    smoothStore,
    baseGeometry,
    creasedGeometry,
    options,
    loadedFont,
    $creasedGeometry,
    $component
  });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2) $$invalidate(4, text = $$props2.text);
    if ("font" in $$props2) $$invalidate(5, font = $$props2.font);
    if ("size" in $$props2) $$invalidate(6, size = $$props2.size);
    if ("height" in $$props2) $$invalidate(7, height = $$props2.height);
    if ("curveSegments" in $$props2) $$invalidate(8, curveSegments = $$props2.curveSegments);
    if ("bevelEnabled" in $$props2) $$invalidate(9, bevelEnabled = $$props2.bevelEnabled);
    if ("bevelThickness" in $$props2) $$invalidate(10, bevelThickness = $$props2.bevelThickness);
    if ("bevelSize" in $$props2) $$invalidate(11, bevelSize = $$props2.bevelSize);
    if ("bevelOffset" in $$props2) $$invalidate(12, bevelOffset = $$props2.bevelOffset);
    if ("bevelSegments" in $$props2) $$invalidate(13, bevelSegments = $$props2.bevelSegments);
    if ("smooth" in $$props2) $$invalidate(14, smooth = $$props2.smooth);
    if ("depth" in $$props2) $$invalidate(15, depth = $$props2.depth);
    if ("extrudePath" in $$props2) $$invalidate(16, extrudePath = $$props2.extrudePath);
    if ("steps" in $$props2) $$invalidate(17, steps = $$props2.steps);
    if ("UVGenerator" in $$props2) $$invalidate(18, UVGenerator = $$props2.UVGenerator);
    if ("smoothStore" in $$props2) $$invalidate(19, smoothStore = $$props2.smoothStore);
    if ("baseGeometry" in $$props2) $$invalidate(20, baseGeometry = $$props2.baseGeometry);
    if ("creasedGeometry" in $$props2) $$subscribe_creasedGeometry($$invalidate(0, creasedGeometry = $$props2.creasedGeometry));
    if ("options" in $$props2) $$invalidate(21, options = $$props2.options);
    if ("loadedFont" in $$props2) $$invalidate(22, loadedFont = $$props2.loadedFont);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*font*/
    32) {
      $: $$invalidate(22, loadedFont = suspend(typeof font === "string" ? useLoader(FontLoader).load(font) : asyncWritable(new Promise((resolve) => resolve(font)))));
    }
    if ($$self.$$.dirty & /*text, size, height, curveSegments, bevelEnabled, bevelThickness, bevelSize, bevelOffset, bevelSegments*/
    16336) {
      $: $$invalidate(21, options = writable({
        text,
        size,
        height,
        curveSegments,
        bevelEnabled,
        bevelThickness,
        bevelSize,
        bevelOffset,
        bevelSegments
      }));
    }
    if ($$self.$$.dirty & /*loadedFont, options, depth, extrudePath, steps, UVGenerator*/
    6782976) {
      $: $$invalidate(20, baseGeometry = derived([loadedFont, options], ([font2, options2]) => {
        if (!font2) return;
        return new TextGeometry(
          options2.text,
          {
            font: font2,
            size: options2.size,
            height: options2.height,
            curveSegments: options2.curveSegments,
            bevelEnabled: options2.bevelEnabled,
            bevelThickness: options2.bevelThickness,
            bevelSize: options2.bevelSize,
            bevelOffset: options2.bevelOffset,
            bevelSegments: options2.bevelSegments,
            depth,
            extrudePath,
            steps,
            UVGenerator
          }
        );
      }));
    }
    if ($$self.$$.dirty & /*smooth*/
    16384) {
      $: $$invalidate(19, smoothStore = writable(smooth));
    }
    if ($$self.$$.dirty & /*baseGeometry, smoothStore*/
    1572864) {
      $: $$subscribe_creasedGeometry($$invalidate(0, creasedGeometry = derived([baseGeometry, smoothStore], ([baseGeometry2, smooth2]) => {
        if (!baseGeometry2) return;
        if (smooth2 === 0) return baseGeometry2;
        return toCreasedNormals(baseGeometry2, smooth2);
      })));
    }
  };
  return [
    creasedGeometry,
    $creasedGeometry,
    $component,
    component,
    text,
    font,
    size,
    height,
    curveSegments,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    smooth,
    depth,
    extrudePath,
    steps,
    UVGenerator,
    smoothStore,
    baseGeometry,
    options,
    loadedFont,
    slots,
    t_binding,
    $$scope
  ];
}
var Text3DGeometry = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      text: 4,
      font: 5,
      size: 6,
      height: 7,
      curveSegments: 8,
      bevelEnabled: 9,
      bevelThickness: 10,
      bevelSize: 11,
      bevelOffset: 12,
      bevelSegments: 13,
      smooth: 14,
      depth: 15,
      extrudePath: 16,
      steps: 17,
      UVGenerator: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text3DGeometry",
      options,
      id: create_fragment31.name
    });
  }
  get text() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curveSegments() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curveSegments(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bevelEnabled() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bevelEnabled(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bevelThickness() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bevelThickness(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bevelSize() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bevelSize(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bevelOffset() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bevelOffset(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bevelSegments() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bevelSegments(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smooth() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smooth(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depth() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depth(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extrudePath() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extrudePath(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get steps() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set steps(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get UVGenerator() {
    throw new Error("<Text3DGeometry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set UVGenerator(value) {
    throw new Error("<Text3DGeometry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text3DGeometry_default = Text3DGeometry;

// node_modules/@threlte/extras/dist/components/PerfMonitor/PerfMonitor.svelte
function create_fragment32(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PerfMonitor", slots, []);
  let { domElement = document.body } = $$props;
  let { logsPerSecond = 10 } = $$props;
  let { showGraph = true } = $$props;
  let { memory = true } = $$props;
  let { enabled = true } = $$props;
  let { visible = true } = $$props;
  let { actionToCallUI = "" } = $$props;
  let { guiVisible = false } = $$props;
  let { backgroundOpacity = 0.7 } = $$props;
  let { scale = 1 } = $$props;
  let { anchorX = "left" } = $$props;
  let { anchorY = "top" } = $$props;
  const { renderer, renderStage, mainStage } = useThrelte();
  let perf;
  const domElementStore = writable(domElement);
  watch([domElementStore], ([domElement2]) => {
    if (perf) perf.dispose();
    perf = new ThreePerf({
      domElement: domElement2 || document.body,
      renderer
    });
  });
  useTask(
    () => {
      perf.begin();
    },
    {
      stage: useStage("monitor-begin", { before: mainStage })
    }
  );
  useTask(
    () => {
      perf.end();
    },
    {
      stage: useStage("monitor-end", { after: renderStage })
    }
  );
  onDestroy(() => {
    if (perf) perf.dispose();
  });
  const writable_props = [
    "domElement",
    "logsPerSecond",
    "showGraph",
    "memory",
    "enabled",
    "visible",
    "actionToCallUI",
    "guiVisible",
    "backgroundOpacity",
    "scale",
    "anchorX",
    "anchorY"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PerfMonitor> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("domElement" in $$props2) $$invalidate(0, domElement = $$props2.domElement);
    if ("logsPerSecond" in $$props2) $$invalidate(1, logsPerSecond = $$props2.logsPerSecond);
    if ("showGraph" in $$props2) $$invalidate(2, showGraph = $$props2.showGraph);
    if ("memory" in $$props2) $$invalidate(3, memory = $$props2.memory);
    if ("enabled" in $$props2) $$invalidate(4, enabled = $$props2.enabled);
    if ("visible" in $$props2) $$invalidate(5, visible = $$props2.visible);
    if ("actionToCallUI" in $$props2) $$invalidate(6, actionToCallUI = $$props2.actionToCallUI);
    if ("guiVisible" in $$props2) $$invalidate(7, guiVisible = $$props2.guiVisible);
    if ("backgroundOpacity" in $$props2) $$invalidate(8, backgroundOpacity = $$props2.backgroundOpacity);
    if ("scale" in $$props2) $$invalidate(9, scale = $$props2.scale);
    if ("anchorX" in $$props2) $$invalidate(10, anchorX = $$props2.anchorX);
    if ("anchorY" in $$props2) $$invalidate(11, anchorY = $$props2.anchorY);
  };
  $$self.$capture_state = () => ({
    useStage,
    useTask,
    useThrelte,
    watch,
    ThreePerf,
    onDestroy,
    writable,
    domElement,
    logsPerSecond,
    showGraph,
    memory,
    enabled,
    visible,
    actionToCallUI,
    guiVisible,
    backgroundOpacity,
    scale,
    anchorX,
    anchorY,
    renderer,
    renderStage,
    mainStage,
    perf,
    domElementStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("domElement" in $$props2) $$invalidate(0, domElement = $$props2.domElement);
    if ("logsPerSecond" in $$props2) $$invalidate(1, logsPerSecond = $$props2.logsPerSecond);
    if ("showGraph" in $$props2) $$invalidate(2, showGraph = $$props2.showGraph);
    if ("memory" in $$props2) $$invalidate(3, memory = $$props2.memory);
    if ("enabled" in $$props2) $$invalidate(4, enabled = $$props2.enabled);
    if ("visible" in $$props2) $$invalidate(5, visible = $$props2.visible);
    if ("actionToCallUI" in $$props2) $$invalidate(6, actionToCallUI = $$props2.actionToCallUI);
    if ("guiVisible" in $$props2) $$invalidate(7, guiVisible = $$props2.guiVisible);
    if ("backgroundOpacity" in $$props2) $$invalidate(8, backgroundOpacity = $$props2.backgroundOpacity);
    if ("scale" in $$props2) $$invalidate(9, scale = $$props2.scale);
    if ("anchorX" in $$props2) $$invalidate(10, anchorX = $$props2.anchorX);
    if ("anchorY" in $$props2) $$invalidate(11, anchorY = $$props2.anchorY);
    if ("perf" in $$props2) perf = $$props2.perf;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*domElement*/
    1) {
      $: domElementStore.set(domElement);
    }
    if ($$self.$$.dirty & /*logsPerSecond*/
    2) {
      $: perf.logsPerSecond = logsPerSecond;
    }
    if ($$self.$$.dirty & /*showGraph*/
    4) {
      $: perf.showGraph = showGraph;
    }
    if ($$self.$$.dirty & /*memory*/
    8) {
      $: perf.memory = memory;
    }
    if ($$self.$$.dirty & /*enabled*/
    16) {
      $: perf.enabled = enabled;
    }
    if ($$self.$$.dirty & /*visible*/
    32) {
      $: perf.visible = visible;
    }
    if ($$self.$$.dirty & /*actionToCallUI*/
    64) {
      $: perf.actionToCallUI = actionToCallUI;
    }
    if ($$self.$$.dirty & /*guiVisible*/
    128) {
      $: perf.guiVisible = guiVisible;
    }
    if ($$self.$$.dirty & /*backgroundOpacity*/
    256) {
      $: perf.backgroundOpacity = backgroundOpacity;
    }
    if ($$self.$$.dirty & /*scale*/
    512) {
      $: perf.scale = scale;
    }
    if ($$self.$$.dirty & /*anchorX*/
    1024) {
      $: perf.anchorX = anchorX;
    }
    if ($$self.$$.dirty & /*anchorY*/
    2048) {
      $: perf.anchorY = anchorY;
    }
  };
  return [
    domElement,
    logsPerSecond,
    showGraph,
    memory,
    enabled,
    visible,
    actionToCallUI,
    guiVisible,
    backgroundOpacity,
    scale,
    anchorX,
    anchorY
  ];
}
var PerfMonitor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      domElement: 0,
      logsPerSecond: 1,
      showGraph: 2,
      memory: 3,
      enabled: 4,
      visible: 5,
      actionToCallUI: 6,
      guiVisible: 7,
      backgroundOpacity: 8,
      scale: 9,
      anchorX: 10,
      anchorY: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PerfMonitor",
      options,
      id: create_fragment32.name
    });
  }
  get domElement() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set domElement(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logsPerSecond() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logsPerSecond(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showGraph() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showGraph(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get memory() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set memory(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionToCallUI() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionToCallUI(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get guiVisible() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set guiVisible(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundOpacity() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundOpacity(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorX() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorX(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorY() {
    throw new Error("<PerfMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorY(value) {
    throw new Error("<PerfMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PerfMonitor_default = PerfMonitor;

// node_modules/@threlte/extras/dist/components/Outlines/shaders.js
var vertexShader7 = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`;
var fragmentShader7 = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <${revision2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
}
`;

// node_modules/@threlte/extras/dist/components/Outlines/Outlines.svelte
var get_default_slot_changes22 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context22 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot25(ctx) {
  let t0;
  let t1;
  let current;
  t0 = new T({
    props: { is: (
      /*mesh*/
      ctx[1]
    ) },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_default_slot_context22
  );
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t0_changes = {};
      if (dirty & /*mesh*/
      2) t0_changes.is = /*mesh*/
      ctx2[1];
      t0.$set(t0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        4194305)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_default_slot_changes22
            ),
            get_default_slot_context22
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t0.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t1);
      }
      destroy_component(t0, detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: "(84:0) <T   is={ref}   {...$$restProps}   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[21](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      33 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        )
      ]) : {};
      if (dirty & /*$$scope, ref, mesh*/
      4194307) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[21](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "color",
    "screenspace",
    "opacity",
    "transparent",
    "thickness",
    "toneMapped",
    "angle",
    "polygonOffset",
    "polygonOffsetFactor",
    "renderOrder",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Outlines", slots, ["default"]);
  let { color = "black" } = $$props;
  let { screenspace = false } = $$props;
  let { opacity = 1 } = $$props;
  let { transparent = false } = $$props;
  let { thickness = 0.05 } = $$props;
  let { toneMapped = true } = $$props;
  let { angle = Math.PI } = $$props;
  let { polygonOffset = false } = $$props;
  let { polygonOffsetFactor = 0 } = $$props;
  let { renderOrder = 0 } = $$props;
  const { renderer } = useThrelte();
  const uniforms = {
    screenspace: { value: screenspace },
    color: { value: new Color(color) },
    opacity: { value: opacity },
    thickness: { value: thickness },
    size: { value: new Vector2() }
  };
  let { ref = new Group() } = $$props;
  const material = new ShaderMaterial({
    side: BackSide,
    uniforms,
    vertexShader: vertexShader7,
    fragmentShader: fragmentShader7
  });
  let oldAngle = 0;
  let oldGeometry;
  let mesh;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(19, $parent = value));
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(2, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props) $$invalidate(6, color = $$new_props.color);
    if ("screenspace" in $$new_props) $$invalidate(7, screenspace = $$new_props.screenspace);
    if ("opacity" in $$new_props) $$invalidate(8, opacity = $$new_props.opacity);
    if ("transparent" in $$new_props) $$invalidate(9, transparent = $$new_props.transparent);
    if ("thickness" in $$new_props) $$invalidate(10, thickness = $$new_props.thickness);
    if ("toneMapped" in $$new_props) $$invalidate(11, toneMapped = $$new_props.toneMapped);
    if ("angle" in $$new_props) $$invalidate(12, angle = $$new_props.angle);
    if ("polygonOffset" in $$new_props) $$invalidate(13, polygonOffset = $$new_props.polygonOffset);
    if ("polygonOffsetFactor" in $$new_props) $$invalidate(14, polygonOffsetFactor = $$new_props.polygonOffsetFactor);
    if ("renderOrder" in $$new_props) $$invalidate(15, renderOrder = $$new_props.renderOrder);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useParent,
    useThrelte,
    forwardEventHandlers,
    Color,
    Vector2,
    ShaderMaterial,
    Group,
    SkinnedMesh,
    InstancedMesh,
    Mesh,
    BackSide,
    toCreasedNormals,
    vertexShader: vertexShader7,
    fragmentShader: fragmentShader7,
    color,
    screenspace,
    opacity,
    transparent,
    thickness,
    toneMapped,
    angle,
    polygonOffset,
    polygonOffsetFactor,
    renderOrder,
    renderer,
    uniforms,
    ref,
    material,
    oldAngle,
    oldGeometry,
    mesh,
    parent,
    component,
    $parent,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props) $$invalidate(6, color = $$new_props.color);
    if ("screenspace" in $$props) $$invalidate(7, screenspace = $$new_props.screenspace);
    if ("opacity" in $$props) $$invalidate(8, opacity = $$new_props.opacity);
    if ("transparent" in $$props) $$invalidate(9, transparent = $$new_props.transparent);
    if ("thickness" in $$props) $$invalidate(10, thickness = $$new_props.thickness);
    if ("toneMapped" in $$props) $$invalidate(11, toneMapped = $$new_props.toneMapped);
    if ("angle" in $$props) $$invalidate(12, angle = $$new_props.angle);
    if ("polygonOffset" in $$props) $$invalidate(13, polygonOffset = $$new_props.polygonOffset);
    if ("polygonOffsetFactor" in $$props) $$invalidate(14, polygonOffsetFactor = $$new_props.polygonOffsetFactor);
    if ("renderOrder" in $$props) $$invalidate(15, renderOrder = $$new_props.renderOrder);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("oldAngle" in $$props) $$invalidate(17, oldAngle = $$new_props.oldAngle);
    if ("oldGeometry" in $$props) $$invalidate(18, oldGeometry = $$new_props.oldGeometry);
    if ("mesh" in $$props) $$invalidate(1, mesh = $$new_props.mesh);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*transparent*/
    512) {
      $: $$invalidate(16, material.transparent = transparent, material);
    }
    if ($$self.$$.dirty & /*toneMapped*/
    2048) {
      $: $$invalidate(16, material.toneMapped = toneMapped, material);
    }
    if ($$self.$$.dirty & /*polygonOffset*/
    8192) {
      $: $$invalidate(16, material.polygonOffset = polygonOffset, material);
    }
    if ($$self.$$.dirty & /*polygonOffsetFactor*/
    16384) {
      $: $$invalidate(16, material.polygonOffsetFactor = polygonOffsetFactor, material);
    }
    if ($$self.$$.dirty & /*screenspace*/
    128) {
      $: $$invalidate(16, material.uniforms.screenspace.value = screenspace, material);
    }
    if ($$self.$$.dirty & /*opacity*/
    256) {
      $: $$invalidate(16, material.uniforms.opacity.value = opacity, material);
    }
    if ($$self.$$.dirty & /*thickness*/
    1024) {
      $: $$invalidate(16, material.uniforms.thickness.value = thickness, material);
    }
    if ($$self.$$.dirty & /*$parent, oldAngle, angle, oldGeometry, mesh, ref, material, renderOrder*/
    1019907) {
      $: {
        const parentMesh = $parent;
        if ((parentMesh == null ? void 0 : parentMesh.geometry) !== void 0) {
          if (oldAngle !== angle || oldGeometry !== parentMesh.geometry) {
            $$invalidate(17, oldAngle = angle);
            $$invalidate(18, oldGeometry = parentMesh.geometry);
            if (mesh) {
              if (angle) mesh.geometry.dispose();
              ref.remove(mesh);
            }
            const geometry = angle ? toCreasedNormals(parentMesh.geometry, angle) : parentMesh.geometry;
            if ("skeleton" in parentMesh) {
              const nextMesh = new SkinnedMesh(geometry, material);
              nextMesh.bind(parentMesh.skeleton, parentMesh.bindMatrix);
              $$invalidate(1, mesh = nextMesh);
            } else if ("isInstancedMesh" in parentMesh) {
              const nextMesh = new InstancedMesh(geometry, material, parentMesh.count);
              nextMesh.instanceMatrix = parentMesh.instanceMatrix;
              $$invalidate(1, mesh = nextMesh);
            } else {
              $$invalidate(1, mesh = new Mesh(geometry, material));
            }
            $$invalidate(1, mesh.renderOrder = renderOrder, mesh);
          }
        }
      }
    }
    if ($$self.$$.dirty & /*mesh, renderOrder*/
    32770) {
      $: if (mesh) {
        $$invalidate(1, mesh.renderOrder = renderOrder, mesh);
      }
    }
    if ($$self.$$.dirty & /*material, color*/
    65600) {
      $: material.uniforms.color.value.set(color);
    }
    if ($$self.$$.dirty & /*material*/
    65536) {
      $: renderer.getDrawingBufferSize(material.uniforms.size.value);
    }
  };
  return [
    ref,
    mesh,
    $component,
    parent,
    component,
    $$restProps,
    color,
    screenspace,
    opacity,
    transparent,
    thickness,
    toneMapped,
    angle,
    polygonOffset,
    polygonOffsetFactor,
    renderOrder,
    material,
    oldAngle,
    oldGeometry,
    $parent,
    slots,
    t_binding,
    $$scope
  ];
}
var Outlines = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      color: 6,
      screenspace: 7,
      opacity: 8,
      transparent: 9,
      thickness: 10,
      toneMapped: 11,
      angle: 12,
      polygonOffset: 13,
      polygonOffsetFactor: 14,
      renderOrder: 15,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Outlines",
      options,
      id: create_fragment33.name
    });
  }
  get color() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get screenspace() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set screenspace(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thickness() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thickness(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toneMapped() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toneMapped(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angle() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angle(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get polygonOffset() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set polygonOffset(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get polygonOffsetFactor() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set polygonOffsetFactor(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Outlines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Outlines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Outlines_default = Outlines;

// node_modules/@threlte/extras/dist/components/Mask/Mask.svelte
var get_default_slot_changes23 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context23 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context23
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        129)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes23
            ),
            get_default_slot_context23
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: "(33:0) <T.Mesh   {...$$restProps}   renderOrder={-id}   bind:ref >",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let t_mesh;
  let updating_ref;
  let current;
  const t_mesh_spread_levels = [
    /*$$restProps*/
    ctx[2],
    { renderOrder: -/*id*/
    ctx[1] }
  ];
  function t_mesh_ref_binding(value) {
    ctx[6](value);
  }
  let t_mesh_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_mesh_spread_levels.length; i += 1) {
    t_mesh_props = assign(t_mesh_props, t_mesh_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    t_mesh_props.ref = /*ref*/
    ctx[0];
  }
  t_mesh = new T.Mesh({ props: t_mesh_props, $$inline: true });
  binding_callbacks.push(() => bind(t_mesh, "ref", t_mesh_ref_binding));
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_mesh_changes = dirty & /*$$restProps, id*/
      6 ? get_spread_update(t_mesh_spread_levels, [
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        ),
        dirty & /*id*/
        2 && { renderOrder: -/*id*/
        ctx2[1] }
      ]) : {};
      if (dirty & /*$$scope, ref*/
      129) {
        t_mesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*ref*/
      1) {
        updating_ref = true;
        t_mesh_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t_mesh.$set(t_mesh_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t_mesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_mesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "colorWrite", "depthWrite", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mask", slots, ["default"]);
  let { id = 1 } = $$props;
  let { colorWrite = false } = $$props;
  let { depthWrite = false } = $$props;
  let { ref = new Mesh() } = $$props;
  const meshLoaded = (mesh) => {
    if (!mesh) return;
    const material = mesh.material;
    if (Array.isArray(material)) return;
    material.colorWrite = colorWrite;
    material.depthWrite = depthWrite;
    material.stencilWrite = true;
    material.stencilRef = id;
    material.stencilFunc = AlwaysStencilFunc;
    material.stencilFail = ReplaceStencilOp;
    material.stencilZFail = ReplaceStencilOp;
    material.stencilZPass = ReplaceStencilOp;
  };
  function t_mesh_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    if ("colorWrite" in $$new_props) $$invalidate(3, colorWrite = $$new_props.colorWrite);
    if ("depthWrite" in $$new_props) $$invalidate(4, depthWrite = $$new_props.depthWrite);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    ReplaceStencilOp,
    AlwaysStencilFunc,
    Mesh,
    id,
    colorWrite,
    depthWrite,
    ref,
    meshLoaded
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    if ("colorWrite" in $$props) $$invalidate(3, colorWrite = $$new_props.colorWrite);
    if ("depthWrite" in $$props) $$invalidate(4, depthWrite = $$new_props.depthWrite);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref*/
    1) {
      $: meshLoaded(ref);
    }
    if ($$self.$$.dirty & /*ref, id*/
    3) {
      $: {
        meshLoaded(ref);
        id;
      }
    }
  };
  return [
    ref,
    id,
    $$restProps,
    colorWrite,
    depthWrite,
    slots,
    t_mesh_ref_binding,
    $$scope
  ];
}
var Mask = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      id: 1,
      colorWrite: 3,
      depthWrite: 4,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mask",
      options,
      id: create_fragment34.name
    });
  }
  get id() {
    throw new Error("<Mask>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Mask>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorWrite() {
    throw new Error("<Mask>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorWrite(value) {
    throw new Error("<Mask>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depthWrite() {
    throw new Error("<Mask>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depthWrite(value) {
    throw new Error("<Mask>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Mask>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Mask>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mask_default = Mask;

// node_modules/@threlte/extras/dist/suspense/Suspense.svelte
var get_fallback_slot_changes = (dirty) => ({});
var get_fallback_slot_context = (ctx) => ({});
var get_error_slot_changes = (dirty) => ({ errors: dirty & /*$errors*/
1 });
var get_error_slot_context = (ctx) => ({ errors: (
  /*$errors*/
  ctx[0]
) });
var get_default_slot_changes24 = (dirty) => ({
  suspended: dirty & /*$suspended*/
  2,
  errors: dirty & /*$errors*/
  1
});
var get_default_slot_context24 = (ctx) => ({
  suspended: (
    /*$suspended*/
    ctx[1]
  ),
  errors: (
    /*$errors*/
    ctx[0]
  )
});
function create_default_slot_19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context24
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $suspended, $errors*/
        131)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes24
            ),
            get_default_slot_context24
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(34:2) <T is={group}>",
    ctx
  });
  return block;
}
function create_default_slot27(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*group*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$$scope, $suspended, $errors*/
      131) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: "(33:0) <HierarchicalObject>",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let current;
  const fallback_slot_template = (
    /*#slots*/
    ctx[6].fallback
  );
  const fallback_slot = create_slot(
    fallback_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_fallback_slot_context
  );
  const block = {
    c: function create() {
      if (fallback_slot) fallback_slot.c();
    },
    l: function claim(nodes) {
      if (fallback_slot) fallback_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (fallback_slot) {
        fallback_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              fallback_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_fallback_slot_changes
            ),
            get_fallback_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(fallback_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (fallback_slot) fallback_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(47:21) ",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let current;
  const error_slot_template = (
    /*#slots*/
    ctx[6].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_error_slot_context
  );
  const block = {
    c: function create() {
      if (error_slot) error_slot.c();
    },
    l: function claim(nodes) {
      if (error_slot) error_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & /*$$scope, $errors*/
        129)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot) error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(42:0) {#if $errors.length}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let hierarchicalobject;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block9, create_if_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$errors*/
      ctx2[0].length
    ) return 0;
    if (
      /*$suspended*/
      ctx2[1]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope, $suspended, $errors*/
      131) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block_anchor);
      }
      destroy_component(hierarchicalobject, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let $errors;
  let $suspended;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Suspense", slots, ["default", "error", "fallback"]);
  let { final = false } = $$props;
  const dispatch = createRawEventDispatcher();
  const { suspended, errors, setFinal } = createSuspenseContext({ final });
  validate_store(suspended, "suspended");
  component_subscribe($$self, suspended, (value) => $$invalidate(1, $suspended = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(0, $errors = value));
  const group = new Group();
  const parent = useParent();
  watch([parent, suspended, errors], ([parent2, suspended2, errors2]) => {
    if (!parent2) return;
    if (suspended2 || errors2.length) {
      parent2.remove(group);
      return;
    }
    parent2.add(group);
    return () => {
      parent2.remove(group);
    };
  });
  const writable_props = ["final"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Suspense> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("final" in $$props2) $$invalidate(5, final = $$props2.final);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    HierarchicalObject: HierarchicalObject_default,
    T,
    createRawEventDispatcher,
    useParent,
    watch,
    Group,
    createSuspenseContext,
    final,
    dispatch,
    suspended,
    errors,
    setFinal,
    group,
    parent,
    $errors,
    $suspended
  });
  $$self.$inject_state = ($$props2) => {
    if ("final" in $$props2) $$invalidate(5, final = $$props2.final);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*final*/
    32) {
      $: setFinal(final);
    }
    if ($$self.$$.dirty & /*$suspended*/
    2) {
      $: if (!$suspended) dispatch("load");
    }
    if ($$self.$$.dirty & /*$suspended*/
    2) {
      $: if ($suspended) dispatch("suspend");
    }
    if ($$self.$$.dirty & /*$errors*/
    1) {
      $: if ($errors.length) dispatch("error", $errors);
    }
  };
  return [$errors, $suspended, suspended, errors, group, final, slots, $$scope];
}
var Suspense = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { final: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Suspense",
      options,
      id: create_fragment35.name
    });
  }
  get final() {
    throw new Error("<Suspense>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set final(value) {
    throw new Error("<Suspense>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Suspense_default = Suspense;

// node_modules/@threlte/extras/dist/suspense/onReveal.js
var onReveal = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  let cleanup;
  const mounted = writable(false);
  onMount(() => {
    if (!ctx)
      cleanup = callback();
    mounted.set(true);
  });
  if (!ctx) {
    onDestroy(() => cleanup == null ? void 0 : cleanup());
    return;
  }
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && !suspended)
      cleanup = callback();
    return () => cleanup == null ? void 0 : cleanup();
  });
};

// node_modules/@threlte/extras/dist/suspense/onSuspend.js
var onSuspend = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  if (!ctx)
    return;
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
  });
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/components/portals/usePortalContext.js
var createPortalContext = () => {
  const ctx = {
    portals: currentWritable(/* @__PURE__ */ new Map()),
    addPortal(object, id) {
      ctx.portals.update((portals) => {
        if (portals.has(id)) {
          console.warn(`Portal with id ${id} already exists. Skipping portal creation.`);
        } else {
          portals.set(id, object);
        }
        return portals;
      });
    },
    removePortal(id) {
      ctx.portals.update((portals) => {
        if (!portals.has(id)) {
          console.warn(`Portal with id ${id} does not exist. Skipping portal removal.`);
        } else {
          portals.delete(id);
        }
        return portals;
      });
    },
    getPortal(id) {
      return derived(ctx.portals, (portals) => portals.get(id));
    },
    hasPortal(id) {
      return ctx.portals.current.has(id);
    }
  };
  return ctx;
};
var usePortalContext = () => {
  return useThrelteUserContext("threlte-portals", createPortalContext());
};

// node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte
function create_if_block10(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      onChildMount: (
        /*func*/
        ctx[8]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(29:0) {#if $target}",
    ctx
  });
  return block;
}
function create_default_slot28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot28.name,
    type: "slot",
    source: "(30:2) <HierarchicalObject     onChildMount={(child) =>       children.update((array) => {         array.push(child)         return array       })}     onChildDestroy={(child) =>       children.update((array) => {         array.splice(array.indexOf(child), 1)         return array       })}   >",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$target*/
    ctx[1] && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$target*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$target*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let portal;
  let $portal, $$unsubscribe_portal = noop, $$subscribe_portal = () => ($$unsubscribe_portal(), $$unsubscribe_portal = subscribe(portal, ($$value) => $$invalidate(6, $portal = $$value)), portal);
  let $target;
  $$self.$$.on_destroy.push(() => $$unsubscribe_portal());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { id = "default" } = $$props;
  let { object = void 0 } = $$props;
  const { getPortal } = usePortalContext();
  const children2 = writable([]);
  const target = writable();
  validate_store(target, "target");
  component_subscribe($$self, target, (value) => $$invalidate(1, $target = value));
  watch([children2, target], ([children3, target2]) => {
    if (target2 === void 0) return;
    for (const child of children3) {
      if (target2.children.includes(child)) continue;
      target2.add(child);
    }
    return () => {
      for (const child of children3) {
        if (target2.children.includes(child)) {
          target2.remove(child);
        }
      }
    };
  });
  const writable_props = ["id", "object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Portal> was created with unknown prop '${key}'`);
  });
  const func3 = (child) => children2.update((array) => {
    array.push(child);
    return array;
  });
  const func_12 = (child) => children2.update((array) => {
    array.splice(array.indexOf(child), 1);
    return array;
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("object" in $$props2) $$invalidate(5, object = $$props2.object);
    if ("$$scope" in $$props2) $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    HierarchicalObject: HierarchicalObject_default,
    watch,
    usePortalContext,
    writable,
    id,
    object,
    getPortal,
    children: children2,
    target,
    portal,
    $portal,
    $target
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("object" in $$props2) $$invalidate(5, object = $$props2.object);
    if ("portal" in $$props2) $$subscribe_portal($$invalidate(0, portal = $$props2.portal));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    16) {
      $: $$subscribe_portal($$invalidate(0, portal = getPortal(id)));
    }
    if ($$self.$$.dirty & /*object, $portal*/
    96) {
      $: target.set(object ?? $portal);
    }
  };
  return [
    portal,
    $target,
    children2,
    target,
    id,
    object,
    $portal,
    slots,
    func3,
    func_12,
    $$scope
  ];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { id: 4, object: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment36.name
    });
  }
  get id() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Portal_default = Portal;

// node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte
var { Error: Error_15 } = globals;
function create_fragment37(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PortalTarget", slots, []);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(2, $parent = value));
  if (!$parent) {
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  }
  let { id = "default" } = $$props;
  const { addPortal, removePortal } = usePortalContext();
  watch(parent, (parent2) => {
    if (!parent2) return;
    addPortal(parent2, id);
    return () => {
      removePortal(id);
    };
  });
  const writable_props = ["id"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PortalTarget> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
  };
  $$self.$capture_state = () => ({
    useParent,
    watch,
    usePortalContext,
    parent,
    id,
    addPortal,
    removePortal,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(1, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [parent, id];
}
var PortalTarget = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { id: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PortalTarget",
      options,
      id: create_fragment37.name
    });
  }
  get id() {
    throw new Error_15("<PortalTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_15("<PortalTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PortalTarget_default = PortalTarget;

// node_modules/troika-three-text/node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived2 = Object.create(base, descriptor);
    Object.defineProperty(derived2, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived2, "id", { value: materialInstanceId++ });
    derived2.uuid = generateUUID();
    derived2.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived2.defines = assign2({}, base.defines, options.defines);
    derived2.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived2.extensions = assign2({}, base.extensions, options.extensions);
    derived2._listeners = void 0;
    return derived2;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material, { vertexShader: vertexShader8, fragmentShader: fragmentShader8 }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader8 = expandShaderIncludes(vertexShader8);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader8 = fragmentShader8.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader8 = expandShaderIncludes(fragmentShader8);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader: vertexShader8, fragmentShader: fragmentShader8 });
    vertexShader8 = res.vertexShader;
    fragmentShader8 = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader8 = fragmentShader8.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader8 = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader8}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader8 = vertexShader8.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
    if (!(material.map && material.map.channel > 0)) {
      vertexShader8 = vertexShader8.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
    }
  }
  vertexShader8 = injectIntoShaderCode(vertexShader8, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader8 = injectIntoShaderCode(fragmentShader8, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader: vertexShader8,
    fragmentShader: fragmentShader8
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a2, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a2, n2), n2 += 2, t3.readUshort(a2, n2), n2 += 2;
        var o = t3.readUint(a2, n2);
        n2 += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t3.readUint(a2, n2);
          n2 += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t3) {
      var a2 = e._bin, n2 = t3;
      a2.readFixed(r2, t3), t3 += 4;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n2 }, h = {}, d = 0; d < o; d++) {
        var f = a2.readASCII(r2, t3, 4);
        t3 += 4, a2.readUint(r2, t3), t3 += 4;
        var u2 = a2.readUint(r2, t3);
        t3 += 4;
        var l = a2.readUint(r2, t3);
        t3 += 4, h[f] = { offset: u2, length: l };
      }
      for (d = 0; d < s.length; d++) {
        var v = s[d];
        h[v] && (i[v.trim()] = e[v.trim()].parse(r2, h[v].offset, h[v].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t3, a2) {
      for (var n2 = e._bin, o = n2.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n2.readASCII(r2, s, 4);
        s += 4, n2.readUint(r2, s), s += 4;
        var d = n2.readUint(r2, s);
        if (s += 4, n2.readUint(r2, s), s += 4, h == t3) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a2) {
      for (var n2 = [], o = 0; o < a2; o++) n2.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n2;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) a2 += String.fromCharCode(r2[e2 + n2]);
      return a2;
    }, readUnicode: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a2) {
      var n2 = e._bin._tdec;
      return n2 && 0 == t3 && a2 == r2.length ? n2.decode(r2) : e._bin.readASCII(r2, t3, a2);
    }, readBytes: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(r2[e2 + n2]);
      return a2;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++) a2.push(String.fromCharCode(r2[e2 + n2]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a2, n2, o) {
      var s = e._bin, i = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var u2 = s.readUshort(r2, t3);
      return t3 += 2, i.scriptList = e._lctf.readScriptList(r2, h + d), i.featureList = e._lctf.readFeatureList(r2, h + f), i.lookupList = e._lctf.readLookupList(r2, h + u2, o), i;
    }, e._lctf.readLookupList = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = [], i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readLookupTable(r2, o + d, a2);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r2, t3), t3 += 2, s.flag = n2.readUshort(r2, t3), t3 += 2;
      var i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = a2(r2, h, o + f, s);
        s.tabs.push(u2);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++) 0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = a2.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a2.readUshort(r2, t3);
        t3 += 2;
        var i = a2.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i; h++) n2.push(s + h), n2.push(s + h), n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < d; h++) n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      return n2;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a2 = r2[t3], n2 = r2[t3 + 1];
        if (r2[t3 + 2], a2 <= e2 && e2 <= n2) return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.fmt = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, o)), 2 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, 3 * o)), n2;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a2 = r2.tab;
      if (1 == r2.fmt) return a2.indexOf(t3);
      if (2 == r2.fmt) {
        var n2 = e._lctf.getInterval(a2, t3);
        if (-1 != n2) return a2[n2 + 2] + (t3 - a2[n2]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2;
        var f = e._lctf.readFeatureTable(r2, n2 + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a2.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n2 + d);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r2, n2 + s));
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var d = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2, o[d.trim()] = e._lctf.readLangSysTable(r2, n2 + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      a2.readUshort(r2, t3), t3 += 2, n2.reqFeature = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, n2.features = a2.readUshorts(r2, t3, o), n2;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a2) {
      var n2 = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a2))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n2.readASCII(r2, t3 + o[i], o[i + 1] - o[i]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r2, t3 + h[i], t3 + h[i + 1]));
      t3 += h[h.length - 1];
      var f = d[0], u2 = [];
      t3 = e.CFF.readIndex(r2, t3, u2);
      var l = [];
      for (i = 0; i < u2.length - 1; i++) l.push(n2.readASCII(r2, t3 + u2[i], u2[i + 1] - u2[i]));
      if (t3 += u2[u2.length - 1], e.CFF.readSubrs(r2, t3, f), f.CharStrings) {
        t3 = f.CharStrings;
        u2 = [];
        t3 = e.CFF.readIndex(r2, t3, u2);
        var v = [];
        for (i = 0; i < u2.length - 1; i++) v.push(n2.readBytes(r2, t3 + u2[i], u2[i + 1] - u2[i]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        t3 = f.FDArray;
        var c = [];
        t3 = e.CFF.readIndex(r2, t3, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r2, t3 + c[i], t3 + c[i + 1]);
          e.CFF._readFDict(r2, p, l), f.FDArray.push(p);
        }
        t3 += c[c.length - 1], t3 = f.FDSelect, f.FDSelect = [];
        var U = r2[t3];
        if (t3++, 3 != U) throw U;
        var g3 = n2.readUshort(r2, t3);
        t3 += 2;
        for (i = 0; i < g3 + 1; i++) f.FDSelect.push(n2.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r2, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r2, f.charset, f.CharStrings.length)), e.CFF._readFDict(r2, f, l), f;
    }, e.CFF._readFDict = function(r2, t3, a2) {
      var n2;
      for (var o in t3.Private && (n2 = t3.Private[1], t3.Private = e.CFF.readDict(r2, n2, n2 + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n2 + t3.Private.Subrs, t3.Private)), t3) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a2[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a2.Subrs.push(n2.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++) if (r2.charset[t3] == e2) return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a2) {
      e._bin;
      var n2 = [".notdef"], o = r2[t3];
      if (t3++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i = 0; i < s; i++) n2.push(r2[t3 + i]);
      return n2;
    }, e.CFF.readCharset = function(r2, t3, a2) {
      var n2 = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s) for (var i = 0; i < a2; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2, o.push(h);
      }
      else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n2.readUshort(r2, t3);
          t3 += 2;
          var d = 0;
          1 == s ? (d = r2[t3], t3++) : (d = n2.readUshort(r2, t3), t3 += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a2) {
      var n2 = e._bin, o = n2.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s) for (var i = 0; i < o; i++) a2.push(r2[t3 + i]);
      else if (2 == s) for (i = 0; i < o; i++) a2.push(n2.readUshort(r2, t3 + 2 * i));
      else if (3 == s) for (i = 0; i < o; i++) a2.push(16777215 & n2.readUint(r2, t3 + 3 * i - 1));
      else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a2) {
      var n2 = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i = 1, h = null, d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n2.readShort(r2, t3 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n2.readInt(r2, t3 + 1) / 65535, i = 5), a2.val = null != d ? d : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t3, a2) {
      for (var n2 = t3 + a2, o = e._bin, s = []; t3 < n2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u2 = o.readShort(r2, t3 + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u2 = o.readInt(r2, t3 + 1) / 65535, d = 5), s.push(null != u2 ? u2 : "o" + f), t3 += d;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a2) {
      for (var n2 = e._bin, o = {}, s = []; t3 < a2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var d = 1, f = null, u2 = null;
        if (28 == i && (u2 = n2.readShort(r2, t3 + 1), d = 3), 29 == i && (u2 = n2.readInt(r2, t3 + 1), d = 5), 32 <= i && i <= 246 && (u2 = i - 139, d = 1), 247 <= i && i <= 250 && (u2 = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u2 = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u2 = n2.readInt(r2, t3 + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1; ; ) {
            var v = r2[t3 + d];
            d++;
            var c = v >> 4, p = 15 & v;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U = "", g3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U += g3[l[S]];
          u2 = parseFloat(U);
        }
        if (i <= 21) {
          if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        }
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u2), t3 += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a2) {
      r2 = new Uint8Array(r2.buffer, t3, a2), t3 = 0;
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var u2 = n2.readUint(r2, t3);
        t3 += 4;
        var l = "p" + d + "e" + f, v = i.indexOf(u2);
        if (-1 == v) {
          var c;
          v = o.tables.length, i.push(u2);
          var p = n2.readUshort(r2, u2);
          0 == p ? c = e.cmap.parse0(r2, u2) : 4 == p ? c = e.cmap.parse4(r2, u2) : 6 == p ? c = e.cmap.parse6(r2, u2) : 12 == p ? c = e.cmap.parse12(r2, u2) : console.debug("unknown format: " + p, d, f, u2), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o - 6; s++) n2.map.push(r2[t3 + s]);
      return n2;
    }, e.cmap.parse4 = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {};
      o.format = a2.readUshort(r2, t3), t3 += 2;
      var s = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t3), t3 += 2, o.entrySelector = a2.readUshort(r2, t3), t3 += 2, o.rangeShift = a2.readUshort(r2, t3), t3 += 2, o.endCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a2.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n2 + s; ) o.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.firstCode = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o; s++) n2.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.cmap.parse12 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, t3 += 2, a2.readUint(r2, t3), t3 += 4, a2.readUint(r2, t3), t3 += 4;
      var o = a2.readUint(r2, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t3 + 12 * s, h = a2.readUint(r2, i + 0), d = a2.readUint(r2, i + 4), f = a2.readUint(r2, i + 8);
        n2.groups.push([h, d, f]);
      }
      return n2;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a2) {
      for (var n2 = [], o = 0; o < a2.maxp.numGlyphs; o++) n2.push(null);
      return n2;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a2 = e._bin, n2 = r2._data, o = e._tabOffset(n2, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1]) return null;
      var s = {};
      if (s.noc = a2.readShort(n2, o), o += 2, s.xMin = a2.readShort(n2, o), o += 2, s.yMin = a2.readShort(n2, o), o += 2, s.xMax = a2.readShort(n2, o), o += 2, s.yMax = a2.readShort(n2, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a2.readUshort(n2, o)), o += 2;
        var h = a2.readUshort(n2, o);
        if (o += 2, n2.length - o < h) return null;
        s.instructions = a2.readBytes(n2, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n2[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u2 = n2[o];
            o++;
            for (var l = 0; l < u2; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v ? (s.xs.push(c ? n2[o] : -n2[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n2, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v ? (s.ys.push(c ? n2[o] : -n2[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n2, o)), o += 2);
        }
        var p = 0, U = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U += s.ys[i], s.xs[i] = p, s.ys[i] = U;
      } else {
        var g3;
        s.parts = [];
        do {
          g3 = a2.readUshort(n2, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n2, o), o += 2, 1 & g3) {
            var m = a2.readShort(n2, o);
            o += 2;
            var b = a2.readShort(n2, o);
            o += 2;
          } else {
            m = a2.readInt8(n2, o);
            o++;
            b = a2.readInt8(n2, o);
            o++;
          }
          2 & g3 ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g3 ? (S.m.a = S.m.d = a2.readF2dot14(n2, o), o += 2) : 64 & g3 ? (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2) : 128 & g3 && (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.b = a2.readF2dot14(n2, o), o += 2, S.m.c = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2);
        } while (32 & g3);
        if (256 & g3) {
          var y = a2.readUshort(n2, o);
          o += 2, s.instr = [];
          for (i = 0; i < y; i++) s.instr.push(n2[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function(r2, t3, a2, n2) {
      var o = t3;
      t3 += 4;
      var s = e._bin.readUshort(r2, t3);
      return { glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r2, o + s) };
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i.fmt) {
        var d = o.readUshort(r2, a2);
        a2 += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r2, a2, d));
      } else if (2 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r2, a2);
        a2 += 2;
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var u2 = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v; c++) {
            var p = s + o.readUshort(r2, a2);
            a2 += 2;
            var U = o.readUshort(r2, p);
            p += 2;
            for (var g3 = [], S = 0; S < U; S++) {
              var m = o.readUshort(r2, p);
              p += 2, 0 != d && (P = e.GPOS.readValueRecord(r2, p, d), p += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * l), g3.push({ gid2: m, val1: P, val2: x });
            }
            i.pairsets.push(g3);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y = o.readUshort(r2, a2);
          a2 += 2;
          var F = o.readUshort(r2, a2);
          a2 += 2;
          var C3 = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y), i.matrix = [];
          for (c = 0; c < F; c++) {
            var _ = [];
            for (S = 0; S < C3; S++) {
              var P = null, x = null;
              0 != d && (P = e.GPOS.readValueRecord(r2, a2, d), a2 += 2 * u2), 0 != f && (x = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * l), _.push({ val1: P, val2: x });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t3 && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.baseCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.markArray = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.baseArray = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else if (6 == t3 && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.mark2Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.mark1Array = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else {
        if (9 == t3 && 1 == i.fmt) {
          var I2 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = I2;
          else if (n2.ltype != I2) throw "invalid extension substitution";
          return e.GPOS.subt(r2, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      return o.push(1 & a2 ? n2.readShort(r2, t3) : 0), t3 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n2.readShort(r2, t3) : 0), t3 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n2.readShort(r2, t3) : 0), t3 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n2.readShort(r2, t3) : 0), t3 += 8 & a2 ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function(r2, t3, a2) {
      var n2 = e._bin, o = [], s = t3, i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a2; f++) d.push(e.GPOS.readAnchorRecord(r2, s + n2.readUshort(r2, t3))), t3 += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = t3, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r2, a2.readUshort(r2, t3 + 2) + o);
        h.markClass = a2.readUshort(r2, t3), n2.push(h), t3 += 4;
      }
      return n2;
    }, e.GPOS.readAnchorRecord = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      return n2.fmt = a2.readUshort(r2, t3), n2.x = a2.readShort(r2, t3 + 2), n2.y = a2.readShort(r2, t3 + 4), n2;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t3 && 2 != t3 && 4 != t3 && 5 != t3 && 6 != t3) return null;
      if (1 == t3 || 2 == t3 || 4 == t3 || 5 == t3 && i.fmt <= 2 || 6 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var d = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, d), a2 += 2 * i.newg.length;
        }
      } else if (2 == t3 && 1 == i.fmt) {
        d = o.readUshort(r2, a2);
        a2 += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u2 = o.readUshort(r2, a2) + s;
          a2 += 2;
          var l = o.readUshort(r2, u2);
          i.seqs.push(o.readUshorts(r2, u2 + 2, l));
        }
      } else if (4 == t3) {
        i.vals = [];
        d = o.readUshort(r2, a2);
        a2 += 2;
        for (f = 0; f < d; f++) {
          var v = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + v));
        }
      } else if (5 == t3 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + c), i.scset = [];
          var p = o.readUshort(r2, a2);
          a2 += 2;
          for (f = 0; f < p; f++) {
            var U = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == U ? null : e.GSUB.readSubClassSet(r2, s + U));
          }
        }
      } else if (6 == t3 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r2, a2);
            a2 += 2;
            for (var g3 = [], S = 0; S < d; S++) g3.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * S)));
            a2 += 2 * d, 0 == f && (i.backCvg = g3), 1 == f && (i.inptCvg = g3), 2 == f && (i.ahedCvg = g3);
          }
          d = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, d);
        }
      } else {
        if (7 == t3 && 1 == i.fmt) {
          var m = o.readUshort(r2, a2);
          a2 += 2;
          var b = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype) n2.ltype = m;
          else if (n2.ltype != m) throw "invalid extension substitution";
          return e.GSUB.subt(r2, n2.ltype, s + b);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = t3, o = [], s = a2(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = {}, o = a2(r2, t3), s = a2(r2, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i = 0; i < o - 1; i++) n2.input.push(a2(r2, t3)), t3 += 2;
      return n2.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n2;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a2) {
      for (var n2 = e._bin.readUshort, o = [], s = 0; s < a2; s++) o.push(n2(r2, t3), n2(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a2 = e._bin, n2 = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t3);
        t3 += 2, 1 == s && i--, n2[o[s]] = a2.readUshorts(r2, t3, i), t3 += 2 * n2[o[s]].length;
      }
      i = a2.readUshort(r2, t3);
      return t3 += 2, n2.subst = a2.readUshorts(r2, t3, 2 * i), t3 += 2 * n2.subst.length, n2;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a2 = e._bin, n2 = { chain: [] };
      n2.nglyph = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++) n2.chain.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.head = {}, e.head.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.fontRevision = n2.readFixed(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, o.flags = n2.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n2.readUshort(r2, t3), t3 += 2, o.created = n2.readUint64(r2, t3), t3 += 8, o.modified = n2.readUint64(r2, t3), t3 += 8, o.xMin = n2.readShort(r2, t3), t3 += 2, o.yMin = n2.readShort(r2, t3), t3 += 2, o.xMax = n2.readShort(r2, t3), t3 += 2, o.yMax = n2.readShort(r2, t3), t3 += 2, o.macStyle = n2.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n2.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n2.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n2.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n2.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.ascender = n2.readShort(r2, t3), t3 += 2, o.descender = n2.readShort(r2, t3), t3 += 2, o.lineGap = n2.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n2.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n2.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n2.readShort(r2, t3), t3 += 2, o.xMaxExtent = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n2.readShort(r2, t3), t3 += 2, o.caretOffset = n2.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n2.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n2.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a2, n2) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, d = 0; d < n2.maxp.numGlyphs; d++) d < n2.hhea.numberOfHMetrics && (i = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s) return e.kern.parseV1(r2, t3 - 2, a2, n2);
      var i = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < i; d++) {
        t3 += 2;
        a2 = o.readUshort(r2, t3);
        t3 += 2;
        var f = o.readUshort(r2, t3);
        t3 += 2;
        var u2 = f >>> 8;
        if (0 != (u2 &= 15)) throw "unknown kern table format: " + u2;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a2, n2) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var d = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t3 = e.kern.readFormat0(r2, t3, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t3, a2) {
      var n2 = e._bin, o = -1, s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readShort(r2, t3);
        t3 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var u2 = a2.rval[a2.rval.length - 1];
        u2.glyph2.push(d), u2.vals.push(f), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = [], i = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r2, t3 + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r2, t3 + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {}, s = n2.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n2.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n2.readUshort(r2, t3), t3 += 2, o.maxContours = n2.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n2.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n2.readUshort(r2, t3), t3 += 2, o.maxZones = n2.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n2.readUshort(r2, t3), t3 += 2, o.maxStorage = n2.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxStackElements = n2.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n2.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n2.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n2.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t3 += 2, f = 0; f < s; f++) {
        var u2 = n2.readUshort(r2, t3);
        t3 += 2;
        var l = n2.readUshort(r2, t3);
        t3 += 2;
        var v = n2.readUshort(r2, t3);
        t3 += 2;
        var c = n2.readUshort(r2, t3);
        t3 += 2;
        var p = n2.readUshort(r2, t3);
        t3 += 2;
        var U = n2.readUshort(r2, t3);
        t3 += 2;
        var g3, S = h[c], m = d + 12 * s + U;
        if (0 == u2) g3 = n2.readUnicode(r2, m, p / 2);
        else if (3 == u2 && 0 == l) g3 = n2.readUnicode(r2, m, p / 2);
        else if (0 == l) g3 = n2.readASCII(r2, m, p);
        else if (1 == l) g3 = n2.readUnicode(r2, m, p / 2);
        else if (3 == l) g3 = n2.readUnicode(r2, m, p / 2);
        else {
          if (1 != u2) throw "unknown encoding " + l + ", platformID: " + u2;
          g3 = n2.readASCII(r2, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b = "p" + u2 + "," + v.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g3, o[b]._lang = v;
      }
      for (var y in o) if (null != o[y].postScriptName && 1033 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 0 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 3084 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName) return o[y];
      for (var y in o) {
        i = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a2) {
      var n2 = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n2) e["OS/2"].version0(r2, t3, o);
      else if (1 == n2) e["OS/2"].version1(r2, t3, o);
      else if (2 == n2 || 3 == n2 || 4 == n2) e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n2) throw "unknown OS/2 table version: " + n2;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a2) {
      var n2 = e._bin;
      return a2.xAvgCharWidth = n2.readShort(r2, t3), t3 += 2, a2.usWeightClass = n2.readUshort(r2, t3), t3 += 2, a2.usWidthClass = n2.readUshort(r2, t3), t3 += 2, a2.fsType = n2.readUshort(r2, t3), t3 += 2, a2.ySubscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutSize = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutPosition = n2.readShort(r2, t3), t3 += 2, a2.sFamilyClass = n2.readShort(r2, t3), t3 += 2, a2.panose = n2.readBytes(r2, t3, 10), t3 += 10, a2.ulUnicodeRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange2 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange3 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange4 = n2.readUint(r2, t3), t3 += 4, a2.achVendID = [n2.readInt8(r2, t3), n2.readInt8(r2, t3 + 1), n2.readInt8(r2, t3 + 2), n2.readInt8(r2, t3 + 3)], t3 += 4, a2.fsSelection = n2.readUshort(r2, t3), t3 += 2, a2.usFirstCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.usLastCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.sTypoAscender = n2.readShort(r2, t3), t3 += 2, a2.sTypoDescender = n2.readShort(r2, t3), t3 += 2, a2.sTypoLineGap = n2.readShort(r2, t3), t3 += 2, a2.usWinAscent = n2.readUshort(r2, t3), t3 += 2, a2.usWinDescent = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a2), a2.ulCodePageRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulCodePageRange2 = n2.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a2), a2.sxHeight = n2.readShort(r2, t3), t3 += 2, a2.sCapHeight = n2.readShort(r2, t3), t3 += 2, a2.usDefault = n2.readUshort(r2, t3), t3 += 2, a2.usBreak = n2.readUshort(r2, t3), t3 += 2, a2.usMaxContext = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a2), a2.usLowerOpticalPointSize = n2.readUshort(r2, t3), t3 += 2, a2.usUpperOpticalPointSize = n2.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return o.version = n2.readFixed(r2, t3), t3 += 4, o.italicAngle = n2.readFixed(r2, t3), t3 += 4, o.underlinePosition = n2.readShort(r2, t3), t3 += 2, o.underlineThickness = n2.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a2 = -1;
      if (null != t3.p0e4 ? a2 = t3.p0e4 : null != t3.p3e1 ? a2 = t3.p3e1 : null != t3.p1e0 ? a2 = t3.p1e0 : null != t3.p0e3 && (a2 = t3.p0e3), -1 == a2) throw "no familiar platform and encoding!";
      var n2 = t3.tables[a2];
      if (0 == n2.format) return e2 >= n2.map.length ? 0 : n2.map[e2];
      if (4 == n2.format) {
        for (var o = -1, s = 0; s < n2.endCount.length; s++) if (e2 <= n2.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n2.startCount[o] > e2) return 0;
        return 65535 & (0 != n2.idRangeOffset[o] ? n2.glyphIdArray[e2 - n2.startCount[o] + (n2.idRangeOffset[o] >> 1) - (n2.idRangeOffset.length - o)] : e2 + n2.idDelta[o]);
      }
      if (12 == n2.format) {
        if (e2 > n2.groups[n2.groups.length - 1][1]) return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i = n2.groups[s];
          if (i[0] <= e2 && e2 <= i[1]) return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n2 = r2.SVG.entries[t3];
        return null == n2 ? a2 : ("string" == typeof n2 && (n2 = e.SVG.toPath(n2), r2.SVG.entries[t3] = n2), n2);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; ) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i, a2);
      } else r2.glyf && e.U._drawGlyf(t3, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t3, a2) {
      var n2 = t3.glyf[r2];
      null == n2 && (n2 = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n2 && (n2.noc > -1 ? e.U._simpleGlyph(n2, a2) : e.U._compoGlyph(n2, t3, a2));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n2 = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n2; s <= o; s++) {
          var i = s == n2 ? o : s - 1, h = s == o ? n2 : s + 1, d = 1 & r2.flags[s], f = 1 & r2.flags[i], u2 = 1 & r2.flags[h], l = r2.xs[s], v = r2.ys[s];
          if (s == n2) if (d) {
            if (!f) {
              e.U.P.moveTo(t3, l, v);
              continue;
            }
            e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]);
          } else f ? e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t3, (r2.xs[i] + l) / 2, (r2.ys[i] + v) / 2);
          d ? f && e.U.P.lineTo(t3, l, v) : u2 ? e.U.P.qcurveTo(t3, l, v, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, l, v, (l + r2.xs[h]) / 2, (v + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a2) {
      for (var n2 = 0; n2 < r2.parts.length; n2++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n2];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h], f = o.crds[h + 1];
          a2.crds.push(d * i.a + f * i.b + i.tx), a2.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a2 = e._lctf.getInterval(t3, r2);
      return -1 == a2 ? 0 : t3[a2 + 2];
    }, e.U._applySubs = function(r2, t3, a2, n2) {
      for (var o = r2.length - t3 - 1, s = 0; s < a2.tabs.length; s++) if (null != a2.tabs[s]) {
        var i, h = a2.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
          if (1 == a2.ltype) r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i];
          else if (4 == a2.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
            var u2 = d[f], l = u2.chain.length;
            if (!(l > o)) {
              for (var v = true, c = 0, p = 0; p < l; p++) {
                for (; -1 == r2[t3 + c + (1 + p)]; ) c++;
                u2.chain[p] != r2[t3 + c + (1 + p)] && (v = false);
              }
              if (v) {
                r2[t3] = u2.nglyph;
                for (p = 0; p < l + c; p++) r2[t3 + p + 1] = -1;
                break;
              }
            }
          }
          else if (5 == a2.ltype && 2 == h.fmt) for (var U = e._lctf.getInterval(h.cDef, r2[t3]), g3 = h.cDef[U + 2], S = h.scset[g3], m = 0; m < S.length; m++) {
            var b = S[m], y = b.input;
            if (!(y.length > o)) {
              for (v = true, p = 0; p < y.length; p++) {
                var F = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p]);
                if (-1 == U && h.cDef[F + 2] != y[p]) {
                  v = false;
                  break;
                }
              }
              if (v) {
                var C3 = b.substLookupRecords;
                for (f = 0; f < C3.length; f += 2) C3[f], C3[f + 1];
              }
            }
          }
          else if (6 == a2.ltype && 3 == h.fmt) {
            if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length)) continue;
            if (!e.U._glsCovered(r2, h.inptCvg, t3)) continue;
            if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length)) continue;
            var _ = h.lookupRec;
            for (m = 0; m < _.length; m += 2) {
              U = _[m];
              var P = n2[_[m + 1]];
              e.U._applySubs(r2, t3 + U, P, n2);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r2, t3, a2) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e._lctf.coverageIndex(t3[n2], r2[a2 + n2])) return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a2) {
      for (var n2 = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i = t3[s];
        if (-1 != i) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, d = e.U.glyphToPath(r2, i), f = 0; f < d.crds.length; f += 2) n2.crds.push(d.crds[f] + o), n2.crds.push(d.crds[f + 1]);
          a2 && n2.cmds.push(a2);
          for (f = 0; f < d.cmds.length; f++) n2.cmds.push(d.cmds[f]);
          a2 && n2.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n2;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a2, n2, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a2, n2, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a2, n2) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a2, n2);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a2, n2, o) {
      for (var s = t3.stack, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open, u2 = 0, l = t3.x, v = t3.y, c = 0, p = 0, U = 0, g3 = 0, S = 0, m = 0, b = 0, y = 0, F = 0, C3 = 0, _ = { val: 0, size: 0 }; u2 < r2.length; ) {
        e.CFF.getCharString(r2, u2, _);
        var P = _.val;
        if (u2 += _.size, "o1" == P || "o18" == P) s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == P || "o23" == P) {
          s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == P) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), f && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), f = true;
        else if ("o5" == P) for (; s.length > 0; ) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
        else if ("o6" == P || "o7" == P) for (var x = s.length, I2 = "o6" == P, w = 0; w < x; w++) {
          var k = s.shift();
          I2 ? l += k : v += k, I2 = !I2, e.U.P.lineTo(o, l, v);
        }
        else if ("o8" == P || "o24" == P) {
          x = s.length;
          for (var G = 0; G + 6 <= x; ) c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g3 = p + s.shift(), l = U + s.shift(), v = g3 + s.shift(), e.U.P.curveTo(o, c, p, U, g3, l, v), G += 6;
          "o24" == P && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));
        } else {
          if ("o11" == P) break;
          if ("o1234" == P || "o1235" == P || "o1236" == P || "o1237" == P) "o1234" == P && (p = v, U = (c = l + s.shift()) + s.shift(), C3 = g3 = p + s.shift(), m = g3, y = v, l = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g3, F, C3), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1235" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g3 = p + s.shift(), F = U + s.shift(), C3 = g3 + s.shift(), S = F + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y = m + s.shift(), l = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U, g3, F, C3), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1236" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), C3 = g3 = p + s.shift(), m = g3, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U, g3, F, C3), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1237" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g3 = p + s.shift(), F = U + s.shift(), C3 = g3 + s.shift(), S = F + s.shift(), m = C3 + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - l) > Math.abs(y - v) ? l = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p, U, g3, F, C3), e.U.P.curveTo(o, S, m, b, y, l, v));
          else if ("o14" == P) {
            if (s.length > 0 && !h && (d = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var O = s.shift(), T3 = s.shift(), D = s.shift(), B2 = s.shift(), A2 = e.CFF.glyphBySE(a2, D), R2 = e.CFF.glyphBySE(a2, B2);
              e.U._drawCFF(a2.CharStrings[A2], t3, a2, n2, o), t3.x = O, t3.y = T3, e.U._drawCFF(a2.CharStrings[R2], t3, a2, n2, o);
            }
            f && (e.U.P.closePath(o), f = false);
          } else if ("o19" == P || "o20" == P) {
            s.length % 2 != 0 && !h && (d = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, u2 += i + 7 >> 3;
          } else if ("o21" == P) s.length > 2 && !h && (d = s.shift() + n2.nominalWidthX, h = true), v += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = true;
          else if ("o22" == P) s.length > 1 && !h && (d = s.shift() + n2.nominalWidthX, h = true), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = true;
          else if ("o25" == P) {
            for (; s.length > 6; ) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
            c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g3 = p + s.shift(), l = U + s.shift(), v = g3 + s.shift(), e.U.P.curveTo(o, c, p, U, g3, l, v);
          } else if ("o26" == P) for (s.length % 2 && (l += s.shift()); s.length > 0; ) c = l, p = v + s.shift(), l = U = c + s.shift(), v = (g3 = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g3, l, v);
          else if ("o27" == P) for (s.length % 2 && (v += s.shift()); s.length > 0; ) p = v, U = (c = l + s.shift()) + s.shift(), g3 = p + s.shift(), l = U + s.shift(), v = g3, e.U.P.curveTo(o, c, p, U, g3, l, v);
          else if ("o10" == P || "o29" == P) {
            var L = "o10" == P ? n2 : a2;
            if (0 == s.length) console.debug("error: empty stack");
            else {
              var W = s.pop(), M = L.Subrs[W + L.Bias];
              t3.x = l, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f, e.U._drawCFF(M, t3, a2, n2, o), l = t3.x, v = t3.y, i = t3.nStems, h = t3.haveWidth, d = t3.width, f = t3.open;
            }
          } else if ("o30" == P || "o31" == P) {
            var V = s.length, E = (G = 0, "o31" == P);
            for (G += V - (x = -3 & V); G < x; ) E ? (p = v, U = (c = l + s.shift()) + s.shift(), v = (g3 = p + s.shift()) + s.shift(), x - G == 5 ? (l = U + s.shift(), G++) : l = U, E = false) : (c = l, p = v + s.shift(), U = c + s.shift(), g3 = p + s.shift(), l = U + s.shift(), x - G == 5 ? (v = g3 + s.shift(), G++) : v = g3, E = true), e.U.P.curveTo(o, c, p, U, g3, l, v), G += 4;
          } else {
            if ("o" == (P + "").charAt(0)) throw console.debug("Unknown operation: " + P, r2), P;
            s.push(P);
          }
        }
      }
      t3.x = l, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = d, t3.open = f;
    };
    var t2 = e, a = { Typr: t2 };
    return r.Typr = t2, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n2(31), i2 = 0; i2 < 31; ++i2) a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t2(a2[30]);
      for (i2 = 1; i2 < 30; ++i2) for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2) o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u2 = f(a, 2), v = u2[0], s = u2[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n2(32768), g3 = 0; g3 < 32768; ++g3) {
      var h = (43690 & g3) >>> 1 | (21845 & g3) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g3] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a2 = r2.length, i2 = 0, o2 = new n2(e2); i2 < a2; ++i2) ++o2[r2[i2] - 1];
      var f2, u3 = new n2(e2);
      for (i2 = 0; i2 < e2; ++i2) u3[i2] = u3[i2 - 1] + o2[i2 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e2);
        var v4 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2) if (r2[i2]) for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g4 = u3[r2[i2] - 1]++ << l2, h2 = g4 | (1 << l2) - 1; g4 <= h2; ++g4) f2[c[g4] >>> v4] = s2;
      } else for (f2 = new n2(a2), i2 = 0; i2 < a2; ++i2) r2[i2] && (f2[i2] = c[u3[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g3 = 0; g3 < 144; ++g3) d[g3] = 8;
    for (g3 = 144; g3 < 256; ++g3) d[g3] = 9;
    for (g3 = 256; g3 < 280; ++g3) d[g3] = 7;
    for (g3 = 280; g3 < 288; ++g3) d[g3] = 8;
    var m = new e(32);
    for (g3 = 0; g3 < 32; ++g3) m[g3] = 5;
    var b = w(d, 9, 1), p = w(m, 5, 1), y = function(r2) {
      for (var e2 = r2[0], n3 = 1; n3 < r2.length; ++n3) r2[n3] > e2 && (e2 = r2[n3]);
      return e2;
    }, L = function(r2, e2, n3) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n3;
    }, U = function(r2, e2) {
      var n3 = e2 / 8 | 0;
      return (r2[n3] | r2[n3 + 1] << 8 | r2[n3 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T3 = function(r2, e2, n3) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T3), !n3) throw t3;
      return t3;
    }, O = function(r2, f2, u3) {
      var s2 = r2.length;
      if (!s2 || u3 && !u3.l && s2 < 5) return f2 || new e(0);
      var c2 = !f2 || u3, g4 = !u3 || u3.i;
      u3 || (u3 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n3 = f2.length;
        if (r3 > n3) {
          var t3 = new e(Math.max(2 * n3, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u3.f || 0, k2 = u3.p || 0, O2 = u3.b || 0, A3 = u3.l, x2 = u3.d, E = u3.m, D = u3.n, M = 8 * s2;
      do {
        if (!A3) {
          u3.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V = r2[(I2 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I2 - 3] << 8, _ = I2 + V;
            if (_ > s2) {
              g4 && T3(0);
              break;
            }
            c2 && d2(O2 + V), f2.set(r2.subarray(I2, _), O2), u3.b = O2 += V, u3.p = k2 = 8 * _;
            continue;
          }
          if (1 == S) A3 = b, x2 = p, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r2, k2, 31) + 257, z = L(r2, k2 + 10, 15) + 4, C3 = j + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e(C3), P = new e(19), q = 0; q < z; ++q) P[o[q]] = L(r2, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B2 = y(P), G = (1 << B2) - 1, H = w(P, B2, 1);
            for (q = 0; q < C3; ) {
              var I2, J = H[L(r2, k2, G)];
              if (k2 += 15 & J, (I2 = J >>> 4) < 16) F[q++] = I2;
              else {
                var K2 = 0, N = 0;
                for (16 == I2 ? (N = 3 + L(r2, k2, 3), k2 += 2, K2 = F[q - 1]) : 17 == I2 ? (N = 3 + L(r2, k2, 7), k2 += 3) : 18 == I2 && (N = 11 + L(r2, k2, 127), k2 += 7); N--; ) F[q++] = K2;
              }
            }
            var Q2 = F.subarray(0, j), R2 = F.subarray(j);
            E = y(Q2), D = y(R2), A3 = w(Q2, E, 1), x2 = w(R2, D, 1);
          } else T3(1);
          if (k2 > M) {
            g4 && T3(0);
            break;
          }
        }
        c2 && d2(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K2 = A3[U(r2, k2) & W]) >>> 4;
          if ((k2 += 15 & K2) > M) {
            g4 && T3(0);
            break;
          }
          if (K2 || T3(2), Z < 256) f2[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A3 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a[q = Z - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v[q], k2 += rr;
            }
            var er = x2[U(r2, k2) & X], nr = er >>> 4;
            er || T3(3), k2 += 15 & er;
            R2 = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R2 += U(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g4 && T3(0);
              break;
            }
            c2 && d2(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4) f2[O2] = f2[O2 - R2], f2[O2 + 1] = f2[O2 + 1 - R2], f2[O2 + 2] = f2[O2 + 2 - R2], f2[O2 + 3] = f2[O2 + 3 - R2];
            O2 = tr;
          }
        }
        u3.l = A3, u3.p = Y, u3.b = O2, A3 && (m2 = 1, u3.m = E, u3.d = x2, u3.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n2 ? n2 : r3 instanceof t2 ? t2 : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O2);
    }, A2 = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A2, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n3 = 0;
      function t3() {
        var r3 = e2.getUint16(n3);
        return n3 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n3);
        return n3 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b2, r3), b2 += 2;
      }
      function o2(r3) {
        m2.setUint32(b2, r3), b2 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t3(), reserved: t3(), totalSfntSize: a2(), majorVersion: t3(), minorVersion: t3(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u3 = 0; Math.pow(2, u3) <= f2.numTables; ) u3++;
      u3--;
      for (var v4 = 16 * Math.pow(2, u3), s2 = 16 * f2.numTables - v4, l2 = 12, c2 = [], g4 = 0; g4 < f2.numTables; g4++) c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b2 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v4), i2(u3), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n4, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n4 = new Uint8Array(t4, 2), O(n4, a3);
        } else a3 = new Uint8Array(t4);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535) i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3);
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId];
      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j = 0; j < lookup.tabs.length; j++) {
            const tab = lookup.tabs[j];
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            } else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k = 0; k < right.length; k++) {
                      if (right[k].gid2 === glyphId) adj = right[k];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            } else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            } else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "number") {
        return args[i];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x = crds[i2];
                  let y = crds[i2 + 1];
                  if (x < xMin) xMin = x;
                  if (y < yMin) yMin = y;
                  if (x > xMax) xMax = x;
                  if (y > yMax) yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(
              null,
              glyphObj,
              penX + positions[i * 3] * fontScale,
              positions[i * 3 + 1] * fontScale,
              charIndex
            );
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
function unicodeFontResolverClientFactory() {
  return function(t2) {
    var n2 = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    n2.prototype.add = function(t3) {
      var n3 = t3 >> 5;
      this.buckets.set(n3, (this.buckets.get(n3) || 0) | 1 << (31 & t3));
    }, n2.prototype.has = function(t3) {
      var n3 = this.buckets.get(t3 >> 5);
      return void 0 !== n3 && 0 != (n3 & 1 << (31 & t3));
    }, n2.prototype.serialize = function() {
      var t3 = [];
      return this.buckets.forEach(function(n3, r2) {
        t3.push((+r2).toString(36) + ":" + n3.toString(36));
      }), t3.join(",");
    }, n2.prototype.deserialize = function(t3) {
      var n3 = this;
      this.buckets.clear(), t3.split(",").forEach(function(t4) {
        var r2 = t4.split(":");
        n3.buckets.set(parseInt(r2[0], 36), parseInt(r2[1], 36));
      });
    };
    var r = Math.pow(2, 8), e = r - 1, o = ~e;
    function a(t3) {
      var n3 = function(t4) {
        return t4 & o;
      }(t3).toString(16), e2 = function(t4) {
        return (t4 & o) + r - 1;
      }(t3).toString(16);
      return "codepoint-index/plane" + (t3 >> 16) + "/" + n3 + "-" + e2 + ".json";
    }
    function i(t3, n3) {
      var r2 = t3 & e, o2 = n3.codePointAt(r2 / 6 | 0);
      return 0 != ((o2 = (o2 || 48) - 48) & 1 << r2 % 6);
    }
    function u2(t3, n3) {
      var r2;
      (r2 = t3, r2.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(t4) {
        return t4.split("-").map(function(t5) {
          return parseInt(t5.trim(), 16);
        });
      })).forEach(function(t4) {
        var r3 = t4[0], e2 = t4[1];
        void 0 === e2 && (e2 = r3), n3(r3, e2);
      });
    }
    function c(t3, n3) {
      u2(t3, function(t4, r2) {
        for (var e2 = t4; e2 <= r2; e2++) n3(e2);
      });
    }
    var s = {}, f = {}, l = /* @__PURE__ */ new WeakMap(), v = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t3) {
      var r2 = l.get(t3);
      return r2 || (r2 = new n2(), c(t3.ranges, function(t4) {
        return r2.add(t4);
      }), l.set(t3, r2)), r2;
    }
    var h, p = /* @__PURE__ */ new Map();
    function g3(t3, n3, r2) {
      return t3[n3] ? n3 : t3[r2] ? r2 : function(t4) {
        for (var n4 in t4) return n4;
      }(t3);
    }
    function w(t3, n3) {
      var r2 = n3;
      if (!t3.includes(r2)) {
        r2 = 1 / 0;
        for (var e2 = 0; e2 < t3.length; e2++) Math.abs(t3[e2] - n3) < Math.abs(r2 - n3) && (r2 = t3[e2]);
      }
      return r2;
    }
    function k(t3) {
      return h || (h = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(t4) {
        h.add(t4);
      })), h.has(t3);
    }
    return t2.CodePointSet = n2, t2.clearCache = function() {
      s = {}, f = {};
    }, t2.getFontsForString = function(t3, n3) {
      void 0 === n3 && (n3 = {});
      var r2, e2 = n3.lang;
      void 0 === e2 && (e2 = new RegExp("\\p{Script=Hangul}", "u").test(r2 = t3) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(r2) ? "ja" : "en");
      var o2 = n3.category;
      void 0 === o2 && (o2 = "sans-serif");
      var u3 = n3.style;
      void 0 === u3 && (u3 = "normal");
      var c2 = n3.weight;
      void 0 === c2 && (c2 = 400);
      var l2 = (n3.dataUrl || v).replace(/\/$/g, ""), h2 = /* @__PURE__ */ new Map(), y = new Uint8Array(t3.length), b = {}, m = {}, A2 = new Array(t3.length), S = /* @__PURE__ */ new Map(), j = false;
      function M(t4) {
        var n4 = p.get(t4);
        return n4 || (n4 = fetch(l2 + "/" + t4).then(function(t5) {
          if (!t5.ok) throw new Error(t5.statusText);
          return t5.json().then(function(t6) {
            if (!Array.isArray(t6) || 1 !== t6[0]) throw new Error("Incorrect schema version; need 1, got " + t6[0]);
            return t6[1];
          });
        }).catch(function(n5) {
          if (l2 !== v) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l2 + '", trying default CDN. ' + n5.message), j = true), l2 = v, p.delete(t4), M(t4);
          throw n5;
        }), p.set(t4, n4)), n4;
      }
      for (var P = function(n4) {
        var r3 = t3.codePointAt(n4), e3 = a(r3);
        A2[n4] = e3, s[e3] || S.has(e3) || S.set(e3, M(e3).then(function(t4) {
          s[e3] = t4;
        })), r3 > 65535 && (n4++, E = n4);
      }, E = 0; E < t3.length; E++) P(E);
      return Promise.all(S.values()).then(function() {
        S.clear();
        for (var n4 = function(n5) {
          var o3 = t3.codePointAt(n5), a2 = null, u4 = s[A2[n5]], c3 = void 0;
          for (var l3 in u4) {
            var v4 = m[l3];
            if (void 0 === v4 && (v4 = m[l3] = new RegExp(l3).test(e2 || "en")), v4) {
              for (var d2 in c3 = l3, u4[l3]) if (i(o3, u4[l3][d2])) {
                a2 = d2;
                break;
              }
              break;
            }
          }
          if (!a2) {
            t: for (var h3 in u4) if (h3 !== c3) {
              for (var p2 in u4[h3]) if (i(o3, u4[h3][p2])) {
                a2 = p2;
                break t;
              }
            }
          }
          a2 || (console.debug("No font coverage for U+" + o3.toString(16)), a2 = "latin"), A2[n5] = a2, f[a2] || S.has(a2) || S.set(a2, M("font-meta/" + a2 + ".json").then(function(t4) {
            f[a2] = t4;
          })), o3 > 65535 && (n5++, r3 = n5);
        }, r3 = 0; r3 < t3.length; r3++) n4(r3);
        return Promise.all(S.values());
      }).then(function() {
        for (var n4, r3 = null, e3 = 0; e3 < t3.length; e3++) {
          var a2 = t3.codePointAt(e3);
          if (r3 && (k(a2) || d(r3).has(a2))) y[e3] = y[e3 - 1];
          else {
            r3 = f[A2[e3]];
            var i2 = b[r3.id];
            if (!i2) {
              var s2 = r3.typeforms, v4 = g3(s2, o2, "sans-serif"), p2 = g3(s2[v4], u3, "normal"), m2 = w(null === (n4 = s2[v4]) || void 0 === n4 ? void 0 : n4[p2], c2);
              i2 = b[r3.id] = l2 + "/font-files/" + r3.id + "/" + v4 + "." + p2 + "." + m2 + ".woff";
            }
            var S2 = h2.get(i2);
            null == S2 && (S2 = h2.size, h2.set(i2, S2)), y[e3] = S2;
          }
          a2 > 65535 && (e3++, y[e3] = y[e3 - 1]);
        }
        return { fontUrls: Array.from(h2.keys()), chars: y };
      });
    }, Object.defineProperty(t2, "__esModule", { value: true }), t2;
  }({});
}
function createFontResolver(fontParser, unicodeFontResolverClient) {
  const parsedFonts = /* @__PURE__ */ Object.create(null);
  const loadingFonts = /* @__PURE__ */ Object.create(null);
  function doLoadFont(url, callback) {
    const onError = (err) => {
      console.error(`Failure loading font ${url}`, err);
    };
    try {
      const request = new XMLHttpRequest();
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.status >= 400) {
          onError(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError(e);
          }
        }
      };
      request.onerror = onError;
      request.send();
    } catch (err) {
      onError(err);
    }
  }
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, (fontObj) => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach((cb) => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }
  return function(text, callback, {
    lang,
    fonts: userFonts = [],
    style = "normal",
    weight = "normal",
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = /* @__PURE__ */ new Map();
    const fallbackRanges = [];
    if (style !== "italic") style = "normal";
    if (typeof weight !== "number") {
      weight = weight === "bold" ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice().filter((def) => !def.lang || def.lang.test(lang)).reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {
              if (j === jLen) {
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j;
                const { src, unicodeRange } = userFonts[j];
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== "number") {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 65535 && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        const fallbackString = fallbackRanges.map((range) => text.substring(range[0], range[1] + 1)).join("\n");
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || void 0,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({ fontUrls, chars }) => {
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach((range) => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++;
          });
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, (fontObj) => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      for (let k = 0; k < ranges.length; k++) {
        const [start, end = start] = ranges[k];
        if (start <= code && code <= end) {
          return true;
        }
      }
      return false;
    }
  };
}
var fontResolverWorkerModule = defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(createFontResolver2, fontParser, unicodeFontResolverClientFactory2) {
    return createFontResolver2(fontParser, unicodeFontResolverClientFactory2());
  }
});
function createTypesetter(resolveFonts, bidi) {
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {
    const onResolved = ({ chars, fonts: parsedFonts }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]] });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(
        text,
        onResolved,
        { lang, fonts, style, weight, unicodeFontsURL }
      );
    }
  }
  function typeset({
    text = "",
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = "normal",
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === "string" ? [{ src: font }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, (runs) => {
      timings.fontLoad = now2() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const metricsByFont = /* @__PURE__ */ new Map();
      const typesetStart = now2();
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach((run) => {
        const { fontObj } = run;
        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
        let fontData2 = metricsByFont.get(fontObj);
        if (!fontData2) {
          const fontSizeMult2 = fontSize / unitsPerEm;
          const calcLineHeight = lineHeight === "normal" ? (ascender - descender + lineGap) * fontSizeMult2 : lineHeight * fontSize;
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult2) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult2);
          const caretTop = (ascender + descender) / 2 * fontSizeMult2 + caretHeight / 2;
          fontData2 = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult: fontSizeMult2,
            unitsPerEm,
            ascender: ascender * fontSizeMult2,
            descender: descender * fontSizeMult2,
            capHeight: capHeight * fontSizeMult2,
            xHeight: xHeight * fontSizeMult2,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult2,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData2);
        }
        const { fontSizeMult } = fontData2;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;
          if (!("isEmpty" in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              for (let i = curLineCount; i--; ) {
                if (i === 0 && overflowWrap === "break-word") {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j = nextLine.count; j--; ) {
                    nextLine.glyphAt(j).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth;
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData2;
          if (char === "\n") {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });
      let totalHeight = 0;
      lines.forEach((line) => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--; ) {
          const glyphInfo = line.glyphAt(i);
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          let { lineHeight: lineHeight2, capHeight, xHeight, baseline } = glyphInfo.fontData;
          if (lineHeight2 > line.lineHeight) line.lineHeight = lineHeight2;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -lines[0].baseline : anchorY === "top-cap" ? -lines[0].cap : anchorY === "top-ex" ? -lines[0].ex : anchorY === "middle" ? totalHeight / 2 : anchorY === "bottom" ? totalHeight : anchorY === "bottom-baseline" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g3) => glyphObj = g3;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex, fontData: fontData2 } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData2.caretBottom + anchorYOffset;
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData2.caretTop + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      const fontData = [];
      metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight }) => {
        fontData[index] = { src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight };
      });
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - totalHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset({ ...args, metricsOnly: true }, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
    }
  );
}
var queue = [];
var chunkTimeBudget = 5;
var timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
var generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({ timing: now() - start });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
var threadCount = 4;
var idleTimeout = 2e3;
var threads = {};
var callNum = 0;
function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now2) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now2();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now2() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);
    timing += now() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
var CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now$1();
  const { defaultFontURL } = CONFIG;
  const fonts = [];
  if (defaultFontURL) {
    fonts.push({ label: "default", src: toAbsoluteURL(defaultFontURL) });
  }
  if (args.font) {
    fonts.push({ label: "user", src: toAbsoluteURL(args.font) });
  }
  args.font = fonts;
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    const fontGlyphMaps = fontData.map((font) => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = /* @__PURE__ */ new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const { src: fontSrc, unitsPerEm } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[fontSrc][glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function preloadFont({ font, characters, sdfGlyphSize }, callback) {
  let text = Array.isArray(characters) ? characters.join("\n") : "" + characters;
  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);
}
function assign3(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidi_default
  ],
  init(createTypesetter2, fontResolver, bidiFactory) {
    return createTypesetter2(fontResolver, bidiFactory());
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
var templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    const front = new PlaneGeometry(1, 1, detail, detail);
    const back = front.clone();
    const frontAttrs = front.attributes;
    const backAttrs = back.attributes;
    const combined = new BufferGeometry();
    const vertCount = frontAttrs.uv.count;
    for (let i = 0; i < vertCount; i++) {
      backAttrs.position.array[i * 3] *= -1;
      backAttrs.normal.array[i * 3 + 2] *= -1;
    }
    ["position", "normal", "uv"].forEach((name) => {
      combined.setAttribute(
        name,
        new Float32BufferAttribute(
          [...frontAttrs[name].array, ...backAttrs[name].array],
          frontAttrs[name].itemSize
        )
      );
    });
    combined.setIndex([...front.index.array, ...back.index.array.map((n2) => n2 + vertCount)]);
    combined.translate(0.5, 0.5, 0);
    geom = templateGeometries[detail] = combined;
  }
  return geom;
}
var glyphBoundsAttrName = "aTroikaGlyphBounds";
var glyphIndexAttrName = "aTroikaGlyphIndex";
var glyphColorAttrName = "aTroikaGlyphColor";
var GlyphsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(side) {
    const verts = this.getIndex().count;
    this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--; ) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
};
function updateBufferAttr(geom, attrName, newArray, itemSize) {
  const attr = geom.getAttribute(attrName);
  if (newArray) {
    if (attr && attr.array.length === newArray.length) {
      attr.array.set(newArray);
      attr.needsUpdate = true;
    } else {
      geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
      delete geom._maxInstanceCount;
      geom.dispose();
    }
  } else if (attr) {
    geom.deleteAttribute(attrName);
  }
}
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: vertexShader8, fragmentShader: fragmentShader8 }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader8)) {
        fragmentShader8 = fragmentShader8.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader8)) {
          vertexShader8 = vertexShader8.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader: vertexShader8, fragmentShader: fragmentShader8 };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
var defaultStrokeColor = 8421504;
var tempMat4 = new Matrix4();
var tempVec3a = new Vector3();
var tempVec3b = new Vector3();
var tempArray = [];
var origin = new Vector3();
var defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
var getFlatRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
var syncStartEvent = { type: "syncstart" };
var syncCompleteEvent = { type: "synccomplete" };
var SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text = class extends Mesh {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.unicodeFontsURL = null;
    this.fontSize = 0.1;
    this.fontWeight = "normal";
    this.fontStyle = "normal";
    this.lang = null;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || "normal",
          fontStyle: this.fontStyle || "normal",
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }
    material._hadOwnSide = material.hasOwnProperty("side");
    this.geometry.setSide(material._actualSide = material.side);
    material.side = FrontSide;
  }
  onAfterRender(renderer, scene, camera, geometry, material, group) {
    if (material._hadOwnSide) {
      material.side = material._actualSide;
    } else {
      delete material.side;
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaDistanceOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material.color;
    } else {
      const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
      if (color !== colorObj._input || typeof color === "object") {
        colorObj.set(colorObj._input = color);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position, target = new Vector2()) {
    target.copy(position);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position, target = new Vector2()) {
    tempVec3a.copy(position);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position, uv } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z = 0;
        if (curveRadius) {
          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position.setXYZ(i, x, y, z);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i = 0; i < tempArray.length; i++) {
        tempArray[i].object = this;
        intersects.push(tempArray[i]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop) => {
      this[prop] = source[prop];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((prop) => {
  const privateKey = "_private_" + prop;
  Object.defineProperty(Text.prototype, prop, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});

// node_modules/@threlte/extras/dist/components/Text/Text.svelte
var get_default_slot_changes25 = (dirty) => ({ ref: dirty & /*ref*/
8 });
var get_default_slot_context25 = (ctx) => ({ ref: (
  /*ref*/
  ctx[3]
) });
function create_default_slot29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context25
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        520)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes25
            ),
            get_default_slot_context25
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot29.name,
    type: "slot",
    source: "(24:0) <T   is={ref}   let:ref   {...$$restProps}   {font}   {characters}   {sdfGlyphSize}   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[6],
    { font: (
      /*font*/
      ctx[0]
    ) },
    { characters: (
      /*characters*/
      ctx[1]
    ) },
    { sdfGlyphSize: (
      /*sdfGlyphSize*/
      ctx[2]
    ) }
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot29, ({ ref }) => ({ 3: ref }), ({ ref }) => ref ? 8 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[8](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps, font, characters, sdfGlyphSize*/
      79 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        8 && { is: (
          /*ref*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        ),
        dirty & /*font*/
        1 && { font: (
          /*font*/
          ctx2[0]
        ) },
        dirty & /*characters*/
        2 && { characters: (
          /*characters*/
          ctx2[1]
        ) },
        dirty & /*sdfGlyphSize*/
        4 && { sdfGlyphSize: (
          /*sdfGlyphSize*/
          ctx2[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope, ref*/
      520) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = ["font", "characters", "sdfGlyphSize", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { font = void 0 } = $$props;
  let { characters = void 0 } = $$props;
  let { sdfGlyphSize = void 0 } = $$props;
  const ref = new Text();
  const { invalidate } = useThrelte();
  const dispatch = createEventDispatcher();
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(4, $component = value));
  const onUpdate = async () => {
    await tick();
    ref.sync(() => {
      invalidate();
      dispatch("sync");
    });
  };
  const suspend = useSuspense();
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("font" in $$new_props) $$invalidate(0, font = $$new_props.font);
    if ("characters" in $$new_props) $$invalidate(1, characters = $$new_props.characters);
    if ("sdfGlyphSize" in $$new_props) $$invalidate(2, sdfGlyphSize = $$new_props.sdfGlyphSize);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useThrelte,
    createEventDispatcher,
    tick,
    preloadFont,
    Text,
    useSuspense,
    font,
    characters,
    sdfGlyphSize,
    ref,
    invalidate,
    dispatch,
    component,
    onUpdate,
    suspend,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("font" in $$props) $$invalidate(0, font = $$new_props.font);
    if ("characters" in $$props) $$invalidate(1, characters = $$new_props.characters);
    if ("sdfGlyphSize" in $$props) $$invalidate(2, sdfGlyphSize = $$new_props.sdfGlyphSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: $$restProps && onUpdate();
    if ($$self.$$.dirty & /*font, characters, sdfGlyphSize*/
    7) {
      $: suspend(new Promise((res) => preloadFont({ font, characters, sdfGlyphSize }, res)));
    }
  };
  return [
    font,
    characters,
    sdfGlyphSize,
    ref,
    $component,
    component,
    $$restProps,
    slots,
    t_binding,
    $$scope
  ];
}
var Text_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      font: 0,
      characters: 1,
      sdfGlyphSize: 2,
      ref: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text_1",
      options,
      id: create_fragment38.name
    });
  }
  get font() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get characters() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set characters(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sdfGlyphSize() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sdfGlyphSize(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[3];
  }
  set ref(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text_1;

// node_modules/@threlte/extras/dist/audio/useThrelteAudio.js
function useThrelteAudio() {
  const audioCtx = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (listener, id) => {
      id = id ?? "default";
      if (audioCtx.audioListeners.has(id)) {
        console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
        return;
      }
      audioCtx.audioListeners.set(id, listener);
    },
    removeAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      audioCtx.audioListeners.delete(id);
    },
    getAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      return audioCtx.audioListeners.get(id);
    }
  };
  return useThrelteUserContext("threlte-audio", audioCtx);
}

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
var get_default_slot_changes26 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context26 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context26
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes26
            ),
            get_default_slot_context26
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot30.name,
    type: "slot",
    source: "(20:0) <T   is={ref}   {...$$restProps}   let:ref   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot30, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[9](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      1025) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[9](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "masterVolume", "ref", "audioContext", "resumeContext"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioListener", slots, ["default"]);
  let { id = void 0 } = $$props;
  let { masterVolume = void 0 } = $$props;
  const ref = new AudioListener();
  const audioContext = ref.context;
  const resumeContext = async () => await ref.context.resume();
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(ref, id);
  onDestroy(() => {
    removeAudioListener(id);
  });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    if ("masterVolume" in $$new_props) $$invalidate(5, masterVolume = $$new_props.masterVolume);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    onDestroy,
    ThreeAudioListener: AudioListener,
    useThrelteAudio,
    id,
    masterVolume,
    ref,
    audioContext,
    resumeContext,
    addAudioListener,
    removeAudioListener,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    if ("masterVolume" in $$props) $$invalidate(5, masterVolume = $$new_props.masterVolume);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*masterVolume*/
    32) {
      $: if (masterVolume !== void 0) ref.setMasterVolume(masterVolume);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    id,
    masterVolume,
    audioContext,
    resumeContext,
    slots,
    t_binding,
    $$scope
  ];
}
var AudioListener2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      id: 4,
      masterVolume: 5,
      ref: 0,
      audioContext: 6,
      resumeContext: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioListener",
      options,
      id: create_fragment39.name
    });
  }
  get id() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masterVolume() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masterVolume(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audioContext() {
    return this.$$.ctx[6];
  }
  set audioContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resumeContext() {
    return this.$$.ctx[7];
  }
  set resumeContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioListener_default = AudioListener2;

// node_modules/@threlte/extras/dist/audio/utils/useAudio.js
var useAudio = (audio) => {
  const loaded = currentWritable(false);
  const autoplay = currentWritable(false);
  const shouldPlay = currentWritable(false);
  let audioDestroyed = false;
  const loader = useLoader(AudioLoader);
  const dispatch = createRawEventDispatcher();
  const setSrc = async (source) => {
    var _a;
    loaded.set(false);
    try {
      if (typeof source === "string") {
        const audioBuffer = await loader.load(source, {
          onProgress(event) {
            dispatch("progress", event);
          }
        });
        audio.setBuffer(audioBuffer);
      } else if (source instanceof AudioBuffer) {
        audio.setBuffer(source);
      } else if (source instanceof HTMLMediaElement) {
        audio.setMediaElementSource(source);
      } else if (source instanceof AudioBufferSourceNode) {
        audio.setNodeSource(source);
      } else if (source instanceof MediaStream) {
        audio.setMediaStreamSource(source);
      }
      loaded.set(true);
      ((_a = audio.source) == null ? void 0 : _a.buffer) ? dispatch("load", audio.source.buffer) : dispatch("load");
    } catch (error) {
      dispatch("error", error);
    }
  };
  const setVolume = (volume) => {
    audio.setVolume(volume ?? 1);
  };
  const setPlaybackRate = (playbackRate) => {
    audio.setPlaybackRate(playbackRate ?? 1);
  };
  const play = async (delay) => {
    if (!loaded.current) {
      shouldPlay.set(true);
      return;
    }
    if (audio.context.state !== "running") {
      await audio.context.resume();
      if (audioDestroyed) {
        return;
      }
    }
    return audio.play(delay);
  };
  const pause = () => {
    return audio.pause();
  };
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setAutoPlay = (value) => {
    autoplay.set(value ?? false);
  };
  const setDetune = (value) => {
    if (audio.source && audio.source.detune) {
      audio.setDetune(value ?? 0);
    }
  };
  const setLoop = (value) => {
    audio.setLoop(value ?? false);
  };
  watch([loaded, autoplay, shouldPlay], ([loaded2, autoplay2, shouldPlay2]) => {
    if (!loaded2) {
      if (audio.isPlaying)
        stop();
      return;
    }
    if (autoplay2 || shouldPlay2) {
      play();
    }
  });
  onDestroy(() => {
    try {
      audioDestroyed = true;
      stop();
    } catch (error) {
      console.warn("Error while destroying audio", error);
    }
  });
  return {
    setVolume,
    setSrc,
    setPlaybackRate,
    setAutoPlay,
    setDetune,
    setLoop,
    play,
    pause,
    stop
  };
};

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
var { Error: Error_16 } = globals;
var get_default_slot_changes27 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context27 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context27
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        65537)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes27
            ),
            get_default_slot_context27
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot31.name,
    type: "slot",
    source: "(29:0) <T   is={ref}   {...$$restProps}   let:ref   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot31, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[15](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      65537) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[15](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Audio", slots, ["default"]);
  let { src } = $$props;
  let { id = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const ref = new Audio(listener);
  const { pause, play, stop, setAutoPlay, setDetune, setLoop, setPlaybackRate, setSrc, setVolume } = useAudio(ref);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<Audio> was created without expected prop 'src'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props) $$invalidate(4, src = $$new_props.src);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$new_props) $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$new_props) $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$new_props) $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$new_props) $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$new_props) $$invalidate(10, loop = $$new_props.loop);
    if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    ThreeAudio: Audio,
    useAudio,
    useThrelteAudio,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    getAudioListener,
    listener,
    ref,
    pause,
    play,
    stop,
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc,
    setVolume,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props) $$invalidate(4, src = $$new_props.src);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$props) $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$props) $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$props) $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$props) $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$props) $$invalidate(10, loop = $$new_props.loop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoplay*/
    256) {
      $: setAutoPlay(autoplay);
    }
    if ($$self.$$.dirty & /*src*/
    16) {
      $: setSrc(src);
    }
    if ($$self.$$.dirty & /*volume*/
    64) {
      $: setVolume(volume);
    }
    if ($$self.$$.dirty & /*playbackRate*/
    128) {
      $: setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty & /*loop*/
    1024) {
      $: setLoop(loop);
    }
    if ($$self.$$.dirty & /*detune*/
    512) {
      $: setDetune(detune);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    pause,
    play,
    stop,
    slots,
    t_binding,
    $$scope
  ];
}
var Audio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      ref: 0,
      pause: 11,
      play: 12,
      stop: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Audio",
      options,
      id: create_fragment40.name
    });
  }
  get src() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_16("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[11];
  }
  set pause(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[12];
  }
  set play(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[13];
  }
  set stop(value) {
    throw new Error_16("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Audio_default = Audio2;

// node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte
var { Error: Error_17 } = globals;
var get_default_slot_changes28 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context28 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_default_slot_context28
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        2097153)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_default_slot_changes28
            ),
            get_default_slot_context28
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot32.name,
    type: "slot",
    source: "(47:0) <T   is={ref}   {...$$restProps}   let:ref   bind:this={$component} >",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot32, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[20](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      2097153) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[20](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudio", slots, ["default"]);
  let { src } = $$props;
  let { id = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { directionalCone = void 0 } = $$props;
  let { refDistance = void 0 } = $$props;
  let { rolloffFactor = void 0 } = $$props;
  let { distanceModel = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const ref = new PositionalAudio(listener);
  const { pause, play, stop, setAutoPlay, setDetune, setLoop, setPlaybackRate, setSrc: setSource, setVolume } = useAudio(ref);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<PositionalAudio> was created without expected prop 'src'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props) $$invalidate(4, src = $$new_props.src);
    if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$new_props) $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$new_props) $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$new_props) $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$new_props) $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$new_props) $$invalidate(10, loop = $$new_props.loop);
    if ("directionalCone" in $$new_props) $$invalidate(11, directionalCone = $$new_props.directionalCone);
    if ("refDistance" in $$new_props) $$invalidate(12, refDistance = $$new_props.refDistance);
    if ("rolloffFactor" in $$new_props) $$invalidate(13, rolloffFactor = $$new_props.rolloffFactor);
    if ("distanceModel" in $$new_props) $$invalidate(14, distanceModel = $$new_props.distanceModel);
    if ("maxDistance" in $$new_props) $$invalidate(15, maxDistance = $$new_props.maxDistance);
    if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    ThreePositionalAudio: PositionalAudio,
    useAudio,
    useThrelteAudio,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    getAudioListener,
    listener,
    ref,
    pause,
    play,
    stop,
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSource,
    setVolume,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props) $$invalidate(4, src = $$new_props.src);
    if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$props) $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$props) $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$props) $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$props) $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$props) $$invalidate(10, loop = $$new_props.loop);
    if ("directionalCone" in $$props) $$invalidate(11, directionalCone = $$new_props.directionalCone);
    if ("refDistance" in $$props) $$invalidate(12, refDistance = $$new_props.refDistance);
    if ("rolloffFactor" in $$props) $$invalidate(13, rolloffFactor = $$new_props.rolloffFactor);
    if ("distanceModel" in $$props) $$invalidate(14, distanceModel = $$new_props.distanceModel);
    if ("maxDistance" in $$props) $$invalidate(15, maxDistance = $$new_props.maxDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    63488) {
      $: {
        if (refDistance !== void 0) ref.setRefDistance(refDistance);
        if (rolloffFactor !== void 0) ref.setRolloffFactor(rolloffFactor);
        if (distanceModel !== void 0) ref.setDistanceModel(distanceModel);
        if (maxDistance !== void 0) ref.setMaxDistance(maxDistance);
        if (directionalCone !== void 0) {
          ref.setDirectionalCone(directionalCone.coneInnerAngle, directionalCone.coneOuterAngle, directionalCone.coneOuterGain);
        }
      }
    }
    if ($$self.$$.dirty & /*autoplay*/
    256) {
      $: setAutoPlay(autoplay);
    }
    if ($$self.$$.dirty & /*src*/
    16) {
      $: setSource(src);
    }
    if ($$self.$$.dirty & /*volume*/
    64) {
      $: setVolume(volume);
    }
    if ($$self.$$.dirty & /*playbackRate*/
    128) {
      $: setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty & /*loop*/
    1024) {
      $: setLoop(loop);
    }
    if ($$self.$$.dirty & /*detune*/
    512) {
      $: setDetune(detune);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    pause,
    play,
    stop,
    slots,
    t_binding,
    $$scope
  ];
}
var PositionalAudio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      directionalCone: 11,
      refDistance: 12,
      rolloffFactor: 13,
      distanceModel: 14,
      maxDistance: 15,
      ref: 0,
      pause: 16,
      play: 17,
      stop: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudio",
      options,
      id: create_fragment41.name
    });
  }
  get src() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionalCone() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionalCone(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refDistance() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refDistance(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rolloffFactor() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rolloffFactor(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceModel() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceModel(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_17("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[16];
  }
  set pause(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[17];
  }
  set play(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[18];
  }
  set stop(value) {
    throw new Error_17("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PositionalAudio_default = PositionalAudio2;

// node_modules/@threlte/extras/dist/audio/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const { getAudioListener } = useThrelteAudio();
  if (callbackOrId && typeof callbackOrId === "string") {
    const listener = getAudioListener(callbackOrId);
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  } else if (callbackOrId && typeof callbackOrId === "function") {
    const listener = getAudioListener(id);
    if (!listener)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener,
      context: listener.context
    });
  } else {
    const listener = getAudioListener();
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  }
}

// node_modules/@threlte/extras/dist/interactivity/defaults.js
var getDefaultComputeFunction = (target) => {
  const { camera } = useThrelte();
  let width = target.current.clientWidth;
  let height = target.current.clientHeight;
  const resizeObserver = new ResizeObserver(([entry]) => {
    width = entry.contentRect.width;
    height = entry.contentRect.height;
  });
  watch(target, (target2) => {
    if (target2)
      resizeObserver.observe(target2);
    return () => {
      if (target2)
        resizeObserver.unobserve(target2);
    };
  });
  return (event, state) => {
    state.pointer.update((pointer) => {
      pointer.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
      return pointer;
    });
    state.raycaster.setFromCamera(state.pointer.current, camera.current);
  };
};

// node_modules/@threlte/extras/dist/interactivity/context.js
var contextKey = Symbol("interactivity-context");
var getInteractivityContext = () => {
  return getContext(contextKey);
};
var setInteractivityContext = (options) => {
  const target = currentWritable((options == null ? void 0 : options.target) ?? useThrelte().renderer.domElement);
  const context = {
    enabled: currentWritable((options == null ? void 0 : options.enabled) ?? true),
    pointer: currentWritable(new Vector2()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target,
    compute: (options == null ? void 0 : options.compute) ?? getDefaultComputeFunction(target),
    filter: options == null ? void 0 : options.filter
  };
  setContext(contextKey, context);
  return context;
};
var handlerContextKey = Symbol("interactivity-handler-context");
var getHandlerContext = () => {
  return getContext(handlerContextKey);
};
var setHandlerContext = () => {
  setContext(handlerContextKey, {
    dispatchers: /* @__PURE__ */ new WeakMap()
  });
};

// node_modules/@threlte/extras/dist/interactivity/hook.js
var useInteractivity = () => {
  const context = getInteractivityContext();
  const { dispatchers } = getHandlerContext();
  if (!context) {
    throw new Error("No interactivity context found. Did you forget to implement interactivity()?");
  }
  const eventDispatcher = createRawEventDispatcher();
  const addInteractiveObject = (object) => {
    if (context.interactiveObjects.indexOf(object) > -1) {
      return;
    }
    dispatchers.set(object, eventDispatcher);
    context.interactiveObjects.push(object);
  };
  const removeInteractiveObject = (object) => {
    const index = context.interactiveObjects.indexOf(object);
    context.interactiveObjects.splice(index, 1);
    dispatchers.delete(object);
  };
  return {
    ...context,
    addInteractiveObject,
    removeInteractiveObject
  };
};

// node_modules/@threlte/extras/dist/interactivity/useComponentHasEventHandlers.js
var useComponentHasEventHandlers = (eventNames) => {
  const component = get_current_component();
  const hasEventHandlers = writable(false);
  onMount(() => {
    hasEventHandlers.set(Object.keys(component.$$.callbacks).some((value) => eventNames.includes(value)));
  });
  return {
    hasEventHandlers
  };
};

// node_modules/@threlte/extras/dist/interactivity/plugin.js
var interactivityEventNames = [
  "click",
  "contextmenu",
  "dblclick",
  "wheel",
  "pointerup",
  "pointerdown",
  "pointerover",
  "pointerout",
  "pointerenter",
  "pointerleave",
  "pointermove",
  "pointermissed"
];
var injectInteractivityPlugin = () => {
  injectPlugin("interactivity", ({ ref }) => {
    if (!ref.isObject3D)
      return;
    const { addInteractiveObject, removeInteractiveObject } = useInteractivity();
    const refStore = writable(ref);
    const { hasEventHandlers } = useComponentHasEventHandlers(interactivityEventNames);
    watch([hasEventHandlers, refStore], ([hasEventHandlers2, ref2]) => {
      if (!hasEventHandlers2)
        return;
      addInteractiveObject(ref2);
      return () => removeInteractiveObject(ref2);
    });
    return {
      onRefChange(ref2) {
        refStore.set(ref2);
      }
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/setupInteractivity.js
function getIntersectionId(event) {
  return `${(event.eventObject || event.object).uuid}/${event.index}${event.instanceId}`;
}
var DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true]
];
var setupInteractivity = (context) => {
  const { dispatchers } = getHandlerContext();
  const calculateDistance = (event) => {
    const dx = event.offsetX - context.initialClick[0];
    const dy = event.offsetY - context.initialClick[1];
    return Math.round(Math.hypot(dx, dy));
  };
  const cancelPointer = (intersections) => {
    for (const hoveredObj of context.hovered.values()) {
      if (intersections.length === 0 || !intersections.some((hit) => {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId;
      })) {
        const { eventObject } = hoveredObj;
        context.hovered.delete(getIntersectionId(hoveredObj));
        const eventDispatcher = dispatchers.get(eventObject);
        if (eventDispatcher) {
          const data = { ...hoveredObj, intersections };
          eventDispatcher("pointerout", data);
          eventDispatcher("pointerleave", data);
        }
      }
    }
  };
  const enabled = memoize(context.enabled);
  const getHits = () => {
    if (!enabled.current)
      return [];
    const intersections = [];
    const hits = context.raycaster.intersectObjects(context.interactiveObjects, true);
    const filtered = context.filter === void 0 ? hits : context.filter(hits, context);
    for (const hit of filtered) {
      let eventObject = hit.object;
      while (eventObject) {
        if (dispatchers.has(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  const pointerMissed = (event, objects) => {
    var _a;
    for (const object of objects) {
      (_a = dispatchers.get(object)) == null ? void 0 : _a("pointermissed", event);
    }
  };
  const getEventHandler = (name) => {
    if (name === "pointerleave" || name === "pointercancel") {
      return () => {
        context.pointerOverTarget.set(false);
        cancelPointer([]);
      };
    }
    if (name === "pointerenter") {
      return () => {
        context.pointerOverTarget.set(true);
      };
    }
    return (event) => {
      const isPointerMove = name === "pointermove";
      const isClickEvent = name === "click" || name === "contextmenu" || name === "dblclick";
      context.compute(event, context);
      const hits = getHits();
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "pointerdown") {
        context.initialClick = [event.offsetX, event.offsetY];
        context.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && hits.length === 0) {
        if (delta <= 2) {
          pointerMissed(event, context.interactiveObjects);
        }
      }
      if (isPointerMove)
        cancelPointer(hits);
      let stopped = false;
      dispatchEvents: for (const hit of hits) {
        const intersectionEvent = {
          stopped,
          ...hit,
          intersections: hits,
          stopPropagation() {
            stopped = true;
            intersectionEvent.stopped = true;
            if (context.hovered.size > 0 && Array.from(context.hovered.values()).some((i) => i.eventObject === hit.eventObject)) {
              const higher = hits.slice(0, hits.indexOf(hit));
              cancelPointer([...higher, hit]);
            }
          },
          camera: context.raycaster.camera,
          delta,
          nativeEvent: event,
          pointer: context.pointer.current,
          ray: context.raycaster.ray
        };
        const eventDispatcher = dispatchers.get(hit.eventObject);
        if (!eventDispatcher)
          return;
        if (isPointerMove) {
          if (eventDispatcher.hasEventListener("pointerover") || eventDispatcher.hasEventListener("pointerenter") || eventDispatcher.hasEventListener("pointerout") || eventDispatcher.hasEventListener("pointerleave")) {
            const id = getIntersectionId(intersectionEvent);
            const hoveredItem = context.hovered.get(id);
            if (!hoveredItem) {
              context.hovered.set(id, intersectionEvent);
              eventDispatcher("pointerover", intersectionEvent);
              eventDispatcher("pointerenter", intersectionEvent);
            } else if (hoveredItem.stopped) {
              intersectionEvent.stopPropagation();
            }
          }
          eventDispatcher("pointermove", intersectionEvent);
        } else {
          const hasEventListener = eventDispatcher.hasEventListener(name);
          if (hasEventListener) {
            if (!isClickEvent || context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
              eventDispatcher(name, intersectionEvent);
            }
          } else {
            if (isClickEvent && context.initialHits.includes(hit.eventObject)) {
              pointerMissed(event, context.interactiveObjects.filter((object) => !context.initialHits.includes(object)));
            }
          }
        }
        if (stopped)
          break dispatchEvents;
      }
    };
  };
  const disconnect = (target) => {
    DOM_EVENTS.forEach(([eventName]) => {
      target.removeEventListener(eventName, getEventHandler(eventName));
    });
  };
  const connect = (target) => {
    DOM_EVENTS.forEach(([eventName, passive]) => {
      target.addEventListener(eventName, getEventHandler(eventName), { passive });
    });
  };
  watch(context.target, (target) => {
    if (target)
      connect(target);
    return () => {
      if (target)
        disconnect(target);
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/index.js
var interactivity = (options) => {
  setHandlerContext();
  const context = setInteractivityContext(options);
  injectInteractivityPlugin();
  setupInteractivity(context);
  return context;
};

// node_modules/@threlte/extras/dist/transitions/transitions-plugin.js
var fragmentFunctions = {
  create: "c",
  claim: "l",
  hydrate: "h",
  mount: "m",
  update: "p",
  measure: "r",
  fix: "f",
  animate: "a",
  intro: "i",
  outro: "o",
  destroy: "d"
};
var appendToFragmentFunction = (component, fragmentFn, append) => {
  const fragment = component.$$.fragment;
  const fragmentFnShorthand = fragmentFunctions[fragmentFn];
  const original = fragment[fragmentFnShorthand];
  fragment[fragmentFnShorthand] = (...args) => {
    append(...args);
    original(...args);
  };
};
var transitions = () => {
  injectPlugin("transitions", ({ ref, props }) => {
    if (!props.in && !props.out && !props.transition)
      return;
    const { invalidate } = useThrelte();
    const dispatch = createRawEventDispatcher();
    let currentRef = ref;
    const el = {
      style: {},
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      dispatchEvent: (...args) => {
        const eventType = args[0].type;
        dispatch(eventType, ...args);
      }
    };
    const comp = get_current_component();
    const convertTransition = (transition) => {
      return (_node, _params, options) => {
        const t2 = transition(currentRef, {
          direction: options.direction
        });
        return {
          ...t2,
          tick(...args) {
            var _a;
            invalidate();
            (_a = t2 == null ? void 0 : t2.tick) == null ? void 0 : _a.call(t2, ...args);
          }
        };
      };
    };
    if (props.transition) {
      let transition;
      onMount(() => {
        add_render_callback(() => {
          if (!transition) {
            if (!props.transition)
              return;
            transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, true);
          }
          transition.run(1);
        });
        appendToFragmentFunction(comp, "intro", () => {
          add_render_callback(() => {
            if (!transition) {
              if (!props.transition)
                return;
              transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, true);
            }
            transition.run(1);
          });
        });
        appendToFragmentFunction(comp, "outro", () => {
          if (!transition) {
            if (!props.transition)
              return;
            transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, false);
          }
          transition.run(0);
        });
        appendToFragmentFunction(comp, "destroy", (...args) => {
          const detaching = args[0];
          if (detaching && transition)
            transition.end();
        });
      });
    } else {
      if (props.in) {
        let intro;
        onMount(() => {
          add_render_callback(() => {
            if (!props.in)
              return;
            intro = create_in_transition(el, convertTransition(props.in), {});
            intro.start();
          });
          appendToFragmentFunction(comp, "outro", () => {
            intro == null ? void 0 : intro.end();
          });
        });
      }
      if (props.out) {
        let outro;
        onMount(() => {
          appendToFragmentFunction(comp, "outro", () => {
            if (!props.out)
              return;
            outro = create_out_transition(el, convertTransition(props.out), {});
          });
          appendToFragmentFunction(comp, "intro", () => {
            outro == null ? void 0 : outro.end(1);
          });
          appendToFragmentFunction(comp, "destroy", (...args) => {
            const detaching = args[0];
            if (detaching && outro)
              outro.end(0);
          });
        });
      }
    }
    return {
      onRefChange(ref2) {
        currentRef = ref2;
      },
      pluginProps: ["in", "out", "transition"]
    };
  });
};

// node_modules/@threlte/extras/dist/transitions/createTransition.js
var createTransition = (transition) => transition;

// node_modules/@threlte/extras/dist/layers/plugin.js
var isObject3D2 = (ref) => {
  return ref.isObject3D;
};
var propIsThrelteLayers = (prop) => {
  return prop === "all" || prop === "none" || Array.isArray(prop) && prop.every((v) => typeof v === "number") || typeof prop === "number" && prop >= 0 && prop <= 31;
};
var injectLayersPlugin = () => {
  injectPlugin("layers", ({ ref, props }) => {
    if (!isObject3D2(ref))
      return;
    const local = writable(props.layers && propIsThrelteLayers(props.layers) ? props.layers : void 0);
    const ctx = getContext("threlte-layers-context");
    const merged = derived([local, ctx], ([prop, ctx2]) => prop ?? ctx2);
    setContext("threlte-layers-context", merged);
    const applyLayers = (ref2, layers2) => {
      if (layers2 === "all") {
        ref2.layers.enableAll();
      } else if (layers2 === "none") {
        ref2.layers.disableAll();
      } else if (Array.isArray(layers2)) {
        for (let index = 0; index < 32; index += 1) {
          const layerIndex = index;
          const enabled = layers2.includes(layerIndex);
          if (enabled) {
            ref2.layers.enable(index);
          } else {
            ref2.layers.disable(index);
          }
        }
      } else if (layers2 !== void 0) {
        ref2.layers.set(layers2);
      }
    };
    const refStore = writable(ref);
    watch([refStore, merged], ([ref2, layers2]) => {
      applyLayers(ref2, layers2);
    });
    return {
      onRestPropsChange(restProps) {
        local.set(restProps.layers && propIsThrelteLayers(restProps.layers) ? restProps.layers : void 0);
      },
      onRefChange(ref2) {
        if (!isObject3D2(ref2))
          return;
        refStore.set(ref2);
      },
      pluginProps: ["layers"]
    };
  });
};

// node_modules/@threlte/extras/dist/layers/index.js
var layers = (options) => {
  const local = writable((options == null ? void 0 : options.defaultLayers) ?? 0);
  setContext("threlte-layers-context", local);
  injectLayersPlugin();
};

// node_modules/@threlte/extras/dist/components/InstancedSprite/SpriteInstance.svelte
function create_fragment42(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SpriteInstance", slots, []);
  const spriteCtx = getContext("instanced-sprite-ctx");
  const { updatePosition, sprite } = spriteCtx;
  let { id = 0 } = $$props;
  let { position = [0, 0, 0] } = $$props;
  let { scale = [1, 1] } = $$props;
  let { animationName = void 0 } = $$props;
  let { playmode = void 0 } = $$props;
  let { billboarding = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { flipX = void 0 } = $$props;
  let { flipY = void 0 } = $$props;
  let { frameId = void 0 } = $$props;
  const writable_props = [
    "id",
    "position",
    "scale",
    "animationName",
    "playmode",
    "billboarding",
    "offset",
    "loop",
    "flipX",
    "flipY",
    "frameId"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SpriteInstance> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2) $$invalidate(2, scale = $$props2.scale);
    if ("animationName" in $$props2) $$invalidate(3, animationName = $$props2.animationName);
    if ("playmode" in $$props2) $$invalidate(4, playmode = $$props2.playmode);
    if ("billboarding" in $$props2) $$invalidate(5, billboarding = $$props2.billboarding);
    if ("offset" in $$props2) $$invalidate(6, offset = $$props2.offset);
    if ("loop" in $$props2) $$invalidate(7, loop = $$props2.loop);
    if ("flipX" in $$props2) $$invalidate(8, flipX = $$props2.flipX);
    if ("flipY" in $$props2) $$invalidate(9, flipY = $$props2.flipY);
    if ("frameId" in $$props2) $$invalidate(10, frameId = $$props2.frameId);
  };
  $$self.$capture_state = () => ({
    getContext,
    spriteCtx,
    updatePosition,
    sprite,
    id,
    position,
    scale,
    animationName,
    playmode,
    billboarding,
    offset,
    loop,
    flipX,
    flipY,
    frameId
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2) $$invalidate(2, scale = $$props2.scale);
    if ("animationName" in $$props2) $$invalidate(3, animationName = $$props2.animationName);
    if ("playmode" in $$props2) $$invalidate(4, playmode = $$props2.playmode);
    if ("billboarding" in $$props2) $$invalidate(5, billboarding = $$props2.billboarding);
    if ("offset" in $$props2) $$invalidate(6, offset = $$props2.offset);
    if ("loop" in $$props2) $$invalidate(7, loop = $$props2.loop);
    if ("flipX" in $$props2) $$invalidate(8, flipX = $$props2.flipX);
    if ("flipY" in $$props2) $$invalidate(9, flipY = $$props2.flipY);
    if ("frameId" in $$props2) $$invalidate(10, frameId = $$props2.frameId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*position, id, scale*/
    7) {
      $: position !== void 0 && updatePosition(id, position, scale);
    }
    if ($$self.$$.dirty & /*animationName, id*/
    9) {
      $: animationName !== void 0 && sprite.animation.setAt(id, animationName);
    }
    if ($$self.$$.dirty & /*playmode, id*/
    17) {
      $: playmode !== void 0 && sprite.playmode.setAt(id, playmode);
    }
    if ($$self.$$.dirty & /*billboarding, id*/
    33) {
      $: billboarding !== void 0 && sprite.billboarding.setAt(id, billboarding);
    }
    if ($$self.$$.dirty & /*offset, id*/
    65) {
      $: offset !== void 0 && sprite.offset.setAt(id, offset);
    }
    if ($$self.$$.dirty & /*loop, id*/
    129) {
      $: loop !== void 0 && sprite.loop.setAt(id, loop);
    }
    if ($$self.$$.dirty & /*flipX, id*/
    257) {
      $: flipX !== void 0 && sprite.flipX.setAt(id, flipX);
    }
    if ($$self.$$.dirty & /*flipY, id*/
    513) {
      $: flipY !== void 0 && sprite.flipY.setAt(id, flipY);
    }
    if ($$self.$$.dirty & /*frameId, id, animationName*/
    1033) {
      $: frameId !== void 0 && sprite.frame.setAt(id, frameId, animationName);
    }
  };
  return [
    id,
    position,
    scale,
    animationName,
    playmode,
    billboarding,
    offset,
    loop,
    flipX,
    flipY,
    frameId
  ];
}
var SpriteInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {
      id: 0,
      position: 1,
      scale: 2,
      animationName: 3,
      playmode: 4,
      billboarding: 5,
      offset: 6,
      loop: 7,
      flipX: 8,
      flipY: 9,
      frameId: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SpriteInstance",
      options,
      id: create_fragment42.name
    });
  }
  get id() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animationName() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animationName(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playmode() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playmode(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get billboarding() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set billboarding(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipX() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipX(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipY() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipY(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frameId() {
    throw new Error("<SpriteInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frameId(value) {
    throw new Error("<SpriteInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SpriteInstance_default = SpriteInstance;

// node_modules/@threlte/extras/dist/components/InstancedSprite/InstancedSprite.svelte
var get_default_slot_changes29 = (dirty) => ({});
var get_default_slot_context29 = (ctx) => ({
  Instance: (
    /*proxySpritefileComponent*/
    ctx[3]
  )
});
function create_default_slot33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context29
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes29
            ),
            get_default_slot_context29
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot33.name,
    type: "slot",
    source: "(115:0) <T   is={ref}   frustumCulled={false}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    { frustumCulled: false },
    /*$$restProps*/
    ctx[4]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      17 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        t_spread_levels[1],
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      131072) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "autoUpdate",
    "baseMaterial",
    "fps",
    "billboarding",
    "playmode",
    "count",
    "alphaTest",
    "transparent",
    "hueShift",
    "randomPlaybackOffset",
    "spritesheet",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $playmodeStore;
  let $billboardingStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedSprite", slots, ["default"]);
  const g3 = new Mesh();
  g3.material;
  let { autoUpdate = true } = $$props;
  let { baseMaterial = MeshBasicMaterial } = $$props;
  let { fps = 15 } = $$props;
  let { billboarding } = $$props;
  let { playmode = "FORWARD" } = $$props;
  let { count = 1e3 } = $$props;
  let { alphaTest = 0.1 } = $$props;
  let { transparent = true } = $$props;
  let { hueShift = void 0 } = $$props;
  let { randomPlaybackOffset = false } = $$props;
  let { spritesheet } = $$props;
  const spriteBaseMaterial = new baseMaterial({
    transparent,
    alphaTest,
    // needs to be double side for shading
    side: DoubleSide
  });
  const { renderer } = useThrelte();
  let { ref = new Xt(spriteBaseMaterial, count, renderer) } = $$props;
  const animationMap = writable(/* @__PURE__ */ new Map());
  const billboardingStore = writable(void 0);
  validate_store(billboardingStore, "billboardingStore");
  component_subscribe($$self, billboardingStore, (value) => $$invalidate(21, $billboardingStore = value));
  watch([billboardingStore], () => {
    if ($billboardingStore === void 0) {
      ref.billboarding.unsetAll();
      return;
    } else {
      ref.billboarding.setAll($billboardingStore);
    }
  });
  const playmodeStore = writable(void 0);
  validate_store(playmodeStore, "playmodeStore");
  component_subscribe($$self, playmodeStore, (value) => $$invalidate(20, $playmodeStore = value));
  watch([playmodeStore], () => {
    if ($playmodeStore === void 0) {
      ref.playmode.setAll("PAUSE");
      return;
    } else {
      ref.playmode.setAll($playmodeStore);
    }
  });
  const rndOffsetStore = writable(randomPlaybackOffset);
  let previousRndOffset = false;
  watch([rndOffsetStore], ([offset]) => {
    if (previousRndOffset === false && offset) {
      ref.offset.randomizeAll(offset === true ? 100 : offset);
    }
    if (previousRndOffset === true && !offset) {
      for (let i = 0; i < count; i++) {
        ref.offset.setAt(i, 0);
      }
    }
    previousRndOffset = offset ? true : false;
  });
  let instanceMatrixNeedsUpdate = false;
  const tempMatrix = new Matrix4();
  const updatePosition = (id, position, scale = [1, 1]) => {
    tempMatrix.makeScale(scale[0], scale[1], 1);
    tempMatrix.setPosition(...position);
    ref.setMatrixAt(id, tempMatrix);
    instanceMatrixNeedsUpdate = true;
  };
  setContext("instanced-sprite-ctx", {
    sprite: ref,
    count,
    animationMap,
    updatePosition
  });
  useTask(() => {
    if (autoUpdate) {
      ref.update();
    }
    if (instanceMatrixNeedsUpdate) {
      $$invalidate(0, ref.instanceMatrix.needsUpdate = true, ref);
      instanceMatrixNeedsUpdate = false;
    }
  });
  const proxySpritefileComponent = new Proxy(
    SpriteInstance_default,
    {
      construct(_target, [args]) {
        return new SpriteInstance_default(args);
      }
    }
  );
  $$self.$$.on_mount.push(function() {
    if (billboarding === void 0 && !("billboarding" in $$props || $$self.$$.bound[$$self.$$.props["billboarding"]])) {
      console.warn("<InstancedSprite> was created without expected prop 'billboarding'");
    }
    if (spritesheet === void 0 && !("spritesheet" in $$props || $$self.$$.bound[$$self.$$.props["spritesheet"]])) {
      console.warn("<InstancedSprite> was created without expected prop 'spritesheet'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("autoUpdate" in $$new_props) $$invalidate(5, autoUpdate = $$new_props.autoUpdate);
    if ("baseMaterial" in $$new_props) $$invalidate(6, baseMaterial = $$new_props.baseMaterial);
    if ("fps" in $$new_props) $$invalidate(7, fps = $$new_props.fps);
    if ("billboarding" in $$new_props) $$invalidate(8, billboarding = $$new_props.billboarding);
    if ("playmode" in $$new_props) $$invalidate(9, playmode = $$new_props.playmode);
    if ("count" in $$new_props) $$invalidate(10, count = $$new_props.count);
    if ("alphaTest" in $$new_props) $$invalidate(11, alphaTest = $$new_props.alphaTest);
    if ("transparent" in $$new_props) $$invalidate(12, transparent = $$new_props.transparent);
    if ("hueShift" in $$new_props) $$invalidate(13, hueShift = $$new_props.hueShift);
    if ("randomPlaybackOffset" in $$new_props) $$invalidate(14, randomPlaybackOffset = $$new_props.randomPlaybackOffset);
    if ("spritesheet" in $$new_props) $$invalidate(15, spritesheet = $$new_props.spritesheet);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    InstancedSpriteMesh: Xt,
    PLAY_MODE: K,
    T,
    useTask,
    useThrelte,
    watch,
    DoubleSide,
    Matrix4,
    Mesh,
    MeshBasicMaterial,
    setContext,
    writable,
    SpriteInstance: SpriteInstance_default,
    g: g3,
    autoUpdate,
    baseMaterial,
    fps,
    billboarding,
    playmode,
    count,
    alphaTest,
    transparent,
    hueShift,
    randomPlaybackOffset,
    spritesheet,
    spriteBaseMaterial,
    renderer,
    ref,
    animationMap,
    billboardingStore,
    playmodeStore,
    rndOffsetStore,
    previousRndOffset,
    instanceMatrixNeedsUpdate,
    tempMatrix,
    updatePosition,
    proxySpritefileComponent,
    $playmodeStore,
    $billboardingStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("autoUpdate" in $$props) $$invalidate(5, autoUpdate = $$new_props.autoUpdate);
    if ("baseMaterial" in $$props) $$invalidate(6, baseMaterial = $$new_props.baseMaterial);
    if ("fps" in $$props) $$invalidate(7, fps = $$new_props.fps);
    if ("billboarding" in $$props) $$invalidate(8, billboarding = $$new_props.billboarding);
    if ("playmode" in $$props) $$invalidate(9, playmode = $$new_props.playmode);
    if ("count" in $$props) $$invalidate(10, count = $$new_props.count);
    if ("alphaTest" in $$props) $$invalidate(11, alphaTest = $$new_props.alphaTest);
    if ("transparent" in $$props) $$invalidate(12, transparent = $$new_props.transparent);
    if ("hueShift" in $$props) $$invalidate(13, hueShift = $$new_props.hueShift);
    if ("randomPlaybackOffset" in $$props) $$invalidate(14, randomPlaybackOffset = $$new_props.randomPlaybackOffset);
    if ("spritesheet" in $$props) $$invalidate(15, spritesheet = $$new_props.spritesheet);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("previousRndOffset" in $$props) previousRndOffset = $$new_props.previousRndOffset;
    if ("instanceMatrixNeedsUpdate" in $$props) instanceMatrixNeedsUpdate = $$new_props.instanceMatrixNeedsUpdate;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*spritesheet, ref*/
    32769) {
      $: {
        if (spritesheet) {
          $$invalidate(0, ref.spritesheet = spritesheet.spritesheet, ref);
          animationMap.set(ref.animationMap);
          $$invalidate(0, ref.material.map = spritesheet.texture, ref);
          $$invalidate(0, ref.material.needsUpdate = true, ref);
        }
      }
    }
    if ($$self.$$.dirty & /*alphaTest*/
    2048) {
      $: $$invalidate(0, ref.material.alphaTest = alphaTest, ref);
    }
    if ($$self.$$.dirty & /*transparent*/
    4096) {
      $: $$invalidate(0, ref.material.transparent = transparent, ref);
    }
    if ($$self.$$.dirty & /*fps*/
    128) {
      $: $$invalidate(0, ref.fps = fps, ref);
    }
    if ($$self.$$.dirty & /*ref, hueShift*/
    8193) {
      $: ref.hueShift.setGlobal(hueShift);
    }
    if ($$self.$$.dirty & /*billboarding*/
    256) {
      $: billboardingStore.set(billboarding);
    }
    if ($$self.$$.dirty & /*playmode*/
    512) {
      $: playmodeStore.set(playmode);
    }
    if ($$self.$$.dirty & /*randomPlaybackOffset*/
    16384) {
      $: rndOffsetStore.set(randomPlaybackOffset);
    }
  };
  return [
    ref,
    billboardingStore,
    playmodeStore,
    proxySpritefileComponent,
    $$restProps,
    autoUpdate,
    baseMaterial,
    fps,
    billboarding,
    playmode,
    count,
    alphaTest,
    transparent,
    hueShift,
    randomPlaybackOffset,
    spritesheet,
    slots,
    $$scope
  ];
}
var InstancedSprite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      autoUpdate: 5,
      baseMaterial: 6,
      fps: 7,
      billboarding: 8,
      playmode: 9,
      count: 10,
      alphaTest: 11,
      transparent: 12,
      hueShift: 13,
      randomPlaybackOffset: 14,
      spritesheet: 15,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedSprite",
      options,
      id: create_fragment43.name
    });
  }
  get autoUpdate() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoUpdate(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseMaterial() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseMaterial(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fps() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fps(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get billboarding() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set billboarding(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playmode() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playmode(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alphaTest() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alphaTest(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transparent() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transparent(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hueShift() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hueShift(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get randomPlaybackOffset() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set randomPlaybackOffset(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spritesheet() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spritesheet(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<InstancedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<InstancedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedSprite_default = InstancedSprite;

// node_modules/@threlte/extras/dist/components/InstancedSprite/instancedSpriteUtils.js
var useInstancedSprite = () => {
  return getContext("instanced-sprite-ctx");
};
var from = (meta) => {
  const builder = Jt();
  const animationsList = [];
  for (const { url, type, width, height, animations } of meta) {
    for (const animation of animations) {
      animationsList.push(animation.name);
    }
    builder.add(url, {
      type,
      width,
      height
    }, animations);
  }
  const spritesheet = builder.build();
  const typedHook = useInstancedSprite;
  return { spritesheet, useInstancedSprite: typedHook };
};
var fromAseprite = (asepriteDataUrl, spriteImageUrl) => {
  const texture = new TextureLoader().load(spriteImageUrl, (t2) => {
    t2.matrixAutoUpdate = false;
    t2.generateMipmaps = false;
    t2.premultiplyAlpha = false;
    t2.wrapS = texture.wrapT = RepeatWrapping;
    t2.magFilter = texture.minFilter = NearestFilter;
    t2.colorSpace = SRGBColorSpace;
    t2.needsUpdate = true;
  });
  const parse = async () => {
    const res = await fetch(asepriteDataUrl);
    const json = await res.json();
    return { spritesheet: Yt(json), texture };
  };
  return parse();
};
var buildSpritesheet = { from, fromAseprite };
export {
  Align_default as Align,
  AnimatedSpriteMaterial_default as AnimatedSpriteMaterial,
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  Billboard_default as Billboard,
  CSM_default as CSM,
  ContactShadows_default as ContactShadows,
  Edges_default as Edges,
  Environment_default as Environment,
  FakeGlowMaterial_default as FakeGlowMaterial,
  Float_default as Float,
  GLTF_default as GLTF,
  Gizmo_default as Gizmo,
  Grid_default as Grid,
  HTML_default as HTML,
  ImageMaterial_default as ImageMaterial,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  InstancedMeshes_default as InstancedMeshes,
  InstancedSprite_default as InstancedSprite,
  Mask_default as Mask,
  MeshLineGeometry_default as MeshLineGeometry,
  MeshLineMaterial_default as MeshLineMaterial,
  MeshRefractionMaterial_default as MeshRefractionMaterial,
  OrbitControls_default as OrbitControls,
  Outlines_default as Outlines,
  PerfMonitor_default as PerfMonitor,
  Portal_default as Portal,
  PortalTarget_default as PortalTarget,
  PositionalAudio_default as PositionalAudio,
  RoundedBoxGeometry_default as RoundedBoxGeometry,
  Sky_default as Sky,
  SoftShadows_default as SoftShadows,
  Stars_default as Stars,
  Suspense_default as Suspense,
  Text_default as Text,
  Text3DGeometry_default as Text3DGeometry,
  TrackballControls_default as TrackballControls,
  TransformControls_default as TransformControls,
  buildSpritesheet,
  createTransition,
  interactivity,
  layers,
  onReveal,
  onSuspend,
  transitions,
  useAudioListener,
  useCursor,
  useFBO,
  useGamepad,
  useGltf,
  useGltfAnimations,
  useInstancedSprite,
  useInteractivity,
  useMask,
  useProgress,
  useSuspense,
  useTexture,
  useThrelteAudio
};
/*! Bundled license information:

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
  (*!
  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
  for use in Troika text rendering. 
  Original MIT license applies
  *)
*/
//# sourceMappingURL=@threlte_extras.js.map
